{
    "docs": [
        {
            "location": "/index.html", 
            "text": "The Art of Packet crafting with Scapy", 
            "title": "Title"
        }, 
        {
            "location": "/index.html#the-art-of-packet-crafting-with-scapy", 
            "text": "", 
            "title": "The Art of Packet crafting with Scapy"
        }, 
        {
            "location": "/license/index.html", 
            "text": "License \n Attributions\n\n\n\n\n\n\n\n\n\nExcept as otherwise noted, the content of this workshop is licensed under the \nCreative Commons Attribution-Share Alike 4.0 International License\n , and code samples are licensed under the \nApache 2.0 License\n .", 
            "title": "License"
        }, 
        {
            "location": "/license/index.html#license-attributions", 
            "text": "Except as otherwise noted, the content of this workshop is licensed under the  Creative Commons Attribution-Share Alike 4.0 International License  , and code samples are licensed under the  Apache 2.0 License  .", 
            "title": "License &amp; Attributions"
        }, 
        {
            "location": "/bigger_picture/index.html", 
            "text": "", 
            "title": "Bigger picture"
        }, 
        {
            "location": "/speakers/index.html", 
            "text": "Speakers\n\n\nBharath\n\n\nWebpage  \n: \nDisruptivelabs.in\n\nTwitter\n \n  \n  : \ntwitter.com/yamakira_\n\nGithub \n \n   :", 
            "title": "Speakers"
        }, 
        {
            "location": "/speakers/index.html#speakers", 
            "text": "", 
            "title": "Speakers"
        }, 
        {
            "location": "/speakers/index.html#bharath", 
            "text": "Webpage   :  Disruptivelabs.in \nTwitter        :  twitter.com/yamakira_ \nGithub       :", 
            "title": "Bharath"
        }, 
        {
            "location": "/workshop_settings/index.html", 
            "text": "Settings\n\n\nThe Goal\n\n\n\n\nUnderstanding packet crafting and crafting packets with scapy\n\n\nUnderstanding common attacks and analysis techniques, implementing with scapy.\n\n\nWriting custom tools using scapy framework!\n\n\nHave fun while programming and solving challenges!\n\n\n\n\nQuestions\n\n\n\n\nRTFM\n\n\nAsk them when you got them.\n\n\nIt\ns easy to get lost so \ntry not to be on auto pilot mode\n.\n\n\npythonhumla@gmail.com\n\n\n\n\nWorkshop\n\n\n\n\nMeter wide \n Mile deep!\n\n\nPentesters point of view.\n\n\nMinimal theory, maximal hands-on.\n\n\nProgramming experience in Python preferred but it\ns possible to follow even without it.\n\n\nPython 2.7.x\n\n\n\n\nFor more on Python 2.x vs 3.x \nPython 2.x vs 3.x\n\n\n\n\n\n\n\n\nFood for thought:\n\n \nWhich one might happen first:\n\n        \n \n Complete IPv6 deployment\n\n        \n \n Python 3.x adaptation\n\n        \n \n Half life 3??", 
            "title": "Workshop settings"
        }, 
        {
            "location": "/workshop_settings/index.html#settings", 
            "text": "", 
            "title": "Settings"
        }, 
        {
            "location": "/workshop_settings/index.html#the-goal", 
            "text": "Understanding packet crafting and crafting packets with scapy  Understanding common attacks and analysis techniques, implementing with scapy.  Writing custom tools using scapy framework!  Have fun while programming and solving challenges!", 
            "title": "The Goal"
        }, 
        {
            "location": "/workshop_settings/index.html#questions", 
            "text": "RTFM  Ask them when you got them.  It s easy to get lost so  try not to be on auto pilot mode .  pythonhumla@gmail.com", 
            "title": "Questions"
        }, 
        {
            "location": "/workshop_settings/index.html#workshop", 
            "text": "Meter wide   Mile deep!  Pentesters point of view.  Minimal theory, maximal hands-on.  Programming experience in Python preferred but it s possible to follow even without it.  Python 2.7.x   For more on Python 2.x vs 3.x  Python 2.x vs 3.x     Food for thought: \n  Which one might happen first: \n            Complete IPv6 deployment \n            Python 3.x adaptation \n            Half life 3??", 
            "title": "Workshop"
        }, 
        {
            "location": "/lab_setup/index.html", 
            "text": "Setting up Virtual Lab\n\n\n\n\n\u201cGive me six hours to chop down a tree and I will spend the first four sharpening the axe.\u201d - Lincoln\n\n\n\n\nVirtualBox / VMWare\n\n\n\n\nOld school way\n\n\nMostly tasks are manual, automation is non-trivial.\n\n\nNo provisioning support through shell, chef or puppet etc\n\n\n\n\nVagrant\n\n\n\n\nBuilds on top of traditional virtualization software(Virtualbox, VMware, AWS\n).\n\n\nFocused on saving environment setup time, disposability.\n\n\nOne command to setup complete environment i.e. create VM, modify properties, configure networking, provide provisiong.\n\n\nWhole environment is built based on one configuration file , which allows version control.\n\n\nSupports provisioning through shell scripts, chef, puppet\n\n\nProvides SSH to communcate with the host.\n\n\n\n\n\n\nTL;DR\n\n\nHit \nvagrant up\n in the mysterious_boxes directory, get your environment up and running!\n\n\n\n\nVagrant Commands:\n\n\nvagrant init\n - Initialize a new vagrant box in the current directory.\n\n\nvagrant up\n - Start an existing vagrant environment \n provision it.\n\n\nvagrant ssh\n - Shell into a running vagrant box.\n \n\nvagrant halt\n - Stop a running vagrant box (shut down).\n \n\nvagrant destroy\n - Completely destroy a vagrant box (delete all).\n\n\nVirtual Lab Setup - Tasks\n\n\nStep I - Installation\n\n\n\n\nInstall \n VirtualBox 5.0\n.\n\n\nInstall \n Vagrant 1.6\n.\n\n\n\n\nStep II - Modify Environmental Variables\n\n\n\n\nChange default \nVAGRANT_HOME\n envi\n variable to point to the newly provided \n.vagrant.d\n folder(where your virtual boxes are).\n\n\n\n\nLinux - BASH\n\n\n$nano ~/.bashrc\n#add the following line at the bottom of the .bashrc file:\nexport VAGRANT_HOME=\n/PATH/TO/.vagrant.d\n \n\n\n\n\n\nFor more on linux environmental variables \nHow to set environmental variables on linux/unix\n \n\n\nWINDOWS - CMD\n\n\nsetx VAGRANT_HOME \nX:/your/path\n\n\n\n\n\nWINDOWS - Powershell\n\n\ncmd /c setx VAGRANT_HOME \nX:/your/path/\n\n\n\n\n\n\n\nWindows - Enviroment variables\n\n\n\n\nIf you need the VAGRANT_HOME to stay across sessions you should do a \nSETX\n command not \nset\non windows cmd or powershell (you need to run it as admin).\n\n\nAbove command adds variable to the User Environment.\n\n\nIf you want to add to the system/machine you need to add the /M option at the end of the command: \nsetx VAGRANT_HOME \"X:/your/path\" /M\n\n\n\n\n\n\nFor more on windows environmental variables \nHow to modify VAGRANT_HOME on windows\n \n\n\nSTEP III - Install SSH client\n\n\nLinux\n\n\nOn Linux there is an SSH client by default. You can simply SSH into the attacker box from host by running \nvagrant ssh\n from mysterious_boxes directory(where you VagrantFile is).\n\n\n\nWindows\n\n\n TBD", 
            "title": "Virtual Lab"
        }, 
        {
            "location": "/lab_setup/index.html#setting-up-virtual-lab", 
            "text": "\u201cGive me six hours to chop down a tree and I will spend the first four sharpening the axe.\u201d - Lincoln", 
            "title": "Setting up Virtual Lab"
        }, 
        {
            "location": "/lab_setup/index.html#virtualbox-vmware", 
            "text": "Old school way  Mostly tasks are manual, automation is non-trivial.  No provisioning support through shell, chef or puppet etc", 
            "title": "VirtualBox / VMWare"
        }, 
        {
            "location": "/lab_setup/index.html#vagrant", 
            "text": "Builds on top of traditional virtualization software(Virtualbox, VMware, AWS ).  Focused on saving environment setup time, disposability.  One command to setup complete environment i.e. create VM, modify properties, configure networking, provide provisiong.  Whole environment is built based on one configuration file , which allows version control.  Supports provisioning through shell scripts, chef, puppet  Provides SSH to communcate with the host.    TL;DR  Hit  vagrant up  in the mysterious_boxes directory, get your environment up and running!", 
            "title": "Vagrant"
        }, 
        {
            "location": "/lab_setup/index.html#vagrant-commands", 
            "text": "vagrant init  - Initialize a new vagrant box in the current directory.  vagrant up  - Start an existing vagrant environment   provision it.  vagrant ssh  - Shell into a running vagrant box.   vagrant halt  - Stop a running vagrant box (shut down).   vagrant destroy  - Completely destroy a vagrant box (delete all).", 
            "title": "Vagrant Commands:"
        }, 
        {
            "location": "/lab_setup/index.html#virtual-lab-setup-tasks", 
            "text": "", 
            "title": "Virtual Lab Setup - Tasks"
        }, 
        {
            "location": "/lab_setup/index.html#step-i-installation", 
            "text": "Install   VirtualBox 5.0 .  Install   Vagrant 1.6 .", 
            "title": "Step I - Installation"
        }, 
        {
            "location": "/lab_setup/index.html#step-ii-modify-environmental-variables", 
            "text": "Change default  VAGRANT_HOME  envi  variable to point to the newly provided  .vagrant.d  folder(where your virtual boxes are).   Linux - BASH  $nano ~/.bashrc\n#add the following line at the bottom of the .bashrc file:\nexport VAGRANT_HOME= /PATH/TO/.vagrant.d    \nFor more on linux environmental variables  How to set environmental variables on linux/unix    WINDOWS - CMD  setx VAGRANT_HOME  X:/your/path   WINDOWS - Powershell  cmd /c setx VAGRANT_HOME  X:/your/path/    Windows - Enviroment variables   If you need the VAGRANT_HOME to stay across sessions you should do a  SETX  command not  set on windows cmd or powershell (you need to run it as admin).  Above command adds variable to the User Environment.  If you want to add to the system/machine you need to add the /M option at the end of the command:  setx VAGRANT_HOME \"X:/your/path\" /M    For more on windows environmental variables  How to modify VAGRANT_HOME on windows", 
            "title": "Step II - Modify Environmental Variables"
        }, 
        {
            "location": "/lab_setup/index.html#step-iii-install-ssh-client", 
            "text": "Linux  On Linux there is an SSH client by default. You can simply SSH into the attacker box from host by running  vagrant ssh  from mysterious_boxes directory(where you VagrantFile is).  Windows   TBD", 
            "title": "STEP III - Install SSH client"
        }, 
        {
            "location": "/lab_topology/index.html", 
            "text": "Virtual Lab - Topology\n\n\n\n\n\n\n\n\n\n\n\n\n\nHost machine\n\n\n\n\nRuns vagrant/virtualbox to simulate the network .\n\n\nOn same sub-net as the VM\ns\n\n\nWe could \nuse it as sniffer\n(wireshark) because of GUI access.\n\n\nUse your favorite SSH client to log into Attacker box.\n\n\n\n\n\n\nWriting scripts\n\n\nThe beauty of using vagrant is that you could write all the scripts using your favorite editors on host and save it in shared folder(where your Vagrantfile is located) and execute it on attacker box.\n\n\n\n\nAttacker machine\n\n\n\n\nPre-configured with all the software neccesary(Scapy, nmap, netdiscover, dsniff, tcpdump\n).\n\n\nThis is sort of our \nbase box\n for this workshop from where we orchestrate our attacks.\n\n\nSSH into the attacker from host machine.\n\n\n\n\nVictim machines\n\n\n\n\n3 pre-configured VM\ns.\n\n\nVarious OSs with some listening services and security policies, nothing fancy though.\n\n\n\n\nThe Goal\n\n\nTo find as much information as we can about the victim machines using Scapy.\n\n- Fingerprinting OSs.\n\n- Find listening services.\n\n- Map firewall rules.", 
            "title": "Topology"
        }, 
        {
            "location": "/lab_topology/index.html#virtual-lab-topology", 
            "text": "", 
            "title": "Virtual Lab - Topology"
        }, 
        {
            "location": "/lab_topology/index.html#host-machine", 
            "text": "Runs vagrant/virtualbox to simulate the network .  On same sub-net as the VM s  We could  use it as sniffer (wireshark) because of GUI access.  Use your favorite SSH client to log into Attacker box.    Writing scripts  The beauty of using vagrant is that you could write all the scripts using your favorite editors on host and save it in shared folder(where your Vagrantfile is located) and execute it on attacker box.", 
            "title": "Host machine"
        }, 
        {
            "location": "/lab_topology/index.html#attacker-machine", 
            "text": "Pre-configured with all the software neccesary(Scapy, nmap, netdiscover, dsniff, tcpdump ).  This is sort of our  base box  for this workshop from where we orchestrate our attacks.  SSH into the attacker from host machine.", 
            "title": "Attacker machine"
        }, 
        {
            "location": "/lab_topology/index.html#victim-machines", 
            "text": "3 pre-configured VM s.  Various OSs with some listening services and security policies, nothing fancy though.", 
            "title": "Victim machines"
        }, 
        {
            "location": "/lab_topology/index.html#the-goal", 
            "text": "To find as much information as we can about the victim machines using Scapy. \n- Fingerprinting OSs. \n- Find listening services. \n- Map firewall rules.", 
            "title": "The Goal"
        }, 
        {
            "location": "/layers/index.html", 
            "text": "Layered Approach", 
            "title": "Layers"
        }, 
        {
            "location": "/layers/index.html#layered-approach", 
            "text": "", 
            "title": "Layered Approach"
        }, 
        {
            "location": "/socket_interface/index.html", 
            "text": "Socket Interface\n\n\n\n\n\n\n\n\n\n\n\nRaw sockets\n\n\nKernel offers two ways to forge packets:\n\n\nLayer 3 - PF_INET, SOCK_RAW\n\n- Classic raw sockets.\n\n- Lotsa hand holding by kernel which inturn limits what you can do.\n \n\n\nLayer 2 - PF_PACKET, PF_RAW\n\n- There is no limit on what you send.\n\n- No hand holding by kernel.\n\n- You are responsible for choosing interfaces, linktypes, ARP stuff, calculate checksums\u2026", 
            "title": "Socket Interface"
        }, 
        {
            "location": "/socket_interface/index.html#socket-interface", 
            "text": "", 
            "title": "Socket Interface"
        }, 
        {
            "location": "/socket_interface/index.html#raw-sockets", 
            "text": "Kernel offers two ways to forge packets:  Layer 3 - PF_INET, SOCK_RAW \n- Classic raw sockets. \n- Lotsa hand holding by kernel which inturn limits what you can do.    Layer 2 - PF_PACKET, PF_RAW \n- There is no limit on what you send. \n- No hand holding by kernel. \n- You are responsible for choosing interfaces, linktypes, ARP stuff, calculate checksums\u2026", 
            "title": "Raw sockets"
        }, 
        {
            "location": "/packet_headers/index.html", 
            "text": "Packet Headers\n\n\nThis workshop is about crafting packets so it makes sense to spend enough time understanding what packets are and how they are structured.\n\n\nIllustrations on this page are reproduced work created and shared by Matt Baxter as seen at \nhttps://nmap.org/book/tcpip-ref.html\n \n\n\nIP Header\n\n\n\n\n\n\n\n\nTCP Header\n\n\n\n\n\n\n\n\n\nUDP Header\n\n\n\n\n\n\n\n\nICMP Header", 
            "title": "Packet Headers"
        }, 
        {
            "location": "/packet_headers/index.html#packet-headers", 
            "text": "This workshop is about crafting packets so it makes sense to spend enough time understanding what packets are and how they are structured.  Illustrations on this page are reproduced work created and shared by Matt Baxter as seen at  https://nmap.org/book/tcpip-ref.html", 
            "title": "Packet Headers"
        }, 
        {
            "location": "/packet_headers/index.html#ip-header", 
            "text": "", 
            "title": "IP Header"
        }, 
        {
            "location": "/packet_headers/index.html#tcp-header", 
            "text": "", 
            "title": "TCP Header"
        }, 
        {
            "location": "/packet_headers/index.html#udp-header", 
            "text": "", 
            "title": "UDP Header"
        }, 
        {
            "location": "/packet_headers/index.html#icmp-header", 
            "text": "", 
            "title": "ICMP Header"
        }, 
        {
            "location": "/python/index.html", 
            "text": "Python - Lightspeed revision\n\n\n\n\nImporting modules\n\n\nimport socket\n\nimport argparse\n\n \n\n dir()\n['__builtins__', '__doc__', '__name__', '__package__', 'socket', 'argparse']\n\n\n\n\n\n\n\n\n from socket import *\n\n from scapy.all import *\n\n dir()\n['AF_APPLETALK', 'AF_ASH', 'SOCK_DGRAM', 'SOCK_RAW', 'SOCK_RDM', 'SOCK_SEQPACKET', 'SOCK_STREAM']\n[...snipped...]\n\n\n\n\n\n\nIntrospection\n\n\n\n\nExtremely powerful pythonic feature.\n\n\nFeatures in Python that help understand other features.\n\n\nEverything in Python is an object, and introspection is to look at this objects in memory and provide information them(attributes \n methods).\n\n\n\n\nhelp()\n\n\n help(sys)\n\n\n\n\ndir()\n\n\n dir(sys)\n['__displayhook__', '__doc__', '__excepthook__' [...snipped...]]\n\n\n\n\ntype()\n\n\n import sys\n\n \n\n \n\n type(sys)\n\ntype 'module'\n\n\n type(1)\n\ntype 'int'\n\n\n type()\n\n\n\n\n\ndoc string\n\n\n sys.__doc__\n\nThis module provides access to some objects used [...snipped...]\n\n\n\n\n\n\n\nPython - Lists\n\n\n\n\nSyntax: \nmy_list = [item0, item1,item2]\n\n\nCollection of elements of any data type.\n\n\nLists are \nmutable\n (Can be changed even after creation).\n\n\nPython provides numerous methods on lists. Just \ndir(list_name)\n to get a list of all the methods available.\n\n\nIndexing \n Slicing mechanism is consistent with strings.\n\n\nLists have very useful methods to manipulate them such as append, count, extend, index, insert, pop, remove, reverse,sort.\n\n\n\n\n\ncolors = ['red', 'blue', 'green']\nprint colors[0]    ## red\nprint colors[2]    ## green\nprint len(colors)  ## 3\n\n\n\n\n\n\n\n\n\n\n\n\nAssignment with an = on lists does not make a copy. Instead, assignment makes the two variables point to the one list in memory.\n\n\n\n\n\n\n\n\n\n\n\n\n\nList of lists or sublists\n\n\nLists can have sublists as elements. These sublists may contain sublists as well, i.e. lists can be recursively constructed by sublist structures.\n\n\n\n\n\n\n\n\n\n employee_details = [('Mark','22489'),('Steph','88153'),('Ajay','99112')]\n\n\n\n for i in xrange(len(employee_details)):\n...          print employee_details[i][0], employee_details[i][1]\n... \nMark 22489\nSteph 88153\nAjay 99112\n\n\n\n\n\nTuples\n\n\n\n\nSyntax \nmy_tuple = (val0, val1)\n\n\nA tuple is a \nfixed size\n grouping of elements.\n\n\nTuples are like lists but are \nimmutable\n and do not change size (tuples are not strictly immutable since one of the contained elements could be mutable).\n\n\nTuples have no other methods other than builtin\ns\n\n\n\nTuples are faster than lists.\n\n\nTuples are immutable so they protect from data being changed.\n\n\nTuples can be used as keys in a dictionary.\n\n\n\n\n  tuple = (1, 2, 'hi')\n  print len(tuple)  ## 3\n  print tuple[2]    ## hi\n  tuple[2] = 'bye'  ## NO, tuples cannot be changed\n  tuple = (1, 2, 'bye')  ## this works\n\n\n\n\nIf/elif/else\n\n\n\n\nAny value can be used as an if-test. The \nzero\n values all count as false: None, 0, empty string, empty list, empty dictionary.\n\n\nComparision operations: ==, !=, \n, \n=, \n, \n=\n\n\nThe boolean operators are the spelled out words \nand\n, \nor\n, \nnot\n (Python does not use the C-style \n || !).\n\n\n\n\n\nreturn = scan_target('10.5.0.6')\nif return == 0:\n    print \n[+] Scan sucessful!!\n\n    print packet\nelif return ==1:\n    print \n[-] Scan unsucessful!!\n\n    print \n[*] Inspect with wireshark\n\nelse:\n    print \n[!] Unknown error\n\n\n\n\n\n\n  if speed \n= 80:\n    print 'License and registration please'\n    if mood == 'terrible' or speed \n= 100:\n      print 'You have the right to remain silent.'\n    elif mood == 'bad' or speed \n= 90:\n      print \nI'm going to have to write you a ticket.\n\n      write_ticket()\n    else:\n      print \nLet's try to keep it under 80 ok?\n\n\n\n\nWhile loop\n\n\nPython also has the standard while-loop, and the \nbreak\n and \ncontinue\n statements work as in C++ and Java, altering the course of the innermost loop. The above for/in loops solves the common case of iterating over every element in a list, but the while loop gives you total control over the index numbers. Here\ns a while loop which accesses every 3rd element in a list:\n\n\n  ## Access every 3rd element in a list\n  i = 0\n  while i \n len(a):\n    print a[i]\n    i = i + 3\n\n\n\n\nFor Loop\n\n\nFOR - IN construct\n\n\n\n\nPython\ns \nfor\n and \nin\n constructs are extremely useful.\n\n\nThe \nfor\n construct \n \nfor var in list\n \n is an easy way to look at each element in a list (or other collection). Do not add or remove from the list during iteration.\n\n\n\n\n  squares = [1, 4, 9, 16]\n  sum = 0\n  for num in squares:\n    sum += num\n  print sum  ## 30\n\n\n\n\n\n\nThe \nin\n construct on its own is an easy way to test if an element appears in a list (or other collection) \n \nvalue in collection\n \n tests if the value is in the collection, returning True/False.\n\n\n\n\n  list = ['larry', 'curly', 'moe']\n  if 'curly' in list:\n    print 'yay'\n\n\n\n\nRange \n Xrange\n\n\n\n\nPython for loop iterates over a range of numbers, list of elements.\n\n\nThe \nrange(n)\n function yields the numbers 0, 1, \n n-1, and range(a, b) returns a, a+1, \n b-1 \n\n\n\n\n from socket import *\n\n open_ports = [21, 23, 25, 80, 139, 8080]\n\n \n\n for a in xrange(len(open_ports)):\n...     print \n[+] Port num: {} {} is open.\n.format(open_ports[a], getservbyport(open_ports[a]))\n... \n[+] Port num: 21 ftp is open.\n[+] Port num: 23 telnet is open.\n[+] Port num: 25 smtp is open.\n[+] Port num: 80 http is open.\n[+] Port num: 139 netbios-ssn is open.\n[+] Port num: 8080 http-alt is open.\n\n\n\n\n\n\nprint\n as a statement\n\n\n\n\nIn \nPython2.X \nprint\n is a statement\n not a function.\n\n\nVery intutive but not very powerful.\n\n\n\n\n answer = 42\n\n print \nThe answer is: \n + str(answer)\nThe answer is: 42\n\n\n\n\nprint\n as a function\n\n\n\n\nIn \nPython 3.X \nprint\n is a function\n which gives it more control on how to print stuff.\n\n\nYou can import print funtion into python 2.7.X using the statement \nfrom future import print_function\n\n\nI would recommend using print as a function even in Python2.X, for one your code will be more compatiable with Python3.X and also print function gives you more control on the output.\n\n\n\n\n from __future__ import print_function       # This internally sets a flag that lets interpreter enable print function\n\n answer = 42\n\n print('The answer is: '+str(42))\nThe answer is: 42\n\n\n\n\n\n\nPrint as a funtion can take arguments which provide more control on how you ptint stuff.\n\n\n\n\nprint(value1, ..., sep=' ', end='\\n', file=sys.stdout, flush=False)\n#\n#    file: a file-like object (stream); defaults to the current sys.stdout.\n#    sep:  string inserted between values, default a space.\n#    end:  string appended after the last value, default a newline.\n#\n\n\n\n\n\n\nWith the \nend\n argument you can choose what is appended as the last value.\n\n\n\n\n# Building a simple NOP sled for memory exploits\n# Only one of the output works for a NOP sled. Which one? Why?(Out of this workshop context though)\n\n\n\n print('\\x90'*30)\n\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n\n \n\n print('\\x90'*30, end='')\n\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n \n\n\n\n\n\n\n\n\nBy redefining the keyword parameter \nfile\n we can send the output into a different stream e.g. to a file or stderr\n\n\n\n\n fh = open(\ndata.txt\n,\nw\n)\n\n print(\n42 is the answer, but what is the question?\n, file=fh) \n\n fh.close()      # we see no ouput  to console after print because it's directed into the file fh\n\n\n\n\nC-Style format strings\n\n\n\n\nThe nearest thing to c-style printf equivalent in python.\n\n\n'%s %s' % ('one', 'two')\n\n\n\n\n\n\n\n\n\n\n\n port_number = 139\n\n \n\n host = '10.5.0.6'\n\n \n\n print \nPort num: %d is open on Host: %s\n%(port_number, host)\nPort num: 139 is open on Host: 10.5.0.6\n\n\n\n\n\n\nFor more on format string modulo: \nhttp://www.python-course.eu/python3_formatted_output.php\n \n\n\nPythonic style - string format method.\n\n\n\n\n\n\nPython has awesome string formatters to produce beautifully formatted output.\n\n\n\n\n\n\nThe \nfields to be replaced\n are surrounded by curly braces {}.\n\n'{} {}'.format('one', 'two')\n\n\n\n\n\n\n print \n[+] Port num: {} on host {} is open.\n.format(port_number, hostname)\n\n\n\n\nPlaceholders\n\n\n\n\nPython string format method supports placeholders and an explicit positional index. \n{1} {0}'.format('one', 'two')\n\n\nA positional parameter of the format method can be accessed by placing the index of the parameter after the opening brace, e.g. {0} accesses the first parameter.\n\n\n\n\n\n\n\n\n\n\n\n\n- Keywords can be used to index parameters as well.(Named placeholders)\n\n\n \nArt: {a:5d},  Price: {p:8.2f}\n.format(a=453, p=59.058)\n'Art:   453,  Price:    59.06'\n\n \n\n\n\n\nPadding and aligning strings\n\n\nBy default values are formatted to take up only as many characters as needed to represent the content. It is however also possible to define that a value should be padded to a specific length.\n\n\n\n\nWe can precede the formatting with a \n (left justify) or \n (right justify)\n\n\n\n\n '{:\n10}'.format('test')                             # right align\n'      test'\n\n\n\n \n{0:\n20s} {1:6.2f}\n.format('Spam \n Eggs:', 6.99)    # left align\n'Spam \n Eggs:           6.99'\n\n\n\n'{:^10}'.format('test')                          #center align\n'   test   '\n\n\n\n\n\n\nChoose your character for padding. \n'{:_\n10}'.format('test')\n\n\n\n\n '{:_\n10}'.format('test')\n'test______'\n\n\n\n\n\n\nFurther reading on string format method \nhttps://pyformat.info/\n \n\n\n\nsys.stdout.write()\n\n\nThis could be used to write to standard output or consoles when print doesn\u2019t seem to work.\n\n\n pack = '\\x90\\x32\\x67\\x70'\n\n sys.stdout.write(pack)\n\ufffd2gp\n \n\n\n\n\nList Comprehensions\n\n\n\n\nA list comprehension is a compact way to write an expression that expands to a whole list.\n\n\nList comprehension can almost substitute for the lambda function especially as map(), filter() and reduce().\n\n\n\n\n\n\n\n\n\n\n\n\n\nExamples\n\n\n# compute a list of their squares of elements in a list\nnums = [1, 2, 3, 4]\n\nsquares = [ n * n for n in nums ]   ## [1, 4, 9, 16]\n\n\n\n\n port_numbers = [22,25,80,139,443]\n\n [k for k in port_numbers]\n[22, 25, 80, 139, 443]\n\n\n\n numbers = [2,4,6,8] \n\n [k*2 for k in numbers]\n[4, 8, 12, 16]\n\n\n\n\n\n\n\nYou can add an if test to the right of the for-loop to narrow the result. The if test is evaluated for each element, including only the elements where the test is true.\n\n\n\n\n port_numbers = [22,25,80,139,443,8080,9999,55555]\n\n \n\n [k for k in port_numbers if k\n1023]\n[22, 25, 80, 139, 443]\n\n\n\n\n\nLambda functions\n\n\nSyntax: \nlambda arg1, arg2, \nargN : expression using arguments\n.\n\n\n\n\n\n\n\n\n\n\n\n\n- Python supports the creation of anonymous functions (i.e. functions that are not bound to a name) at runtime, using a construct called \nlambda\n.\n\n- Lambda functions take any number of arguments but only has one expression, the result of this expression is returned.\n\n\n def f (x): return x**2\n... \n\n print f(8)\n64\n\n \n\n g = lambda x: x**2\n\n \n\n print g(8)\n64\n\n\n\n\n\n\nLambda functions can be used anywhere a function is expected, not necessary to assign it to a variable.\n\n\nYou can pass lambda functions to other functions to do stuff(for example lambda function as key to sorted())\n\n\n\n\nmult3 = filter(lambda x: x % 3 == 0, [1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n\n\n\n\n\nUsing Lambda\n\n\nLambda funtions are good when they are short and as throw away functions. If you plan on doing anything remotely complex with it, put lambda away and define a real function.", 
            "title": "Python"
        }, 
        {
            "location": "/python/index.html#python-lightspeed-revision", 
            "text": "", 
            "title": "Python - Lightspeed revision"
        }, 
        {
            "location": "/python/index.html#importing-modules", 
            "text": "import socket import argparse    dir()\n['__builtins__', '__doc__', '__name__', '__package__', 'socket', 'argparse']     from socket import *  from scapy.all import *  dir()\n['AF_APPLETALK', 'AF_ASH', 'SOCK_DGRAM', 'SOCK_RAW', 'SOCK_RDM', 'SOCK_SEQPACKET', 'SOCK_STREAM']\n[...snipped...]", 
            "title": "Importing modules"
        }, 
        {
            "location": "/python/index.html#introspection", 
            "text": "Extremely powerful pythonic feature.  Features in Python that help understand other features.  Everything in Python is an object, and introspection is to look at this objects in memory and provide information them(attributes   methods).", 
            "title": "Introspection"
        }, 
        {
            "location": "/python/index.html#help", 
            "text": "help(sys)", 
            "title": "help()"
        }, 
        {
            "location": "/python/index.html#dir", 
            "text": "dir(sys)\n['__displayhook__', '__doc__', '__excepthook__' [...snipped...]]", 
            "title": "dir()"
        }, 
        {
            "location": "/python/index.html#type", 
            "text": "import sys      type(sys) type 'module'   type(1) type 'int'   type()", 
            "title": "type()"
        }, 
        {
            "location": "/python/index.html#doc-string", 
            "text": "sys.__doc__ This module provides access to some objects used [...snipped...]", 
            "title": "doc string"
        }, 
        {
            "location": "/python/index.html#python-lists", 
            "text": "Syntax:  my_list = [item0, item1,item2]  Collection of elements of any data type.  Lists are  mutable  (Can be changed even after creation).  Python provides numerous methods on lists. Just  dir(list_name)  to get a list of all the methods available.  Indexing   Slicing mechanism is consistent with strings.  Lists have very useful methods to manipulate them such as append, count, extend, index, insert, pop, remove, reverse,sort.   colors = ['red', 'blue', 'green']\nprint colors[0]    ## red\nprint colors[2]    ## green\nprint len(colors)  ## 3     \nAssignment with an = on lists does not make a copy. Instead, assignment makes the two variables point to the one list in memory.", 
            "title": "Python - Lists"
        }, 
        {
            "location": "/python/index.html#list-of-lists-or-sublists", 
            "text": "Lists can have sublists as elements. These sublists may contain sublists as well, i.e. lists can be recursively constructed by sublist structures.      employee_details = [('Mark','22489'),('Steph','88153'),('Ajay','99112')]   for i in xrange(len(employee_details)):\n...          print employee_details[i][0], employee_details[i][1]\n... \nMark 22489\nSteph 88153\nAjay 99112", 
            "title": "List of lists or sublists"
        }, 
        {
            "location": "/python/index.html#tuples", 
            "text": "Syntax  my_tuple = (val0, val1)  A tuple is a  fixed size  grouping of elements.  Tuples are like lists but are  immutable  and do not change size (tuples are not strictly immutable since one of the contained elements could be mutable).  Tuples have no other methods other than builtin s  Tuples are faster than lists.  Tuples are immutable so they protect from data being changed.  Tuples can be used as keys in a dictionary.     tuple = (1, 2, 'hi')\n  print len(tuple)  ## 3\n  print tuple[2]    ## hi\n  tuple[2] = 'bye'  ## NO, tuples cannot be changed\n  tuple = (1, 2, 'bye')  ## this works", 
            "title": "Tuples"
        }, 
        {
            "location": "/python/index.html#ifelifelse", 
            "text": "Any value can be used as an if-test. The  zero  values all count as false: None, 0, empty string, empty list, empty dictionary.  Comparision operations: ==, !=,  ,  =,  ,  =  The boolean operators are the spelled out words  and ,  or ,  not  (Python does not use the C-style   || !).   \nreturn = scan_target('10.5.0.6')\nif return == 0:\n    print  [+] Scan sucessful!! \n    print packet\nelif return ==1:\n    print  [-] Scan unsucessful!! \n    print  [*] Inspect with wireshark \nelse:\n    print  [!] Unknown error     if speed  = 80:\n    print 'License and registration please'\n    if mood == 'terrible' or speed  = 100:\n      print 'You have the right to remain silent.'\n    elif mood == 'bad' or speed  = 90:\n      print  I'm going to have to write you a ticket. \n      write_ticket()\n    else:\n      print  Let's try to keep it under 80 ok?", 
            "title": "If/elif/else"
        }, 
        {
            "location": "/python/index.html#while-loop", 
            "text": "Python also has the standard while-loop, and the  break  and  continue  statements work as in C++ and Java, altering the course of the innermost loop. The above for/in loops solves the common case of iterating over every element in a list, but the while loop gives you total control over the index numbers. Here s a while loop which accesses every 3rd element in a list:    ## Access every 3rd element in a list\n  i = 0\n  while i   len(a):\n    print a[i]\n    i = i + 3", 
            "title": "While loop"
        }, 
        {
            "location": "/python/index.html#for-loop", 
            "text": "", 
            "title": "For Loop"
        }, 
        {
            "location": "/python/index.html#for-in-construct", 
            "text": "Python s  for  and  in  constructs are extremely useful.  The  for  construct    for var in list    is an easy way to look at each element in a list (or other collection). Do not add or remove from the list during iteration.     squares = [1, 4, 9, 16]\n  sum = 0\n  for num in squares:\n    sum += num\n  print sum  ## 30   The  in  construct on its own is an easy way to test if an element appears in a list (or other collection)    value in collection    tests if the value is in the collection, returning True/False.     list = ['larry', 'curly', 'moe']\n  if 'curly' in list:\n    print 'yay'", 
            "title": "FOR - IN construct"
        }, 
        {
            "location": "/python/index.html#range-xrange", 
            "text": "Python for loop iterates over a range of numbers, list of elements.  The  range(n)  function yields the numbers 0, 1,   n-1, and range(a, b) returns a, a+1,   b-1     from socket import *  open_ports = [21, 23, 25, 80, 139, 8080]    for a in xrange(len(open_ports)):\n...     print  [+] Port num: {} {} is open. .format(open_ports[a], getservbyport(open_ports[a]))\n... \n[+] Port num: 21 ftp is open.\n[+] Port num: 23 telnet is open.\n[+] Port num: 25 smtp is open.\n[+] Port num: 80 http is open.\n[+] Port num: 139 netbios-ssn is open.\n[+] Port num: 8080 http-alt is open.", 
            "title": "Range &amp; Xrange"
        }, 
        {
            "location": "/python/index.html#print-as-a-statement", 
            "text": "In  Python2.X  print  is a statement  not a function.  Very intutive but not very powerful.    answer = 42  print  The answer is:   + str(answer)\nThe answer is: 42", 
            "title": "print as a statement"
        }, 
        {
            "location": "/python/index.html#print-as-a-function", 
            "text": "In  Python 3.X  print  is a function  which gives it more control on how to print stuff.  You can import print funtion into python 2.7.X using the statement  from future import print_function  I would recommend using print as a function even in Python2.X, for one your code will be more compatiable with Python3.X and also print function gives you more control on the output.    from __future__ import print_function       # This internally sets a flag that lets interpreter enable print function  answer = 42  print('The answer is: '+str(42))\nThe answer is: 42   Print as a funtion can take arguments which provide more control on how you ptint stuff.   print(value1, ..., sep=' ', end='\\n', file=sys.stdout, flush=False)\n#\n#    file: a file-like object (stream); defaults to the current sys.stdout.\n#    sep:  string inserted between values, default a space.\n#    end:  string appended after the last value, default a newline.\n#   With the  end  argument you can choose what is appended as the last value.   # Building a simple NOP sled for memory exploits\n# Only one of the output works for a NOP sled. Which one? Why?(Out of this workshop context though)   print('\\x90'*30)\n\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd    print('\\x90'*30, end='')\n\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd      By redefining the keyword parameter  file  we can send the output into a different stream e.g. to a file or stderr    fh = open( data.txt , w )  print( 42 is the answer, but what is the question? , file=fh)   fh.close()      # we see no ouput  to console after print because it's directed into the file fh", 
            "title": "print as a function"
        }, 
        {
            "location": "/python/index.html#c-style-format-strings", 
            "text": "The nearest thing to c-style printf equivalent in python.  '%s %s' % ('one', 'two')       port_number = 139    host = '10.5.0.6'    print  Port num: %d is open on Host: %s %(port_number, host)\nPort num: 139 is open on Host: 10.5.0.6   For more on format string modulo:  http://www.python-course.eu/python3_formatted_output.php", 
            "title": "C-Style format strings"
        }, 
        {
            "location": "/python/index.html#pythonic-style-string-format-method", 
            "text": "Python has awesome string formatters to produce beautifully formatted output.    The  fields to be replaced  are surrounded by curly braces {}. '{} {}'.format('one', 'two')     print  [+] Port num: {} on host {} is open. .format(port_number, hostname)", 
            "title": "Pythonic style - string format method."
        }, 
        {
            "location": "/python/index.html#placeholders", 
            "text": "Python string format method supports placeholders and an explicit positional index.  {1} {0}'.format('one', 'two')  A positional parameter of the format method can be accessed by placing the index of the parameter after the opening brace, e.g. {0} accesses the first parameter.      \n- Keywords can be used to index parameters as well.(Named placeholders)    Art: {a:5d},  Price: {p:8.2f} .format(a=453, p=59.058)\n'Art:   453,  Price:    59.06'", 
            "title": "Placeholders"
        }, 
        {
            "location": "/python/index.html#padding-and-aligning-strings", 
            "text": "By default values are formatted to take up only as many characters as needed to represent the content. It is however also possible to define that a value should be padded to a specific length.   We can precede the formatting with a   (left justify) or   (right justify)    '{: 10}'.format('test')                             # right align\n'      test'    {0: 20s} {1:6.2f} .format('Spam   Eggs:', 6.99)    # left align\n'Spam   Eggs:           6.99'  '{:^10}'.format('test')                          #center align\n'   test   '   Choose your character for padding.  '{:_ 10}'.format('test')    '{:_ 10}'.format('test')\n'test______'  \nFurther reading on string format method  https://pyformat.info/", 
            "title": "Padding and aligning strings"
        }, 
        {
            "location": "/python/index.html#sysstdoutwrite", 
            "text": "This could be used to write to standard output or consoles when print doesn\u2019t seem to work.   pack = '\\x90\\x32\\x67\\x70'  sys.stdout.write(pack)\n\ufffd2gp", 
            "title": "sys.stdout.write()"
        }, 
        {
            "location": "/python/index.html#list-comprehensions", 
            "text": "A list comprehension is a compact way to write an expression that expands to a whole list.  List comprehension can almost substitute for the lambda function especially as map(), filter() and reduce().", 
            "title": "List Comprehensions"
        }, 
        {
            "location": "/python/index.html#examples", 
            "text": "# compute a list of their squares of elements in a list\nnums = [1, 2, 3, 4]\n\nsquares = [ n * n for n in nums ]   ## [1, 4, 9, 16]   port_numbers = [22,25,80,139,443]  [k for k in port_numbers]\n[22, 25, 80, 139, 443]   numbers = [2,4,6,8]   [k*2 for k in numbers]\n[4, 8, 12, 16]   You can add an if test to the right of the for-loop to narrow the result. The if test is evaluated for each element, including only the elements where the test is true.    port_numbers = [22,25,80,139,443,8080,9999,55555]    [k for k in port_numbers if k 1023]\n[22, 25, 80, 139, 443]", 
            "title": "Examples"
        }, 
        {
            "location": "/python/index.html#lambda-functions", 
            "text": "Syntax:  lambda arg1, arg2,  argN : expression using arguments .      \n- Python supports the creation of anonymous functions (i.e. functions that are not bound to a name) at runtime, using a construct called  lambda . \n- Lambda functions take any number of arguments but only has one expression, the result of this expression is returned.   def f (x): return x**2\n...   print f(8)\n64    g = lambda x: x**2    print g(8)\n64   Lambda functions can be used anywhere a function is expected, not necessary to assign it to a variable.  You can pass lambda functions to other functions to do stuff(for example lambda function as key to sorted())   mult3 = filter(lambda x: x % 3 == 0, [1, 2, 3, 4, 5, 6, 7, 8, 9])   Using Lambda  Lambda funtions are good when they are short and as throw away functions. If you plan on doing anything remotely complex with it, put lambda away and define a real function.", 
            "title": "Lambda functions"
        }, 
        {
            "location": "/scapy_intro/index.html", 
            "text": "Scapy - Intro\n\n\nTrivia\n\n\n\n\nScapy is packet crafting, manipulating and analysis suite . \n\n\nPython interpreter disguised as a Domain Specific Language. \n\n\nCreated by Philippe Biondi.\n\n\n\n\nFeatures - Overview\n\n\n\n\n\n\nHelps to forge packets, send \n recieve packets, R\nW pcaps, alter packets.\n\n\n\n\n\n\nEasy \n faster packet desgining.\n\n\n\n\n\n\nDecode, Not Interpret .\n\n\n\n\n\n\nProbe Once, Interpret Many Times.\n\n\n\n\n\n\nRuns inside Python interpreter, provides you the whole language when dealing with packets but you don\u2019t need to master Python to use Scapy though.\n\n\n\n\n\n\nScapy Limitations\n\n\n\n\n\n\nScapy is not designed for fast throughput. It\ns written in Python which comes with many layers of abstraction.\n\n\n\n\n\n\nScapy does not go easy on memory(Each packet is a class). Not a right choice for analysing large packet captures.", 
            "title": "Scapy Intro"
        }, 
        {
            "location": "/scapy_intro/index.html#scapy-intro", 
            "text": "", 
            "title": "Scapy - Intro"
        }, 
        {
            "location": "/scapy_intro/index.html#trivia", 
            "text": "Scapy is packet crafting, manipulating and analysis suite .   Python interpreter disguised as a Domain Specific Language.   Created by Philippe Biondi.", 
            "title": "Trivia"
        }, 
        {
            "location": "/scapy_intro/index.html#features-overview", 
            "text": "Helps to forge packets, send   recieve packets, R W pcaps, alter packets.    Easy   faster packet desgining.    Decode, Not Interpret .    Probe Once, Interpret Many Times.    Runs inside Python interpreter, provides you the whole language when dealing with packets but you don\u2019t need to master Python to use Scapy though.", 
            "title": "Features - Overview"
        }, 
        {
            "location": "/scapy_intro/index.html#scapy-limitations", 
            "text": "Scapy is not designed for fast throughput. It s written in Python which comes with many layers of abstraction.    Scapy does not go easy on memory(Each packet is a class). Not a right choice for analysing large packet captures.", 
            "title": "Scapy Limitations"
        }, 
        {
            "location": "/scapy_modes/index.html", 
            "text": "Scapy - Interactive mode\n\n\n\n\nJust run \nscapy\n command in your terminal. You will be presented with an interactive interpreter.\n\n\nIt\ns just a Python interpreter disguised as a Domain Specific Language i.e. python interpreter loaded with scapy classes and objects.\n\n\nScapy in interactive mode suits well for one-liners.\n\n\n\n\nverax@humla ~/humla $ scapy\nWelcome to Scapy (2.3.1)\n\n \n\n \n\n sniff()\n^C\nSniffed: TCP:281 UDP:0 ICMP:0 Other:2\n\n\n\n\n\n\n\nImporting Scapy as a module\n\n\n\n\nScapy can be imported as an externam module into any python scipt.\n\n\n\n\n from scapy.all import *\n\n dir()\n['AES', 'AH', 'ARC2', 'ARC4', 'ARP', 'ARPHDR_ETHER', 'ARPHDR_LOOPBACK', 'ARPHDR_METRICOM'   [...snipped...]\n\n IP\n\nclass 'scapy.layers.inet.IP'\n\n\n TCP\n\nclass 'scapy.layers.inet.TCP'", 
            "title": "Scapy Modes"
        }, 
        {
            "location": "/scapy_modes/index.html#scapy-interactive-mode", 
            "text": "Just run  scapy  command in your terminal. You will be presented with an interactive interpreter.  It s just a Python interpreter disguised as a Domain Specific Language i.e. python interpreter loaded with scapy classes and objects.  Scapy in interactive mode suits well for one-liners.   verax@humla ~/humla $ scapy\nWelcome to Scapy (2.3.1)      sniff()\n^C Sniffed: TCP:281 UDP:0 ICMP:0 Other:2", 
            "title": "Scapy - Interactive mode"
        }, 
        {
            "location": "/scapy_modes/index.html#importing-scapy-as-a-module", 
            "text": "Scapy can be imported as an externam module into any python scipt.    from scapy.all import *  dir()\n['AES', 'AH', 'ARC2', 'ARC4', 'ARP', 'ARPHDR_ETHER', 'ARPHDR_LOOPBACK', 'ARPHDR_METRICOM'   [...snipped...]  IP class 'scapy.layers.inet.IP'   TCP class 'scapy.layers.inet.TCP'", 
            "title": "Importing Scapy as a module"
        }, 
        {
            "location": "/scapy_exploring/index.html", 
            "text": "Exploring scapy\n\n\nList of protocols supported\n\n\n ls()\nARP        : ARP\nDNS        : DNS\nDot11      : 802.11\nTCP        : TCP\nEther      : Ethernet\n[...]\n\n\n\n\nDissecting protocols\n\n\n ls(IP)\nversion    : BitField             = (4)\nihl        : BitField             = (None)\ntos        : XByteField           = (0)\nlen        : ShortField           = (None)\nid         : ShortField           = (1)\nflags      : FlagsField           = (0)\nfrag       : BitField             = (0)\nttl        : ByteField            = (64)\nproto      : ByteEnumField        = (0)\nchksum     : XShortField          = (None)\nsrc        : Emph                 = (None)\ndst        : Emph                 = ('127.0.0.1')\noptions    : PacketListField      = ([])\n\n\n\n\nList of all the scapy commands\n\n\n lsc()\nrdpcap     : Read a pcap file and return a packet \nsend       : Send packets at layer 3\nsendp      : Send packets at layer 2\nsendpfast  : Send packets at layer 2 using tcpreplay\n[...]\n\n\n\n\nGetting help on any function\n\n\n help(arpcachepoison)\n\nHelp on function arpcachepoison in module scapy.layers.l2:\n\narpcachepoison(target, victim, interval=60)\n    Poison target's cache with (your MAC,victim's IP) couple\n    arpcachepoison(target, victim, [interval=60]) -\n None\n\n[...]\n\n\n\n\nChange Scapy configuration\n\n\n conf\niface      = 'eth3'\niface6     = 'wlan0'\nwepkey     = ''\nsniff_promisc = 1\n[...]\n\n\n\n\n\n\nRoot Alert!\n\n\nAssembling and sending raw packets requires UID 0(root access) . Use sudo to become root.", 
            "title": "Exploring scapy"
        }, 
        {
            "location": "/scapy_exploring/index.html#exploring-scapy", 
            "text": "", 
            "title": "Exploring scapy"
        }, 
        {
            "location": "/scapy_exploring/index.html#list-of-protocols-supported", 
            "text": "ls()\nARP        : ARP\nDNS        : DNS\nDot11      : 802.11\nTCP        : TCP\nEther      : Ethernet\n[...]", 
            "title": "List of protocols supported"
        }, 
        {
            "location": "/scapy_exploring/index.html#dissecting-protocols", 
            "text": "ls(IP)\nversion    : BitField             = (4)\nihl        : BitField             = (None)\ntos        : XByteField           = (0)\nlen        : ShortField           = (None)\nid         : ShortField           = (1)\nflags      : FlagsField           = (0)\nfrag       : BitField             = (0)\nttl        : ByteField            = (64)\nproto      : ByteEnumField        = (0)\nchksum     : XShortField          = (None)\nsrc        : Emph                 = (None)\ndst        : Emph                 = ('127.0.0.1')\noptions    : PacketListField      = ([])", 
            "title": "Dissecting protocols"
        }, 
        {
            "location": "/scapy_exploring/index.html#list-of-all-the-scapy-commands", 
            "text": "lsc()\nrdpcap     : Read a pcap file and return a packet \nsend       : Send packets at layer 3\nsendp      : Send packets at layer 2\nsendpfast  : Send packets at layer 2 using tcpreplay\n[...]", 
            "title": "List of all the scapy commands"
        }, 
        {
            "location": "/scapy_exploring/index.html#getting-help-on-any-function", 
            "text": "help(arpcachepoison)\n\nHelp on function arpcachepoison in module scapy.layers.l2:\n\narpcachepoison(target, victim, interval=60)\n    Poison target's cache with (your MAC,victim's IP) couple\n    arpcachepoison(target, victim, [interval=60]) -  None\n\n[...]", 
            "title": "Getting help on any function"
        }, 
        {
            "location": "/scapy_exploring/index.html#change-scapy-configuration", 
            "text": "conf\niface      = 'eth3'\niface6     = 'wlan0'\nwepkey     = ''\nsniff_promisc = 1\n[...]   Root Alert!  Assembling and sending raw packets requires UID 0(root access) . Use sudo to become root.", 
            "title": "Change Scapy configuration"
        }, 
        {
            "location": "/creating_packets/index.html", 
            "text": "Creating packets with Scapy\n\n\nCreating a packet\n\n\n\n\nCreating packets in scapy is pretty straight forward and it is consistent with layered approach to networking.\n\n\nIn scapy, packets are constructed by defining packet headers for each protocol at different layers of TCP/IP and then stacking these layers in order.\n\n\nTo create a DNS query, you need to build Ether(sometimes optional), IP,UDP headers and stack them using \n/\n operator.\n\n\n\n\nCreating packet in one line\n\n\n packet = Ether()/IP(dst='8.8.8.8')/TCP(dport=53,flags='S')\n\n\n\n\nCreate each layer individually and stack them using \n/\n operator\n\n\n l2 = Ether()\n\n l3 = IP(dst='8.8.8.8/30')\n\n l4 = TCP(dport=53, flags = 'S')\n\n packet = l2/l3/l4\n\n\n\n\n\n\nScapy IP notations\n\n\nScapy accepts plain dotted-quad IP notation, CIDR notation, hostnames.\n\n\n packet = IP(dst = '8.8.8.8')\n\n \n\n packet = IP(dst = 'scanme.nmap.org')\n\n \n\n packet = IP(dst = '8.8.8.8/30')\n\n# Above line created 4 packets in one statements implicitly.\n# Using list comprehensions to view all the packets.\n\n [a for a in packet]\n[\nIP  dst=8.8.8.8 |\n, \nIP  dst=8.8.8.9 |\n, \nIP  dst=8.8.8.10 |\n, \nIP  dst=8.8.8.11 |\n]\n\n\n packet = IP(dst = 'egadz.metasploit.com/30')", 
            "title": "Creating packets"
        }, 
        {
            "location": "/creating_packets/index.html#creating-packets-with-scapy", 
            "text": "", 
            "title": "Creating packets with Scapy"
        }, 
        {
            "location": "/creating_packets/index.html#creating-a-packet", 
            "text": "Creating packets in scapy is pretty straight forward and it is consistent with layered approach to networking.  In scapy, packets are constructed by defining packet headers for each protocol at different layers of TCP/IP and then stacking these layers in order.  To create a DNS query, you need to build Ether(sometimes optional), IP,UDP headers and stack them using  /  operator.   Creating packet in one line   packet = Ether()/IP(dst='8.8.8.8')/TCP(dport=53,flags='S')  Create each layer individually and stack them using  /  operator   l2 = Ether()  l3 = IP(dst='8.8.8.8/30')  l4 = TCP(dport=53, flags = 'S')  packet = l2/l3/l4", 
            "title": "Creating a packet"
        }, 
        {
            "location": "/creating_packets/index.html#scapy-ip-notations", 
            "text": "Scapy accepts plain dotted-quad IP notation, CIDR notation, hostnames.   packet = IP(dst = '8.8.8.8')    packet = IP(dst = 'scanme.nmap.org')    packet = IP(dst = '8.8.8.8/30')\n\n# Above line created 4 packets in one statements implicitly.\n# Using list comprehensions to view all the packets.  [a for a in packet]\n[ IP  dst=8.8.8.8 | ,  IP  dst=8.8.8.9 | ,  IP  dst=8.8.8.10 | ,  IP  dst=8.8.8.11 | ]  packet = IP(dst = 'egadz.metasploit.com/30')", 
            "title": "Scapy IP notations"
        }, 
        {
            "location": "/inspecting_packets/index.html", 
            "text": "Inspecting packets\n\n\nGet detailed description of the packet along with datatypes\n\n\n packet = IP()/TCP()\n\n ls(packet)\nversion    : BitField             = 4               (4)\nihl        : BitField             = None            (None)\ntos        : XByteField           = 0               (0)\nlen        : ShortField           = None            (None)\nid         : ShortField           = 1               (1)\nflags      : FlagsField           = 0               (0)\nfrag       : BitField             = 0               (0)\nttl        : ByteField            = 64              (64)\nproto      : ByteEnumField        = 6               (0)\nchksum     : XShortField          = None            (None)\nsrc        : Emph                 = '127.0.0.1'     (None)\ndst        : Emph                 = '127.0.0.1'     ('127.0.0.1')\noptions    : PacketListField      = []              ([])\n[-- snipped --]\n\n\n\n\n\n\n\nDisplay short  \n interesting summary of a packet.\n\n\n packet.summary()\n'Ether / IP / TCP 192.168.1.100:ftp_data \n 8.8.8.8:domain S'\n\n\n\n\n\n\nShow() function displays detailed headers but \ndoes not assemble\n the packet\n\n\n packet.show()\n###[ IP ]###\n  version= 4\n  ihl= None\n  len= None\n  [...]\n  proto= hopopt\n  chksum= None\n  src= 192.168.1.100\n  dst= Net('8.8.8.8/30')\n\n\n\n\n\n\nShow2() is similar to show() but also assembles\nthe packet and calculates the checksums and IHL.\n\n\n packet.show2()\n###[ IP ]###\n  version= 4L\n  ihl= 5L\n  [...]\n  ttl= 64\n  proto= hopopt\n  chksum= 0xa8cd\n  src= 192.168.1.100\n  dst= 8.8.8.8\n\n### ** Get only the values supplied by the user.\n\n\n\n\n\n\nGet only user supplied values\n\n\n b.hide_defaults( )\n\n\n\n\n\n\nInteracting with fields inside packet\n\n\nTo access a specific field: [packet_name].[field]\n\n\n packet.dst\n'd8:55:a3:fe:80:78'\n\n\n\n\n\n\nFor fields that are not unique [packet_name][proto].[field]\n\n\n packet[Ether].dst\n'd8:55:a3:fe:80:78'\n\n packet[IP].dst\n'8.8.8.8'\n\n\n\n\n\n\n.payload\n ignores the lowest layer and parses the next layer.\n\n\n packet.payload.flags\n0\n\n packet.payload.payload.flags\n2\n\n\n\n\n\n\n.haslayer\n checks for presence of a layer in a packet\n\n\n if packet.haslayer(TCP):\n...     print packet[TCP].flags\n... \n2\n\n\n\n\n\n\n\n\nScapy sprintf() \n Python\u2019s .format()\n\n\n\n\nSprintf fills a format string with values from the packet.\n\n\nVery handy while writing custom tools.\n\n\n\n\n\n packet.sprintf(\nEthernet source is %Ether.src% and IP proto is %IP.proto%\n)\n'Ethernet source is 00:00:00:00:00:00 and IP proto is icmp'\n\n\n\n\n\n\n- Python string format method generates beautiful output but unlike sprintf it prints literal values.\n\n\n\n \nEther source is: {} \n IP proto is: {}\n.format(packet.src, packet.proto)\n'Ether source is: 00:00:00:00:00:00 \n IP proto is: 1'", 
            "title": "Inspecting packets"
        }, 
        {
            "location": "/inspecting_packets/index.html#inspecting-packets", 
            "text": "Get detailed description of the packet along with datatypes   packet = IP()/TCP()  ls(packet)\nversion    : BitField             = 4               (4)\nihl        : BitField             = None            (None)\ntos        : XByteField           = 0               (0)\nlen        : ShortField           = None            (None)\nid         : ShortField           = 1               (1)\nflags      : FlagsField           = 0               (0)\nfrag       : BitField             = 0               (0)\nttl        : ByteField            = 64              (64)\nproto      : ByteEnumField        = 6               (0)\nchksum     : XShortField          = None            (None)\nsrc        : Emph                 = '127.0.0.1'     (None)\ndst        : Emph                 = '127.0.0.1'     ('127.0.0.1')\noptions    : PacketListField      = []              ([])\n[-- snipped --]   Display short    interesting summary of a packet.   packet.summary()\n'Ether / IP / TCP 192.168.1.100:ftp_data   8.8.8.8:domain S'   Show() function displays detailed headers but  does not assemble  the packet   packet.show()\n###[ IP ]###\n  version= 4\n  ihl= None\n  len= None\n  [...]\n  proto= hopopt\n  chksum= None\n  src= 192.168.1.100\n  dst= Net('8.8.8.8/30')   Show2() is similar to show() but also assembles\nthe packet and calculates the checksums and IHL.   packet.show2()\n###[ IP ]###\n  version= 4L\n  ihl= 5L\n  [...]\n  ttl= 64\n  proto= hopopt\n  chksum= 0xa8cd\n  src= 192.168.1.100\n  dst= 8.8.8.8\n\n### ** Get only the values supplied by the user.   Get only user supplied values   b.hide_defaults( )", 
            "title": "Inspecting packets"
        }, 
        {
            "location": "/inspecting_packets/index.html#interacting-with-fields-inside-packet", 
            "text": "To access a specific field: [packet_name].[field]   packet.dst\n'd8:55:a3:fe:80:78'   For fields that are not unique [packet_name][proto].[field]   packet[Ether].dst\n'd8:55:a3:fe:80:78'  packet[IP].dst\n'8.8.8.8'   .payload  ignores the lowest layer and parses the next layer.   packet.payload.flags\n0  packet.payload.payload.flags\n2   .haslayer  checks for presence of a layer in a packet   if packet.haslayer(TCP):\n...     print packet[TCP].flags\n... \n2", 
            "title": "Interacting with fields inside packet"
        }, 
        {
            "location": "/inspecting_packets/index.html#scapy-sprintf-pythons-format", 
            "text": "Sprintf fills a format string with values from the packet.  Very handy while writing custom tools.    packet.sprintf( Ethernet source is %Ether.src% and IP proto is %IP.proto% )\n'Ethernet source is 00:00:00:00:00:00 and IP proto is icmp'  \n- Python string format method generates beautiful output but unlike sprintf it prints literal values.    Ether source is: {}   IP proto is: {} .format(packet.src, packet.proto)\n'Ether source is: 00:00:00:00:00:00   IP proto is: 1'", 
            "title": "Scapy sprintf() &amp; Python\u2019s .format()"
        }, 
        {
            "location": "/sending_recieving/index.html", 
            "text": "Sending \n recieving packets\n\n\n\n\nSend \n recieve funtions are the heart of scapy\ns functionality.\n\n\n\n\n\n\nFine grained options\n\n\nMost scapy funtions like send(), sniff() functions has fine grain options like applying bpf filters, timeout, retry, verbosity etc. Use help(function_name) to find out more options.\n\n\n\n\nsend()\n\n\nSend packets at Layer 3(Scapy creates Layer 2 header), Does not recieve any packets.\n\n\n send(IP(dst=\n1.2.3.4\n)/ICMP())\n.\nSent 1 packets.\n\n\n\n\nsendp()\n\n\nSend packets at Layer 2(Must provide Layer 2 header), Does not recieve any packets.\n\n\n sendp(Ether()/IP(dst=\n1.2.3.4\n,ttl=(1,4)), iface=\neth1\n)\n....\nSent 4 packets.\n\n\n sendp(\nI\u2019m travelling on Ethernet\n, iface=\neth1\n, loop=1, inter=0.2)\n\n\n sendp(rdpcap(\n/tmp/pcapfile\n)) # tcpreplay\n...........\nSent 11 packets.\n\n\n\n\nsr()\n\n\n\n\nSends packets and receiving answers. \n\n\nsr() returns a list of tuples of probe and answer in a packet list, and the unanswered packets.\n\n\n\n\n sr(IP(dst=\n192.168.8.1\n)/TCP(dport=[21,22,23]))\n\nReceived 6 packets, got 3 answers, remaining 0 packets\n(\nResults: UDP:0 TCP:3 ICMP:0 Other:0\n, \nUnanswered: UDP:0\n\n\n ans,unans=_\n\n ans.summary()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nsr1()\n\n\n\n\nSends packets and recieves only the first response . \n\n\nThe function returns a couple of packet and answers, and the unanswered packets.\n\n\n\n\n p=sr1(IP(dst=\nscanme.nmap.org\n)/ICMP()/\nXXXXXXXXXXX\n)\nBegin emission:\n...Finished to send 1 packets.\n.*\nReceived 5 packets, got 1 answers, remaining 0 packets\n\n\n\n\nsrloop()\n\n\n\n\nSends packets, recieves and displays responses, in a loop . \n\n\nThe function returns a couple of packet and answers, and the unanswered\n\n\n\n\n packet = IP(dst='192.168.56.102')/ICMP()\n\n srloop(packet)\nRECV 1: IP / ICMP 192.168.56.102 \n 192.168.56.1 echo-reply 0\nRECV 1: IP / ICMP 192.168.56.102 \n 192.168.56.1 echo-reply 0\nRECV 1: IP / ICMP 192.168.56.102 \n 192.168.56.1 echo-reply 0\n^C        \nSent 3 packets, received 3 packets. 100.0% hits.\n(\nResults: TCP:0 UDP:0 ICMP:3 Other:0\n, \nPacketList: TCP:0 UDP:0 ICMP:0 Other:0\n)", 
            "title": "Sending & Recieving"
        }, 
        {
            "location": "/sending_recieving/index.html#sending-recieving-packets", 
            "text": "Send   recieve funtions are the heart of scapy s functionality.    Fine grained options  Most scapy funtions like send(), sniff() functions has fine grain options like applying bpf filters, timeout, retry, verbosity etc. Use help(function_name) to find out more options.", 
            "title": "Sending &amp; recieving packets"
        }, 
        {
            "location": "/sending_recieving/index.html#send", 
            "text": "Send packets at Layer 3(Scapy creates Layer 2 header), Does not recieve any packets.   send(IP(dst= 1.2.3.4 )/ICMP())\n.\nSent 1 packets.", 
            "title": "send()"
        }, 
        {
            "location": "/sending_recieving/index.html#sendp", 
            "text": "Send packets at Layer 2(Must provide Layer 2 header), Does not recieve any packets.   sendp(Ether()/IP(dst= 1.2.3.4 ,ttl=(1,4)), iface= eth1 )\n....\nSent 4 packets.  sendp( I\u2019m travelling on Ethernet , iface= eth1 , loop=1, inter=0.2)  sendp(rdpcap( /tmp/pcapfile )) # tcpreplay\n...........\nSent 11 packets.", 
            "title": "sendp()"
        }, 
        {
            "location": "/sending_recieving/index.html#sr", 
            "text": "Sends packets and receiving answers.   sr() returns a list of tuples of probe and answer in a packet list, and the unanswered packets.    sr(IP(dst= 192.168.8.1 )/TCP(dport=[21,22,23]))\n\nReceived 6 packets, got 3 answers, remaining 0 packets\n( Results: UDP:0 TCP:3 ICMP:0 Other:0 ,  Unanswered: UDP:0  ans,unans=_  ans.summary()", 
            "title": "sr()"
        }, 
        {
            "location": "/sending_recieving/index.html#sr1", 
            "text": "Sends packets and recieves only the first response .   The function returns a couple of packet and answers, and the unanswered packets.    p=sr1(IP(dst= scanme.nmap.org )/ICMP()/ XXXXXXXXXXX )\nBegin emission:\n...Finished to send 1 packets.\n.*\nReceived 5 packets, got 1 answers, remaining 0 packets", 
            "title": "sr1()"
        }, 
        {
            "location": "/sending_recieving/index.html#srloop", 
            "text": "Sends packets, recieves and displays responses, in a loop .   The function returns a couple of packet and answers, and the unanswered    packet = IP(dst='192.168.56.102')/ICMP()  srloop(packet)\nRECV 1: IP / ICMP 192.168.56.102   192.168.56.1 echo-reply 0\nRECV 1: IP / ICMP 192.168.56.102   192.168.56.1 echo-reply 0\nRECV 1: IP / ICMP 192.168.56.102   192.168.56.1 echo-reply 0\n^C        \nSent 3 packets, received 3 packets. 100.0% hits.\n( Results: TCP:0 UDP:0 ICMP:3 Other:0 ,  PacketList: TCP:0 UDP:0 ICMP:0 Other:0 )", 
            "title": "srloop()"
        }, 
        {
            "location": "/sniffing/index.html", 
            "text": "Sniffing\n\n\nSniff()\n\n\n\n\nsniff() hasCount, filters, iface, timeout options. \n\n\nCan apply BPF filters .(Same as TCPDUMP).\n\n\n\n\n\n\nSniffing with Scapy\nScapy sniffer is not designed to be super fast so it can miss packets   sometimes.\nAlways use use tcpdump when you can, which is more simpler and efficient.\n\n\n\n\n\n\n sniff(filter='arp', count=5, iface='vboxnet0')\n\nSniffed: TCP:0 UDP:0 ICMP:0 Other:5\n\n\n\n\n _.summary()\nEther / ARP who has 192.168.56.101 says 192.168.56.1\nEther / ARP who has 192.168.56.101 says 192.168.56.1\nEther / ARP who has 192.168.56.101 says 192.168.56.1\nEther / ARP who has 192.168.56.101 says 192.168.56.1\nEther / ARP who has 192.168.56.101 says 192.168.56.1\n\n\n\n\nSMTP \n HTTP sniffer\n\n\n TBD", 
            "title": "Sniffing"
        }, 
        {
            "location": "/sniffing/index.html#sniffing", 
            "text": "", 
            "title": "Sniffing"
        }, 
        {
            "location": "/sniffing/index.html#sniff", 
            "text": "sniff() hasCount, filters, iface, timeout options.   Can apply BPF filters .(Same as TCPDUMP).    Sniffing with Scapy Scapy sniffer is not designed to be super fast so it can miss packets   sometimes.\nAlways use use tcpdump when you can, which is more simpler and efficient.     sniff(filter='arp', count=5, iface='vboxnet0') Sniffed: TCP:0 UDP:0 ICMP:0 Other:5    _.summary()\nEther / ARP who has 192.168.56.101 says 192.168.56.1\nEther / ARP who has 192.168.56.101 says 192.168.56.1\nEther / ARP who has 192.168.56.101 says 192.168.56.1\nEther / ARP who has 192.168.56.101 says 192.168.56.1\nEther / ARP who has 192.168.56.101 says 192.168.56.1", 
            "title": "Sniff()"
        }, 
        {
            "location": "/sniffing/index.html#smtp-http-sniffer", 
            "text": "TBD", 
            "title": "SMTP &amp; HTTP sniffer"
        }, 
        {
            "location": "/pcap_analysis/index.html", 
            "text": "PCAP Analysis\n\n\nRead \n Write PCAPs\n\n\n\n\nMemory matters!\n\n\nWith Scapy, each packet is a class which takes toll on the system memory, so Scapy is not a right choice for analysing large PCAPs\n\n\n\n\n\n\n\n\n\n\nrdpcap(\nport_knock_seq.pcap\n)\n\n\n\nwrpcap(\nattack.pcap\n,packets)\n\n\nsendp(rdpcap(\n/tmp/pcapfile\n)) # tcpreplay\n...........\nSent 11 packets.\n\n\n\n\n\n\n\n\nSolving some PCAP challenges\n\n\n TBD", 
            "title": "PCAP Analysis"
        }, 
        {
            "location": "/pcap_analysis/index.html#pcap-analysis", 
            "text": "", 
            "title": "PCAP Analysis"
        }, 
        {
            "location": "/pcap_analysis/index.html#read-write-pcaps", 
            "text": "Memory matters!  With Scapy, each packet is a class which takes toll on the system memory, so Scapy is not a right choice for analysing large PCAPs      rdpcap( port_knock_seq.pcap )  wrpcap( attack.pcap ,packets)  sendp(rdpcap( /tmp/pcapfile )) # tcpreplay\n...........\nSent 11 packets.", 
            "title": "Read &amp; Write PCAPs"
        }, 
        {
            "location": "/pcap_analysis/index.html#solving-some-pcap-challenges", 
            "text": "TBD", 
            "title": "Solving some PCAP challenges"
        }, 
        {
            "location": "/host_discovery/index.html", 
            "text": "Two steps to basic network reconnaissance.\n\n- Host Discovery.\n\n- Service Discovery(Port Scanning).\n\n\nHost Discovery\n\n\n\n\nFirst step to network recon. Goal is to \nreduce a large set of IP ranges into a list of active or interesting hosts.\n(A 10.0.0.0/8 network can accomdate 16777200 hosts).\n\n\nPort scanning is loud and also expensive on time and resources. More targets; More chances of being caught by an IDS.\n\n\nStrict narrowing down might miss interesting targets, Too lenient narrowing down can result in large set of machines to scan.. Strike a balance based on the requirements.\n\n\n\n\nTCP SYN Ping\n\n\n\n\nSend an empty TCP packet with only SYN bit set.\n\n\nSYN/ACK or RST in response indicates that a machine is up and running.\n\n\n\n\n ans,unans=sr( IP(dst=\n192.168.1.*\n)/TCP(dport=80,flags=\nS\n) )\n\n ans.summary( lambda(s,r) : r.sprintf(\n%IP.src% is alive\n) )\n192.168.56.101 is alive!\n\n\n\n\nTCP ACK Ping\n\n\n\n\nSend an empty TCP packet with only ACK bit set.\n\n\nUnsolicited ACK packets should be responded with RST which reveals a machine.\n\n\nSYN ping and ACK ping might seem redundant but most of the stateless firewalls won\nt filter unsolicited ACK packets so it\ns a better approach to use both ping tecnhiques.\n\n\n\n\n ans, unans = sr(IP(dst='192.168.56.99-105')/TCP(dport=80, flags='A'))\nBegin emission:\nFinished to send 7 packets.\n......................^C\nReceived 25 packets, got 1 answers, remaining 6 packets\n\n \n\n ans.summary(lambda(s,r): r.sprintf('{IP: %IP.src% is alive}'))\n 192.168.56.101 is alive\n\n \n\n\n\n\n\nUDP Ping\n\n\n\n\nSend UDP packet to the given ports with or without payload, though protocol specific payload makes the scan more effective.\n\n\nChoose a port that\ns most likely closed(Open UDP ports might recieve empty packets but ignore them).\n\n\nICMP port unreachable signifies that the machine is up.\n\n\n\n\nIP Protocol ping\n\n\n\n\nSend multiple packets with different protocol numbers set in their IP header, append proper protocol headers.\n\n\nLook for either responses using the same protocol as a probe, or ICMP protocol unreachable, either of the responses will signify a machine is alive.\n\n\n\n\nARP Ping\n\n\n\n\nARP Ping is employed when discovering active hosts on the same network/LAN.\n\n\nFaster and reliable because it operates on Layer 2 by using only ARP.\n\n\nARP is the backbone protocol for any Layer 2 communication so always employ ARP ping when discovering hosts on local network.\n\n\n\n\nARP doesn\nt exist in IPv6 standard. For the equivalent, use Neighbor Discovery Protocol techniques instead.\n\n\n\n\n\n\n\n\n\n\n ans,unans=srp(Ether(dst=\nff:ff:ff:ff:ff:ff\n)/ARP(pdst=\n192.168.56.0/24\n),timeout=2)\nBegin emission:\n**Finished to send 256 packets.\n\nReceived 2 packets, got 2 answers, remaining 254 packets\n\n \n\n ans.summary(lambda (s,r): r.sprintf(\n%Ether.src% %ARP.psrc%\n) )\n08:00:27:7b:2a:a9 192.168.56.100\n08:00:27:37:86:85 192.168.56.101\n\n \n\n\n\n\nICMP Ping\n\n\n\n\nICMP scan involves the standard packets sent by the ubiquitous \nping program\n .\n\n\nSend an \nICMP type 8 (echo request)\n packet to the target IP, a \nICMP type 0 (echo reply) \nindicates that the target is alive.\n\n\nUnfortunately, \nmany hosts and firewalls now block these packets\n so a basic ICMP scan is unreliable.\n\n\nICMP also supports\n timestamp request(13), and address mask request(17)\n which can reveal the availabilty of a machine.\n\n\n\n\n ans,unans=sr(IP(dst=\n192.168.56.99-110\n)/ICMP())\nBegin emission:\nFinished to send 12 packets.\nReceived 170 packets, got 1 answers, remaining 11 packets\n\n \n\n ans.summary( lambda(s,r) : r.sprintf(\n{IP: %IP.src% is alive}\n) )\n192.168.56.101 is alive", 
            "title": "Host discovery"
        }, 
        {
            "location": "/host_discovery/index.html#host-discovery", 
            "text": "First step to network recon. Goal is to  reduce a large set of IP ranges into a list of active or interesting hosts. (A 10.0.0.0/8 network can accomdate 16777200 hosts).  Port scanning is loud and also expensive on time and resources. More targets; More chances of being caught by an IDS.  Strict narrowing down might miss interesting targets, Too lenient narrowing down can result in large set of machines to scan.. Strike a balance based on the requirements.", 
            "title": "Host Discovery"
        }, 
        {
            "location": "/host_discovery/index.html#tcp-syn-ping", 
            "text": "Send an empty TCP packet with only SYN bit set.  SYN/ACK or RST in response indicates that a machine is up and running.    ans,unans=sr( IP(dst= 192.168.1.* )/TCP(dport=80,flags= S ) )  ans.summary( lambda(s,r) : r.sprintf( %IP.src% is alive ) )\n192.168.56.101 is alive!", 
            "title": "TCP SYN Ping"
        }, 
        {
            "location": "/host_discovery/index.html#tcp-ack-ping", 
            "text": "Send an empty TCP packet with only ACK bit set.  Unsolicited ACK packets should be responded with RST which reveals a machine.  SYN ping and ACK ping might seem redundant but most of the stateless firewalls won t filter unsolicited ACK packets so it s a better approach to use both ping tecnhiques.    ans, unans = sr(IP(dst='192.168.56.99-105')/TCP(dport=80, flags='A'))\nBegin emission:\nFinished to send 7 packets.\n......................^C\nReceived 25 packets, got 1 answers, remaining 6 packets    ans.summary(lambda(s,r): r.sprintf('{IP: %IP.src% is alive}'))\n 192.168.56.101 is alive", 
            "title": "TCP ACK Ping"
        }, 
        {
            "location": "/host_discovery/index.html#udp-ping", 
            "text": "Send UDP packet to the given ports with or without payload, though protocol specific payload makes the scan more effective.  Choose a port that s most likely closed(Open UDP ports might recieve empty packets but ignore them).  ICMP port unreachable signifies that the machine is up.", 
            "title": "UDP Ping"
        }, 
        {
            "location": "/host_discovery/index.html#ip-protocol-ping", 
            "text": "Send multiple packets with different protocol numbers set in their IP header, append proper protocol headers.  Look for either responses using the same protocol as a probe, or ICMP protocol unreachable, either of the responses will signify a machine is alive.", 
            "title": "IP Protocol ping"
        }, 
        {
            "location": "/host_discovery/index.html#arp-ping", 
            "text": "ARP Ping is employed when discovering active hosts on the same network/LAN.  Faster and reliable because it operates on Layer 2 by using only ARP.  ARP is the backbone protocol for any Layer 2 communication so always employ ARP ping when discovering hosts on local network.   ARP doesn t exist in IPv6 standard. For the equivalent, use Neighbor Discovery Protocol techniques instead.       ans,unans=srp(Ether(dst= ff:ff:ff:ff:ff:ff )/ARP(pdst= 192.168.56.0/24 ),timeout=2)\nBegin emission:\n**Finished to send 256 packets.\n\nReceived 2 packets, got 2 answers, remaining 254 packets    ans.summary(lambda (s,r): r.sprintf( %Ether.src% %ARP.psrc% ) )\n08:00:27:7b:2a:a9 192.168.56.100\n08:00:27:37:86:85 192.168.56.101", 
            "title": "ARP Ping"
        }, 
        {
            "location": "/host_discovery/index.html#icmp-ping", 
            "text": "ICMP scan involves the standard packets sent by the ubiquitous  ping program  .  Send an  ICMP type 8 (echo request)  packet to the target IP, a  ICMP type 0 (echo reply)  indicates that the target is alive.  Unfortunately,  many hosts and firewalls now block these packets  so a basic ICMP scan is unreliable.  ICMP also supports  timestamp request(13), and address mask request(17)  which can reveal the availabilty of a machine.    ans,unans=sr(IP(dst= 192.168.56.99-110 )/ICMP())\nBegin emission:\nFinished to send 12 packets.\nReceived 170 packets, got 1 answers, remaining 11 packets    ans.summary( lambda(s,r) : r.sprintf( {IP: %IP.src% is alive} ) )\n192.168.56.101 is alive", 
            "title": "ICMP Ping"
        }, 
        {
            "location": "/service_discovery/index.html", 
            "text": "Service discovery(Port Scanning)\n\n\nTCP Three way handshake\n\n\n\n\n\n\n\n\n\nConnect Scan\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFin Scan\n\n\n\n\n\n\n\n\n\nNull Scan\n\n\n\n\n\n\n\n\n\nXmas scan\n\n\n\n\n\n\n\n\n\nUDP Scan\n\n\n\n\n\n\n\n\n\nIPID Scan", 
            "title": "Service discovery"
        }, 
        {
            "location": "/service_discovery/index.html#service-discoveryport-scanning", 
            "text": "", 
            "title": "Service discovery(Port Scanning)"
        }, 
        {
            "location": "/service_discovery/index.html#tcp-three-way-handshake", 
            "text": "", 
            "title": "TCP Three way handshake"
        }, 
        {
            "location": "/service_discovery/index.html#connect-scan", 
            "text": "", 
            "title": "Connect Scan"
        }, 
        {
            "location": "/service_discovery/index.html#fin-scan", 
            "text": "", 
            "title": "Fin Scan"
        }, 
        {
            "location": "/service_discovery/index.html#null-scan", 
            "text": "", 
            "title": "Null Scan"
        }, 
        {
            "location": "/service_discovery/index.html#xmas-scan", 
            "text": "", 
            "title": "Xmas scan"
        }, 
        {
            "location": "/service_discovery/index.html#udp-scan", 
            "text": "", 
            "title": "UDP Scan"
        }, 
        {
            "location": "/service_discovery/index.html#ipid-scan", 
            "text": "", 
            "title": "IPID Scan"
        }, 
        {
            "location": "/os_detection/index.html", 
            "text": "Remote OS Detection\n\n\nAmbiguity in protocol implementations\n\n\nRFC 793 says:\n\nACK (1 bit) \u2013 indicates that the Acknowledgment field is significant. All packets after the initial SYN packet sent by the client should have this flag set\n.\n\n\nBut, IP stacks are written for different OSs by different people who read the RFCs and then write their interpretation of what the RFC outlines into code. This leads to a difference in how IP stacks are implemeted across OSes.\n\n\nLinux implementation\n\n\nLinux kernel 2.4+ accepts and acknowledges a segment in an established session where no TCP flags are set and where the segment has payload No other well known current operating system accepts this same segment..\n\n\nThe Technique:\n\n\n\n\n\n\n\n\n\n\n\nWhy RST??\n\n\nThe kernel is not aware of what Scapy is doing behind his back. If Scapy sends a SYN, the target replies with a SYN-ACK and your kernel sees it, it will reply with a RST.\n\n\nTo prevent this, use local firewall rules (e.g. NetFilter for Linux). Scapy does not mind about local firewalls.\n\n\n\n\n IPTABLES COMMAND \n \n\n\n\n\nCorner cases: Curious case of 127.0.0.1\n\n\nThe loopback interface is a very special. Packets going through it are not really assembled and dissassembled.\n\n\nThe kernel routes the packet to its destination while it is still stored an internal structure. The kernel is not aware of what Scapy is doing behind his back, so what you see on the lo interface is also a fake. Except this one did not come from a local structure. Thus the kernel will never receive it.\n\n\nTo speak to local applications, you need to build your packets one layer upper, using a PF_INET/SOCK_RAW socket instead of a PF_PACKET/SOCK_RAW (or its equivalent on other systems that Linux).\n\n\n\n\nPassive OS fingerprinting\n\n\nTTL \n Window size analysis\n\n\n \n\n\n scapy p0f \n\n\n nmap os db \n\n\n active scans", 
            "title": "OS detection"
        }, 
        {
            "location": "/os_detection/index.html#remote-os-detection", 
            "text": "", 
            "title": "Remote OS Detection"
        }, 
        {
            "location": "/os_detection/index.html#ambiguity-in-protocol-implementations", 
            "text": "RFC 793 says: ACK (1 bit) \u2013 indicates that the Acknowledgment field is significant. All packets after the initial SYN packet sent by the client should have this flag set .  But, IP stacks are written for different OSs by different people who read the RFCs and then write their interpretation of what the RFC outlines into code. This leads to a difference in how IP stacks are implemeted across OSes.", 
            "title": "Ambiguity in protocol implementations"
        }, 
        {
            "location": "/os_detection/index.html#linux-implementation", 
            "text": "Linux kernel 2.4+ accepts and acknowledges a segment in an established session where no TCP flags are set and where the segment has payload No other well known current operating system accepts this same segment..", 
            "title": "Linux implementation"
        }, 
        {
            "location": "/os_detection/index.html#the-technique", 
            "text": "Why RST??  The kernel is not aware of what Scapy is doing behind his back. If Scapy sends a SYN, the target replies with a SYN-ACK and your kernel sees it, it will reply with a RST.  To prevent this, use local firewall rules (e.g. NetFilter for Linux). Scapy does not mind about local firewalls.    IPTABLES COMMAND      Corner cases: Curious case of 127.0.0.1  The loopback interface is a very special. Packets going through it are not really assembled and dissassembled.  The kernel routes the packet to its destination while it is still stored an internal structure. The kernel is not aware of what Scapy is doing behind his back, so what you see on the lo interface is also a fake. Except this one did not come from a local structure. Thus the kernel will never receive it.  To speak to local applications, you need to build your packets one layer upper, using a PF_INET/SOCK_RAW socket instead of a PF_PACKET/SOCK_RAW (or its equivalent on other systems that Linux).", 
            "title": "The Technique:"
        }, 
        {
            "location": "/os_detection/index.html#passive-os-fingerprinting", 
            "text": "", 
            "title": "Passive OS fingerprinting"
        }, 
        {
            "location": "/os_detection/index.html#ttl-window-size-analysis", 
            "text": "scapy p0f    nmap os db    active scans", 
            "title": "TTL &amp; Window size analysis"
        }, 
        {
            "location": "/promisc/index.html", 
            "text": "Promiscuous node detection\n\n\n\n\nPromiscuous mode\n\n\n\n\nPromiscuous mode allows a network device to intercept and read each network packet that arrives in its entirety.\n\n\n\n\nUnlike Monitor mode, in promisc mode the listener has to be connected to the network.\n\n\n\n\n\n\nSome tools that use promiscuous mode - Wireshark, Tcpdump, Aircrack-ng, cain and abel, Snort, Virtualbox\n\n\n\n\nExtremely effective because of it\ns passive nature.\n\n\n\n\nEnable promiscuous mode:\n\n\n$ sudo ifconfig \niface\n promisc   \n\n\n\n\nDisable promiscuous mode:\n\n\n$ sudo ifconfig \niface\n -promisc   \n\n\n\n\n\n\n Detecting promisc node -  The idea:\n\n\n\n\n\n\nAll the packets recieved by promisc NIC are passed on to the kernel, so the basic idea of detection is to send specially crafted packets that may trick the system kernel to respond to packets that it is not supposed to respond to.\n\n\n\n\n\n\nFake ARP request packets, ICMP Ping(echo request) with wrong MAC but right IP address could do the job.\n\n\n\n\n\n\nARP Protocol\n\n\n\n\nARP protocol is used for resolution of network layer addresses into link layer addresses, IPV4 over Ethernet generally.\n\n\n\n\n\n\nARP is depricated in IPv6 and the functionality is provided by  Network Discovery Protocol(NDP).\n\n\n\n\n\n\nARP works inside a network and it is \nnever routed\n outside.\n\n\nARP is a \nlayer 2 protocol\n(well, yeah yeah, \n2.5 layer maybe\n, for all the CCNA people)\n\n\nARP is generally \nbroadcasted\n in the local network.\n\n\n\n\n \n\n \n\n\nHardware filter\n\n\nNormally,  NIC of a machine filters and accepts only packets that have destination address set to the NIC\ns own hardware address, broadcast address (FF FF FF FF FF FF), and multicast address 1(01 00 5E 00 00 01). Let\ns call this a hardware filter.\nBut in promiscuous mode NIC is set to accept every packet that it recieves.\n\n\n\n\nShould be easy to find promisc nodes, right?\nJust send packet that is supposed to be filtered by normal mode hardware filter, only a promisc node would pass it to kernel and respond to that.\n\n\nLet\ns try: \n00:00:00:00:00:01\n. What happens??\n\n\n\n\nSoftware Filter\n\n\nOperating system kernels implement a filter, let\ns call it \nsoftware filter\n.\nEven though a packet passes through hardware filter, kernel is implementing another filter.\n\n\nHardware filter vs Software filter\n\n\nThe hardware filter usually blocks packets that are not supposed to arrive to the system kernel. \n\n\nWe need to craft a packet that is:\n\na. Blocked by the hardware filter in normal mode.\n\nb. Should be able to pass the software filter.", 
            "title": "Promisc detection"
        }, 
        {
            "location": "/promisc/index.html#promiscuous-node-detection", 
            "text": "", 
            "title": "Promiscuous node detection"
        }, 
        {
            "location": "/promisc/index.html#promiscuous-mode", 
            "text": "Promiscuous mode allows a network device to intercept and read each network packet that arrives in its entirety.   Unlike Monitor mode, in promisc mode the listener has to be connected to the network.    Some tools that use promiscuous mode - Wireshark, Tcpdump, Aircrack-ng, cain and abel, Snort, Virtualbox   Extremely effective because of it s passive nature.   Enable promiscuous mode:  $ sudo ifconfig  iface  promisc     Disable promiscuous mode:  $ sudo ifconfig  iface  -promisc", 
            "title": "Promiscuous mode"
        }, 
        {
            "location": "/promisc/index.html#detecting-promisc-node-the-idea", 
            "text": "All the packets recieved by promisc NIC are passed on to the kernel, so the basic idea of detection is to send specially crafted packets that may trick the system kernel to respond to packets that it is not supposed to respond to.    Fake ARP request packets, ICMP Ping(echo request) with wrong MAC but right IP address could do the job.", 
            "title": "Detecting promisc node -  The idea:"
        }, 
        {
            "location": "/promisc/index.html#arp-protocol", 
            "text": "ARP protocol is used for resolution of network layer addresses into link layer addresses, IPV4 over Ethernet generally.    ARP is depricated in IPv6 and the functionality is provided by  Network Discovery Protocol(NDP).    ARP works inside a network and it is  never routed  outside.  ARP is a  layer 2 protocol (well, yeah yeah,  2.5 layer maybe , for all the CCNA people)  ARP is generally  broadcasted  in the local network.", 
            "title": "ARP Protocol"
        }, 
        {
            "location": "/promisc/index.html#hardware-filter", 
            "text": "Normally,  NIC of a machine filters and accepts only packets that have destination address set to the NIC s own hardware address, broadcast address (FF FF FF FF FF FF), and multicast address 1(01 00 5E 00 00 01). Let s call this a hardware filter.\nBut in promiscuous mode NIC is set to accept every packet that it recieves.   Should be easy to find promisc nodes, right?\nJust send packet that is supposed to be filtered by normal mode hardware filter, only a promisc node would pass it to kernel and respond to that.  Let s try:  00:00:00:00:00:01 . What happens??", 
            "title": "Hardware filter"
        }, 
        {
            "location": "/promisc/index.html#software-filter", 
            "text": "Operating system kernels implement a filter, let s call it  software filter .\nEven though a packet passes through hardware filter, kernel is implementing another filter.", 
            "title": "Software Filter"
        }, 
        {
            "location": "/promisc/index.html#hardware-filter-vs-software-filter", 
            "text": "The hardware filter usually blocks packets that are not supposed to arrive to the system kernel.   We need to craft a packet that is: \na. Blocked by the hardware filter in normal mode. \nb. Should be able to pass the software filter.", 
            "title": "Hardware filter vs Software filter"
        }, 
        {
            "location": "/scapyhunt/index.html", 
            "text": "Let\ns go hunting with NetworkHunt!\n\n\nTrivia\n\n\n\n\n\n\nTerminal-based game in which you will use common network attack vectors and penetration testing methods to analyze and compromise a virtual network.\n\n\n\n\n\n\nInvolves Network Security challenges designed to educate users on packet manipulation and common network attacks.\n\n\n\n\n\n\nThe whole challenge happens over sort of a software defined network(SDN).\n\n\n\n\n\n\nOriginally created by James Sullivan(MIT License).\n\n\n\n\n\n\n\n\nside note\nThe scapy hunt SDN itself is completely defined by handcrafted packets using scapy which simulates a typical network setup.\n\n\n\n\n\n\nThe Goal\n\n\nThere is an FTP server somewhere on the network containing a document:\n\n\n\n\nLocate the FTP server\n\n\nConnect to the service \n\n\nRetrieve the file!\n\n\n\n\nTools\n\n\n\n\nscapy\n\n\nnmap\n\n\nwireshark\n\n\ntelnet/nc\n\n\ndsniff\n\n\n\n\nConcepts\n\n\n\n\nBash terminal-fu\n\n\nPacket capture and manipulation in scapy\n\n\nPacket analysis in wireshark\n\n\nRouter modes of operation\n\n\nNetwork topography, gateways\n\n\nBasic telnet/nc commands\n\n\n\n\n\n\nHints\n\n\n\n\nYou may need to find a way to see all of the traffic on the network.\n\n\nOther clients on the network might give you useful clues, if you can coerce them.\n\n\nThe target will most likely be isolated from the immediate local network, and will have some preferred clients.\n\n\n\n\n\n\nTASKS\n\n\nTASK - I\n\n\nRun the script \n find the details about the interface.\n\n\nTASK - II\n\n\nUnderstand the Network.\n- The traffic \n The Devices.\n- The nature of layer 2 switches.\n\n\nTASK - III\n\n\nScapy tips:\n\n- RandMAC() - Generates random MAC addresses.\n\n- RandIP() - Generates random IP addresses. \n\n\nTASK - IV\n\n\nSubvert Layer 2 security\n\n\nTASK - V\n\n\nTASK - VI\n\n\nTASK - VIII", 
            "title": "Network Hunt"
        }, 
        {
            "location": "/scapyhunt/index.html#lets-go-hunting-with-networkhunt", 
            "text": "", 
            "title": "Let's go hunting with NetworkHunt!"
        }, 
        {
            "location": "/scapyhunt/index.html#trivia", 
            "text": "Terminal-based game in which you will use common network attack vectors and penetration testing methods to analyze and compromise a virtual network.    Involves Network Security challenges designed to educate users on packet manipulation and common network attacks.    The whole challenge happens over sort of a software defined network(SDN).    Originally created by James Sullivan(MIT License).     side note The scapy hunt SDN itself is completely defined by handcrafted packets using scapy which simulates a typical network setup.", 
            "title": "Trivia"
        }, 
        {
            "location": "/scapyhunt/index.html#the-goal", 
            "text": "There is an FTP server somewhere on the network containing a document:   Locate the FTP server  Connect to the service   Retrieve the file!", 
            "title": "The Goal"
        }, 
        {
            "location": "/scapyhunt/index.html#tools", 
            "text": "scapy  nmap  wireshark  telnet/nc  dsniff", 
            "title": "Tools"
        }, 
        {
            "location": "/scapyhunt/index.html#concepts", 
            "text": "Bash terminal-fu  Packet capture and manipulation in scapy  Packet analysis in wireshark  Router modes of operation  Network topography, gateways  Basic telnet/nc commands    Hints   You may need to find a way to see all of the traffic on the network.  Other clients on the network might give you useful clues, if you can coerce them.  The target will most likely be isolated from the immediate local network, and will have some preferred clients.", 
            "title": "Concepts"
        }, 
        {
            "location": "/scapyhunt/index.html#tasks", 
            "text": "", 
            "title": "TASKS"
        }, 
        {
            "location": "/scapyhunt/index.html#task-i", 
            "text": "Run the script   find the details about the interface.", 
            "title": "TASK - I"
        }, 
        {
            "location": "/scapyhunt/index.html#task-ii", 
            "text": "Understand the Network.\n- The traffic   The Devices.\n- The nature of layer 2 switches.", 
            "title": "TASK - II"
        }, 
        {
            "location": "/scapyhunt/index.html#task-iii", 
            "text": "Scapy tips: \n- RandMAC() - Generates random MAC addresses. \n- RandIP() - Generates random IP addresses.", 
            "title": "TASK - III"
        }, 
        {
            "location": "/scapyhunt/index.html#task-iv", 
            "text": "Subvert Layer 2 security", 
            "title": "TASK - IV"
        }, 
        {
            "location": "/scapyhunt/index.html#task-v", 
            "text": "", 
            "title": "TASK - V"
        }, 
        {
            "location": "/scapyhunt/index.html#task-vi", 
            "text": "", 
            "title": "TASK - VI"
        }, 
        {
            "location": "/scapyhunt/index.html#task-viii", 
            "text": "", 
            "title": "TASK - VIII"
        }, 
        {
            "location": "/feedback/index.html", 
            "text": "Feedback \n Suggestions\n\n\n\n\npythonhumla@gmail.com\n\n\nGive anonymous feedback at \nhttps://www.suggestionox.com/r/pythonhumla\n\n\n\n\nCredits\n\n\nnull - The Open Security Community. \n |  \n \nhttp://swachalit.null.co.in/\n\nPhillipe Biondi for Scapy tool \n excellent literature on it.  \n |  \n \nhttp://secdev.org/\n\nJames Sullivan for his brilliant ScapyHunt program. \n |  \n \nhttps://github.com/JamesSullivan1/scapyHunt/\n\nPeople at packetstan esp. Judy Novak. \n |  \n \npacketstan.com\n\nTom Christie, Dougal Matthews for their beautiful documentation generator \n |  \n \nmkdocs.org", 
            "title": "Feedback"
        }, 
        {
            "location": "/feedback/index.html#feedback-suggestions", 
            "text": "pythonhumla@gmail.com  Give anonymous feedback at  https://www.suggestionox.com/r/pythonhumla", 
            "title": "Feedback &amp; Suggestions"
        }, 
        {
            "location": "/feedback/index.html#credits", 
            "text": "null - The Open Security Community.   |     http://swachalit.null.co.in/ \nPhillipe Biondi for Scapy tool   excellent literature on it.    |     http://secdev.org/ \nJames Sullivan for his brilliant ScapyHunt program.   |     https://github.com/JamesSullivan1/scapyHunt/ \nPeople at packetstan esp. Judy Novak.   |     packetstan.com \nTom Christie, Dougal Matthews for their beautiful documentation generator   |     mkdocs.org", 
            "title": "Credits"
        }
    ]
}