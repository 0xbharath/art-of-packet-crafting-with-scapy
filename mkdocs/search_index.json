{
    "docs": [
        {
            "location": "/index.html", 
            "text": "The Art of Packet Crafting with Scapy\n\n\nWorkshop overview\n\n\n\n\nThis is an intense workshop on crafting packets using Python and Scapy.\n\n\nWe\nll understand low level networking details/abstractions like raw Sockets and move towards using high level tools like Scapy to craft packets.\n\n\nWe\nll understand Scapy framework and craft packets using it.\n\n\nWe\nll leverage Scapy as a framework to build custom network tools/utilities.\n\n\n\n\nConcepts covered\n\n\n\n\nPractical network reconnaissance techniques like host discovery, service discovery, Remote OS finger printing, promiscuous node detection using Scapy.\n\n\nLaunching Layer 2 attacks and detection techniques for these attacks.\n\n\nLeverage Scapy to build custom tools/utilities such as sniffers, pcap analyzer, wireless sniffers and scanners.\n\n\n\n\nSkill prerequisites\n\n\n\n\nBasics of Python programming. (strings, lists, dicts, functions, files etc)\n\n\nKnowledge of basic networking concepts. (Enough to know what an IP address, port number, OSI model etc.)\n\n\n\n\nTechnical prerequisites\n\n\n\n\nLaptop with administrator access (mandatory).\n\n\nMinimum 4 GB RAM and 15 GB free hard disk space (More the better).\n\n\nPreferably running Linux as primary OS but Windows/Mac is permissible.\n\n\nPreferably, your own Internet connectivity.\n\n\n\n\nLibraries/Modules\n\n\n\n\nStandard library\n\n\nsys, pprint.\n\n\n\n\n\n\nThird party modules\n\n\nscapy, python-nmap, netaddr, inetfaces.", 
            "title": "The Art of Packet Crafting with Scapy"
        }, 
        {
            "location": "/index.html#the-art-of-packet-crafting-with-scapy", 
            "text": "", 
            "title": "The Art of Packet Crafting with Scapy"
        }, 
        {
            "location": "/index.html#workshop-overview", 
            "text": "This is an intense workshop on crafting packets using Python and Scapy.  We ll understand low level networking details/abstractions like raw Sockets and move towards using high level tools like Scapy to craft packets.  We ll understand Scapy framework and craft packets using it.  We ll leverage Scapy as a framework to build custom network tools/utilities.", 
            "title": "Workshop overview"
        }, 
        {
            "location": "/index.html#concepts-covered", 
            "text": "Practical network reconnaissance techniques like host discovery, service discovery, Remote OS finger printing, promiscuous node detection using Scapy.  Launching Layer 2 attacks and detection techniques for these attacks.  Leverage Scapy to build custom tools/utilities such as sniffers, pcap analyzer, wireless sniffers and scanners.", 
            "title": "Concepts covered"
        }, 
        {
            "location": "/index.html#skill-prerequisites", 
            "text": "Basics of Python programming. (strings, lists, dicts, functions, files etc)  Knowledge of basic networking concepts. (Enough to know what an IP address, port number, OSI model etc.)", 
            "title": "Skill prerequisites"
        }, 
        {
            "location": "/index.html#technical-prerequisites", 
            "text": "Laptop with administrator access (mandatory).  Minimum 4 GB RAM and 15 GB free hard disk space (More the better).  Preferably running Linux as primary OS but Windows/Mac is permissible.  Preferably, your own Internet connectivity.", 
            "title": "Technical prerequisites"
        }, 
        {
            "location": "/index.html#librariesmodules", 
            "text": "Standard library  sys, pprint.    Third party modules  scapy, python-nmap, netaddr, inetfaces.", 
            "title": "Libraries/Modules"
        }, 
        {
            "location": "/workshop_intro/license/index.html", 
            "text": "Copyright (C) 2016  Bharath Kumar\n \n\nExcept as otherwise noted, the content of this workshop is licensed under the \nCreative Commons Attribution-Share Alike 4.0 International License\n , and code samples are licensed under the \nApache 2.0 License\n.\n\n\nNetwork Hunt\n CTF is based on work created and shared by James Sullivan and used according to terms described in the MIT license.\n\n\nAll the packet header illustrations are reproduced work created and shared by Matt Baxter as seen at \nNmap reference book", 
            "title": "License"
        }, 
        {
            "location": "/workshop_intro/bigger_picture/index.html", 
            "text": "", 
            "title": "Bigger picture"
        }, 
        {
            "location": "/workshop_intro/speakers/index.html", 
            "text": "Bharath\n\n\nWebpage \n \n  \n  \ndisruptivelabs.in\n\nTwitter\n \n  \n \n  \n  \n   \ntwitter.com/yamakira_\n\nGithub \n \n \n \n \ngithub.com/yamakira\n \n\n\nAbhinav\n\n\nWebpage \n \n  \n  \n\nTwitter\n \n  \n \n  \n  \n   \ntwitter.com/geek_ji\n\nGithub", 
            "title": "Speakers"
        }, 
        {
            "location": "/workshop_intro/speakers/index.html#bharath", 
            "text": "Webpage          disruptivelabs.in \nTwitter                  twitter.com/yamakira_ \nGithub          github.com/yamakira", 
            "title": "Bharath"
        }, 
        {
            "location": "/workshop_intro/speakers/index.html#abhinav", 
            "text": "Webpage          \nTwitter                  twitter.com/geek_ji \nGithub", 
            "title": "Abhinav"
        }, 
        {
            "location": "/workshop_intro/workshop_settings/index.html", 
            "text": "Settings\n\n\nThe Goal\n\n\n\n\nUnderstanding packet crafting and crafting packets with scapy\n\n\nUnderstanding common attacks and analysis techniques, implementing with scapy.\n\n\nWriting custom tools using scapy framework!\n\n\nHave fun while programming and solving challenges!\n\n\n\n\nQuestions\n\n\n\n\nRTFM\n\n\nAsk them when you got them.\n\n\nIt\ns easy to get lost so \ntry not to be on auto pilot mode\n.\n\n\n\n\nWorkshop\n\n\n\n\nMeter wide \n Mile deep!\n\n\nPentesters point of view.\n\n\nMinimal theory, maximal hands-on.\n\n\nProgramming experience in Python preferred but it\ns possible to follow even without it.\n\n\nPython 2.7.x\n\n\n\n\nFor more on Python 2.x vs 3.x \nPython 2.x vs 3.x", 
            "title": "Workshop settings"
        }, 
        {
            "location": "/workshop_intro/workshop_settings/index.html#settings", 
            "text": "", 
            "title": "Settings"
        }, 
        {
            "location": "/workshop_intro/workshop_settings/index.html#the-goal", 
            "text": "Understanding packet crafting and crafting packets with scapy  Understanding common attacks and analysis techniques, implementing with scapy.  Writing custom tools using scapy framework!  Have fun while programming and solving challenges!", 
            "title": "The Goal"
        }, 
        {
            "location": "/workshop_intro/workshop_settings/index.html#questions", 
            "text": "RTFM  Ask them when you got them.  It s easy to get lost so  try not to be on auto pilot mode .", 
            "title": "Questions"
        }, 
        {
            "location": "/workshop_intro/workshop_settings/index.html#workshop", 
            "text": "Meter wide   Mile deep!  Pentesters point of view.  Minimal theory, maximal hands-on.  Programming experience in Python preferred but it s possible to follow even without it.  Python 2.7.x   For more on Python 2.x vs 3.x  Python 2.x vs 3.x", 
            "title": "Workshop"
        }, 
        {
            "location": "/workshop_intro/disclaimer/index.html", 
            "text": "Legal ramifications!\n\n\nThe legal ramifications surrounding scanning networks are complex and controversial(like with many other laws pertaining to computer security). When using tools like Scapy/Nmap the line between doing something benign and malignant is thin. Always have written permission before scanning a network you don\nt own, know what you are doing, know your jurisdictions and speak to a lawyer!\n\n\nThe general rules for this class are:\n\n\n\n\nYou don\nt own it; You don\nt scan it!\n\n\n\n\n\n\nDO NOT\n scan any machines at the venue that you don\nt have permission to scan.\n\n\n\n\nLimit your scanning to the following:\n\n\n\n\nThe virtual machines provided as part of the labs.\n\n\nscanme.nmap.org\n\n\negadz.metasploit.com\n\n\nhackme.irongeek.com", 
            "title": "Disclaimer"
        }, 
        {
            "location": "/workshop_intro/disclaimer/index.html#legal-ramifications", 
            "text": "The legal ramifications surrounding scanning networks are complex and controversial(like with many other laws pertaining to computer security). When using tools like Scapy/Nmap the line between doing something benign and malignant is thin. Always have written permission before scanning a network you don t own, know what you are doing, know your jurisdictions and speak to a lawyer!  The general rules for this class are:   You don t own it; You don t scan it!    DO NOT  scan any machines at the venue that you don t have permission to scan.   Limit your scanning to the following:   The virtual machines provided as part of the labs.  scanme.nmap.org  egadz.metasploit.com  hackme.irongeek.com", 
            "title": "Legal ramifications!"
        }, 
        {
            "location": "/lab_setup/lab_setup/index.html", 
            "text": "Mysterious boxes lab setup\n\n\n\n\n\u201cGive me six hours to chop down a tree and I will spend the first four sharpening the axe.\u201d - Lincoln\n\n\n\n\nSetting up\n\n\nDirectory tree\n\n\nUSB\n\u2502\n\u2514\u2500\u2500\u2500null-workshop-packet-crafting-oct2016 \n    \u2502    \n    \u2514\u2500\u2500\u2500\u2500\u2500labs\n         \u2502   \n         \u2514\u2500\u2500\u2500mysterious_boxes\n\n              lab_setup.sh\n              lab_setup.bat\n                ...         \n\n\n\n\n\n\n\n\nFollow the guidlines listed below depending on your primary OS.\n\n\n\n\nWindows\n\n\nStep I\n   \n\n\nCopy the directory \nnull-workshop-packet-crafting-oct2016\n from USB provided on to your Windows machine.\n\n\nStep II\n\n\nInstall Virtualbox(preferably 5.0 or later). Installers are provided in the directory copied.\n\n\nStep III\n\n\nFind the sub-directory \nmysterious_boxes_lab\n and run the script \nlab_setup.bat\n\n\nStep IV\n\n\nOnce the script finshed executing, ping 192.168.56.101. If the pings are sucessful, your lab is configured correctly.\n\n\nLinux\n\n\nStep I\n\n\nCopy the directory \nnull-workshop-packet-crafting-oct2016\n from USB provided on to your Linux machine.\n\n\nStep II\n\n\nInstall Virtualbox(preferably 5.0 or later). Installers are provided in the directory copied.\n\n\nStep III\n\n\nGot to the directory \nmysterious_boxes_lab\n and run the script \nlab_setup.sh\n \n$ ./lab_sh\n\n\nStep IV\n\n\nOnce the script finshed executing, ping 192.168.56.101. If the pings are sucessful, your lab is configured correctly.\n\n\nMac OSX\n\n\nStep I\n\n\nCopy the directory \nnull-workshop-packet-crafting-oct2016\n from USB provided on to your mac.\n\n\nStep II\n\n\nInstall Virtualbox(preferably 5.0 or later). Installers are provided in the directory copied.\n\n\nStep III\n\n\nGo to the directory \nmysterious_boxes_lab\n and run the script \nlab_setup.sh\n\n\nStep IV\n\n\nOnce the script finshed executing, ping 192.168.56.101. If the pings are sucessful, your lab is configured correctly.\n\n\nTopology\n\n\nHost machine\n\n\n\n\nHost OS is the primary Operating System on which you are running virtualbox\n\n\nHost OS is on the same sub-net as the VM\ns\n\n\n\n\nAttacker machine\n\n\n\n\nThe machine with IP address XXX.XXX.XXX.XXX acts as attacker machine.\n\n\nThis is our \nbase box\n for this workshop from where we orchestrate our attacks.\n\n\nPre-configured with all the software neccesary(Scapy, nmap, netdiscover, dsniff, tcpdump\n).\n\n\nYou\nll be able to login to this machine using GUI.\n\n\n\n\nVictim machines\n\n\n\n\nBunch of pre-configured VM\ns.\n\n\nVarious OSs with some listening services and security policies, nothing fancy though.\n\n\n\n\nThe Goal\n\n\nTo find as much information as we can about the victim machines using Scapy.\n\n\n\n\nFingerprinting OSs.\n\n\nFind listening services.\n\n\nUnderstand security policies.", 
            "title": "Mysterious boxes"
        }, 
        {
            "location": "/lab_setup/lab_setup/index.html#mysterious-boxes-lab-setup", 
            "text": "\u201cGive me six hours to chop down a tree and I will spend the first four sharpening the axe.\u201d - Lincoln", 
            "title": "Mysterious boxes lab setup"
        }, 
        {
            "location": "/lab_setup/lab_setup/index.html#setting-up", 
            "text": "", 
            "title": "Setting up"
        }, 
        {
            "location": "/lab_setup/lab_setup/index.html#directory-tree", 
            "text": "USB\n\u2502\n\u2514\u2500\u2500\u2500null-workshop-packet-crafting-oct2016 \n    \u2502    \n    \u2514\u2500\u2500\u2500\u2500\u2500labs\n         \u2502   \n         \u2514\u2500\u2500\u2500mysterious_boxes\n\n              lab_setup.sh\n              lab_setup.bat\n                ...             Follow the guidlines listed below depending on your primary OS.", 
            "title": "Directory tree"
        }, 
        {
            "location": "/lab_setup/lab_setup/index.html#windows", 
            "text": "Step I      Copy the directory  null-workshop-packet-crafting-oct2016  from USB provided on to your Windows machine.  Step II  Install Virtualbox(preferably 5.0 or later). Installers are provided in the directory copied.  Step III  Find the sub-directory  mysterious_boxes_lab  and run the script  lab_setup.bat  Step IV  Once the script finshed executing, ping 192.168.56.101. If the pings are sucessful, your lab is configured correctly.", 
            "title": "Windows"
        }, 
        {
            "location": "/lab_setup/lab_setup/index.html#linux", 
            "text": "Step I  Copy the directory  null-workshop-packet-crafting-oct2016  from USB provided on to your Linux machine.  Step II  Install Virtualbox(preferably 5.0 or later). Installers are provided in the directory copied.  Step III  Got to the directory  mysterious_boxes_lab  and run the script  lab_setup.sh   $ ./lab_sh  Step IV  Once the script finshed executing, ping 192.168.56.101. If the pings are sucessful, your lab is configured correctly.", 
            "title": "Linux"
        }, 
        {
            "location": "/lab_setup/lab_setup/index.html#mac-osx", 
            "text": "Step I  Copy the directory  null-workshop-packet-crafting-oct2016  from USB provided on to your mac.  Step II  Install Virtualbox(preferably 5.0 or later). Installers are provided in the directory copied.  Step III  Go to the directory  mysterious_boxes_lab  and run the script  lab_setup.sh  Step IV  Once the script finshed executing, ping 192.168.56.101. If the pings are sucessful, your lab is configured correctly.", 
            "title": "Mac OSX"
        }, 
        {
            "location": "/lab_setup/lab_setup/index.html#topology", 
            "text": "", 
            "title": "Topology"
        }, 
        {
            "location": "/lab_setup/lab_setup/index.html#host-machine", 
            "text": "Host OS is the primary Operating System on which you are running virtualbox  Host OS is on the same sub-net as the VM s", 
            "title": "Host machine"
        }, 
        {
            "location": "/lab_setup/lab_setup/index.html#attacker-machine", 
            "text": "The machine with IP address XXX.XXX.XXX.XXX acts as attacker machine.  This is our  base box  for this workshop from where we orchestrate our attacks.  Pre-configured with all the software neccesary(Scapy, nmap, netdiscover, dsniff, tcpdump ).  You ll be able to login to this machine using GUI.", 
            "title": "Attacker machine"
        }, 
        {
            "location": "/lab_setup/lab_setup/index.html#victim-machines", 
            "text": "Bunch of pre-configured VM s.  Various OSs with some listening services and security policies, nothing fancy though.", 
            "title": "Victim machines"
        }, 
        {
            "location": "/lab_setup/lab_setup/index.html#the-goal", 
            "text": "To find as much information as we can about the victim machines using Scapy.   Fingerprinting OSs.  Find listening services.  Understand security policies.", 
            "title": "The Goal"
        }, 
        {
            "location": "/lab_setup/network_hunt/index.html", 
            "text": "Network hunt\n lab setup\n\n\nSetting up\n\n\nDirectory tree\n\n\nOn your attacker box\n\n\n/\n\u2502\n\u2514\u2500\u2500\u2500home\n    \u2502\n    \u2514\u2500\u2500\u2500network_hunt_challenge\n        \u2502    \n        \u2514\u2500\u2500 network_hunt.py\n\n\n\n\nInstructions\n\n\n\n\nRun the network_hunt.py script.\n\n\nIf the script executed without errors, the challenge is setup!\n\n\nRefer to \nexercises\n section \n \nnetwork hunt\n page in this notes for instruction on cracking the challenge.", 
            "title": "Network Hunt"
        }, 
        {
            "location": "/lab_setup/network_hunt/index.html#network-hunt-lab-setup", 
            "text": "", 
            "title": "'Network hunt' lab setup"
        }, 
        {
            "location": "/lab_setup/network_hunt/index.html#setting-up", 
            "text": "", 
            "title": "Setting up"
        }, 
        {
            "location": "/lab_setup/network_hunt/index.html#directory-tree", 
            "text": "On your attacker box  /\n\u2502\n\u2514\u2500\u2500\u2500home\n    \u2502\n    \u2514\u2500\u2500\u2500network_hunt_challenge\n        \u2502    \n        \u2514\u2500\u2500 network_hunt.py", 
            "title": "Directory tree"
        }, 
        {
            "location": "/lab_setup/network_hunt/index.html#instructions", 
            "text": "Run the network_hunt.py script.  If the script executed without errors, the challenge is setup!  Refer to  exercises  section    network hunt  page in this notes for instruction on cracking the challenge.", 
            "title": "Instructions"
        }, 
        {
            "location": "/networking/layers/index.html", 
            "text": "Layered Approach", 
            "title": "Layers"
        }, 
        {
            "location": "/networking/layers/index.html#layered-approach", 
            "text": "", 
            "title": "Layered Approach"
        }, 
        {
            "location": "/networking/socket_interface/index.html", 
            "text": "Socket Interface\n\n\n\n\n\n\n\n\n\n\n\nRaw sockets\n\n\nKernel offers two ways to forge packets:\n\n\nLayer 3 - PF_INET, SOCK_RAW\n\n- Classic raw sockets.\n\n- Lotsa hand holding by kernel which inturn limits what you can do.\n \n\n\nLayer 2 - PF_PACKET, PF_RAW\n\n- There is no limit on what you send.\n\n- No hand holding by kernel.\n\n- You are responsible for choosing interfaces, linktypes, ARP stuff, calculate checksums\u2026", 
            "title": "Socket Interface"
        }, 
        {
            "location": "/networking/socket_interface/index.html#socket-interface", 
            "text": "", 
            "title": "Socket Interface"
        }, 
        {
            "location": "/networking/socket_interface/index.html#raw-sockets", 
            "text": "Kernel offers two ways to forge packets:  Layer 3 - PF_INET, SOCK_RAW \n- Classic raw sockets. \n- Lotsa hand holding by kernel which inturn limits what you can do.    Layer 2 - PF_PACKET, PF_RAW \n- There is no limit on what you send. \n- No hand holding by kernel. \n- You are responsible for choosing interfaces, linktypes, ARP stuff, calculate checksums\u2026", 
            "title": "Raw sockets"
        }, 
        {
            "location": "/networking/packet_headers/index.html", 
            "text": "Packet Headers\n\n\nThis workshop is about crafting packets so it makes sense to spend enough time understanding what packets are and how they are structured.\n\n\nIllustrations on this page are reproduced work created and shared by Matt Baxter as seen at \nhttps://nmap.org/book/tcpip-ref.html\n \n\n\nIP Header\n\n\n\n\n\n\n\n\nTCP Header\n\n\n\n\n\n\n\n\n\nUDP Header\n\n\n\n\n\n\n\n\nICMP Header", 
            "title": "Packet Headers"
        }, 
        {
            "location": "/networking/packet_headers/index.html#packet-headers", 
            "text": "This workshop is about crafting packets so it makes sense to spend enough time understanding what packets are and how they are structured.  Illustrations on this page are reproduced work created and shared by Matt Baxter as seen at  https://nmap.org/book/tcpip-ref.html", 
            "title": "Packet Headers"
        }, 
        {
            "location": "/networking/packet_headers/index.html#ip-header", 
            "text": "", 
            "title": "IP Header"
        }, 
        {
            "location": "/networking/packet_headers/index.html#tcp-header", 
            "text": "", 
            "title": "TCP Header"
        }, 
        {
            "location": "/networking/packet_headers/index.html#udp-header", 
            "text": "", 
            "title": "UDP Header"
        }, 
        {
            "location": "/networking/packet_headers/index.html#icmp-header", 
            "text": "", 
            "title": "ICMP Header"
        }, 
        {
            "location": "/python/python/index.html", 
            "text": "Python - Lightspeed revision\n\n\n\n\nImporting modules\n\n\nimport socket\n\nimport argparse\n\n \n\n dir()\n['__builtins__', '__doc__', '__name__', '__package__', 'socket', 'argparse']\n\n\n\n\n\n\n\n\n from socket import *\n\n from scapy.all import *\n\n dir()\n['AF_APPLETALK', 'AF_ASH', 'SOCK_DGRAM', 'SOCK_RAW', 'SOCK_RDM', 'SOCK_SEQPACKET', 'SOCK_STREAM']\n[...snipped...]\n\n\n\n\n\n\nIntrospection\n\n\n\n\nExtremely powerful pythonic feature.\n\n\nFeatures in Python that help understand other features.\n\n\nEverything in Python is an object, and introspection is to look at this objects in memory and provide information them(attributes \n methods).\n\n\n\n\nhelp()\n\n\n help(sys)\n\n\n\n\ndir()\n\n\n dir(sys)\n['__displayhook__', '__doc__', '__excepthook__' [...snipped...]]\n\n\n\n\ntype()\n\n\n import sys\n\n \n\n \n\n type(sys)\n\ntype 'module'\n\n\n type(1)\n\ntype 'int'\n\n\n type()\n\n\n\n\n\ndoc string\n\n\n sys.__doc__\n\nThis module provides access to some objects used [...snipped...]\n\n\n\n\n\n\n\nPython - Lists\n\n\n\n\nSyntax: \nmy_list = [item0, item1,item2]\n\n\nCollection of elements of any data type.\n\n\nLists are \nmutable\n (Can be changed even after creation).\n\n\nPython provides numerous methods on lists. Just \ndir(list_name)\n to get a list of all the methods available.\n\n\nIndexing \n Slicing mechanism is consistent with strings.\n\n\nLists have very useful methods to manipulate them such as append, count, extend, index, insert, pop, remove, reverse,sort.\n\n\n\n\n\ncolors = ['red', 'blue', 'green']\nprint colors[0]    ## red\nprint colors[2]    ## green\nprint len(colors)  ## 3\n\n\n\n\n\n\n\n\n\n\n\n\nAssignment with an = on lists does not make a copy. Instead, assignment makes the two variables point to the one list in memory.\n\n\n\n\n\n\n\n\n\n\n\n\n\nList of lists or sublists\n\n\nLists can have sublists as elements. These sublists may contain sublists as well, i.e. lists can be recursively constructed by sublist structures.\n\n\n\n\n\n\n\n\n\n employee_details = [('Mark','22489'),('Steph','88153'),('Ajay','99112')]\n\n\n\n for i in xrange(len(employee_details)):\n...          print employee_details[i][0], employee_details[i][1]\n... \nMark 22489\nSteph 88153\nAjay 99112\n\n\n\n\n\nTuples\n\n\n\n\nSyntax \nmy_tuple = (val0, val1)\n\n\nA tuple is a \nfixed size\n grouping of elements.\n\n\nTuples are like lists but are \nimmutable\n and do not change size (tuples are not strictly immutable since one of the contained elements could be mutable).\n\n\nTuples have no other methods other than builtin\ns\n\n\n\nTuples are faster than lists.\n\n\nTuples are immutable so they protect from data being changed.\n\n\nTuples can be used as keys in a dictionary.\n\n\n\n\n  tuple = (1, 2, 'hi')\n  print len(tuple)  ## 3\n  print tuple[2]    ## hi\n  tuple[2] = 'bye'  ## NO, tuples cannot be changed\n  tuple = (1, 2, 'bye')  ## this works\n\n\n\n\nIf/elif/else\n\n\n\n\nAny value can be used as an if-test. The \nzero\n values all count as false: None, 0, empty string, empty list, empty dictionary.\n\n\nComparision operations: ==, !=, \n, \n=, \n, \n=\n\n\nThe boolean operators are the spelled out words \nand\n, \nor\n, \nnot\n (Python does not use the C-style \n || !).\n\n\n\n\n\nreturn = scan_target('10.5.0.6')\nif return == 0:\n    print \n[+] Scan sucessful!!\n\n    print packet\nelif return ==1:\n    print \n[-] Scan unsucessful!!\n\n    print \n[*] Inspect with wireshark\n\nelse:\n    print \n[!] Unknown error\n\n\n\n\n\n\n  if speed \n= 80:\n    print 'License and registration please'\n    if mood == 'terrible' or speed \n= 100:\n      print 'You have the right to remain silent.'\n    elif mood == 'bad' or speed \n= 90:\n      print \nI'm going to have to write you a ticket.\n\n      write_ticket()\n    else:\n      print \nLet's try to keep it under 80 ok?\n\n\n\n\nWhile loop\n\n\nPython also has the standard while-loop, and the \nbreak\n and \ncontinue\n statements work as in C++ and Java, altering the course of the innermost loop. The above for/in loops solves the common case of iterating over every element in a list, but the while loop gives you total control over the index numbers. Here\ns a while loop which accesses every 3rd element in a list:\n\n\n  ## Access every 3rd element in a list\n  i = 0\n  while i \n len(a):\n    print a[i]\n    i = i + 3\n\n\n\n\nFor Loop\n\n\nFOR - IN construct\n\n\n\n\nPython\ns \nfor\n and \nin\n constructs are extremely useful.\n\n\nThe \nfor\n construct \n \nfor var in list\n \n is an easy way to look at each element in a list (or other collection). Do not add or remove from the list during iteration.\n\n\n\n\n  squares = [1, 4, 9, 16]\n  sum = 0\n  for num in squares:\n    sum += num\n  print sum  ## 30\n\n\n\n\n\n\nThe \nin\n construct on its own is an easy way to test if an element appears in a list (or other collection) \n \nvalue in collection\n \n tests if the value is in the collection, returning True/False.\n\n\n\n\n  list = ['larry', 'curly', 'moe']\n  if 'curly' in list:\n    print 'yay'\n\n\n\n\nRange \n Xrange\n\n\n\n\nPython for loop iterates over a range of numbers, list of elements.\n\n\nThe \nrange(n)\n function yields the numbers 0, 1, \n n-1, and range(a, b) returns a, a+1, \n b-1 \n\n\n\n\n from socket import *\n\n open_ports = [21, 23, 25, 80, 139, 8080]\n\n \n\n for a in xrange(len(open_ports)):\n...     print \n[+] Port num: {} {} is open.\n.format(open_ports[a], getservbyport(open_ports[a]))\n... \n[+] Port num: 21 ftp is open.\n[+] Port num: 23 telnet is open.\n[+] Port num: 25 smtp is open.\n[+] Port num: 80 http is open.\n[+] Port num: 139 netbios-ssn is open.\n[+] Port num: 8080 http-alt is open.\n\n\n\n\n\n\nprint\n as a statement\n\n\n\n\nIn \nPython2.X \nprint\n is a statement\n not a function.\n\n\nVery intutive but not very powerful.\n\n\n\n\n answer = 42\n\n print \nThe answer is: \n + str(answer)\nThe answer is: 42\n\n\n\n\nprint\n as a function\n\n\n\n\nIn \nPython 3.X \nprint\n is a function\n which gives it more control on how to print stuff.\n\n\nYou can import print funtion into python 2.7.X using the statement \nfrom future import print_function\n\n\nI would recommend using print as a function even in Python2.X, for one your code will be more compatiable with Python3.X and also print function gives you more control on the output.\n\n\n\n\n from __future__ import print_function       # This internally sets a flag that lets interpreter enable print function\n\n answer = 42\n\n print('The answer is: '+str(42))\nThe answer is: 42\n\n\n\n\n\n\nPrint as a funtion can take arguments which provide more control on how you ptint stuff.\n\n\n\n\nprint(value1, ..., sep=' ', end='\\n', file=sys.stdout, flush=False)\n#\n#    file: a file-like object (stream); defaults to the current sys.stdout.\n#    sep:  string inserted between values, default a space.\n#    end:  string appended after the last value, default a newline.\n#\n\n\n\n\n\n\nWith the \nend\n argument you can choose what is appended as the last value.\n\n\n\n\n# Building a simple NOP sled for memory exploits\n# Only one of the output works for a NOP sled. Which one? Why?(Out of this workshop context though)\n\n\n\n print('\\x90'*30)\n\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n\n \n\n print('\\x90'*30, end='')\n\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n \n\n\n\n\n\n\n\n\nBy redefining the keyword parameter \nfile\n we can send the output into a different stream e.g. to a file or stderr\n\n\n\n\n fh = open(\ndata.txt\n,\nw\n)\n\n print(\n42 is the answer, but what is the question?\n, file=fh) \n\n fh.close()      # we see no ouput  to console after print because it's directed into the file fh\n\n\n\n\nC-Style format strings\n\n\n\n\nThe nearest thing to c-style printf equivalent in python.\n\n\n'%s %s' % ('one', 'two')\n\n\n\n\n\n\n\n\n\n\n\n port_number = 139\n\n \n\n host = '10.5.0.6'\n\n \n\n print \nPort num: %d is open on Host: %s\n%(port_number, host)\nPort num: 139 is open on Host: 10.5.0.6\n\n\n\n\n\n\nFor more on format string modulo: \nhttp://www.python-course.eu/python3_formatted_output.php\n \n\n\nPythonic style - string format method.\n\n\n\n\n\n\nPython has awesome string formatters to produce beautifully formatted output.\n\n\n\n\n\n\nThe \nfields to be replaced\n are surrounded by curly braces {}.\n\n'{} {}'.format('one', 'two')\n\n\n\n\n\n\n print \n[+] Port num: {} on host {} is open.\n.format(port_number, hostname)\n\n\n\n\nPlaceholders\n\n\n\n\nPython string format method supports placeholders and an explicit positional index. \n{1} {0}'.format('one', 'two')\n\n\nA positional parameter of the format method can be accessed by placing the index of the parameter after the opening brace, e.g. {0} accesses the first parameter.\n\n\n\n\n\n\n\n\n\n\n\n\n- Keywords can be used to index parameters as well.(Named placeholders)\n\n\n \nArt: {a:5d},  Price: {p:8.2f}\n.format(a=453, p=59.058)\n'Art:   453,  Price:    59.06'\n\n \n\n\n\n\nPadding and aligning strings\n\n\nBy default values are formatted to take up only as many characters as needed to represent the content. It is however also possible to define that a value should be padded to a specific length.\n\n\n\n\nWe can precede the formatting with a \n (left justify) or \n (right justify)\n\n\n\n\n '{:\n10}'.format('test')                             # right align\n'      test'\n\n\n\n \n{0:\n20s} {1:6.2f}\n.format('Spam \n Eggs:', 6.99)    # left align\n'Spam \n Eggs:           6.99'\n\n\n\n'{:^10}'.format('test')                          #center align\n'   test   '\n\n\n\n\n\n\nChoose your character for padding. \n'{:_\n10}'.format('test')\n\n\n\n\n '{:_\n10}'.format('test')\n'test______'\n\n\n\n\n\n\nFurther reading on string format method \nhttps://pyformat.info/\n \n\n\n\nsys.stdout.write()\n\n\nThis could be used to write to standard output or consoles when print doesn\u2019t seem to work.\n\n\n pack = '\\x90\\x32\\x67\\x70'\n\n sys.stdout.write(pack)\n\ufffd2gp\n \n\n\n\n\nList Comprehensions\n\n\n\n\nA list comprehension is a compact way to write an expression that expands to a whole list.\n\n\nList comprehension can almost substitute for the lambda function especially as map(), filter() and reduce().\n\n\n\n\n\n\n\n\n\n\n\n\n\nExamples\n\n\n# compute a list of their squares of elements in a list\nnums = [1, 2, 3, 4]\n\nsquares = [ n * n for n in nums ]   ## [1, 4, 9, 16]\n\n\n\n\n port_numbers = [22,25,80,139,443]\n\n [k for k in port_numbers]\n[22, 25, 80, 139, 443]\n\n\n\n numbers = [2,4,6,8] \n\n [k*2 for k in numbers]\n[4, 8, 12, 16]\n\n\n\n\n\n\n\nYou can add an if test to the right of the for-loop to narrow the result. The if test is evaluated for each element, including only the elements where the test is true.\n\n\n\n\n port_numbers = [22,25,80,139,443,8080,9999,55555]\n\n \n\n [k for k in port_numbers if k\n1023]\n[22, 25, 80, 139, 443]\n\n\n\n\n\nLambda functions\n\n\nSyntax: \nlambda arg1, arg2, \nargN : expression using arguments\n.\n\n\n\n\n\n\n\n\n\n\n\n\n- Python supports the creation of anonymous functions (i.e. functions that are not bound to a name) at runtime, using a construct called \nlambda\n.\n\n- Lambda functions take any number of arguments but only has one expression, the result of this expression is returned.\n\n\n def f (x): return x**2\n... \n\n print f(8)\n64\n\n \n\n g = lambda x: x**2\n\n \n\n print g(8)\n64\n\n\n\n\n\n\nLambda functions can be used anywhere a function is expected, not necessary to assign it to a variable.\n\n\nYou can pass lambda functions to other functions to do stuff(for example lambda function as key to sorted())\n\n\n\n\n\n\n\n\nExtracting numbers that are multiples of 3.\n\n\nOne element of data structure(a list here) gets passed to the lambda function at a time.\n\n\nLambda function can only have one expression.\n\n\nfilter\n is a built-in function in Python that take a function and a data structure as arguments, passes one element of data structure at a time to the function.\n\n\n\n\n mult3 = filter(lambda x: x % 3 == 0, [1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n mult3\n[3, 6, 9]\n\n\n\n\n\n\nSort elements in list by last character.\n\n\n\n\n lis = ['az', 'bbbbbbt', 'cccx']\n\n\n\n sorted_by_last = sorted(lis, key = lambda(x): x[-1] )   \n\n\n\n sorted_by_last\n['bbbbbbt', 'cccx', 'az']\n\n\n\n\n\n\n\nExtracting privileged ports(under 1024) from a list of port numbers using lambda function.\n\n\n\n\n open_ports = [1,20,21,25,80,443,1639,4444,6798]\n\n \n\n privileged_ports = filter(lambda x: x \n1024, open_ports)\n\n privileged_ports\n[1, 20, 21, 25, 80, 443]\n\n \n\n\n\n\n\n\nDoing the same with normal function.\n\n\nIf you are not comfortable with using lambda functions, you can simply use normal functions.\n\n\n\n\n def extract_priv_ports(port_number):\n...     if port_number \n 1024:\n...         return port_number\n\n\n\n privileged_ports = filter(extract_priv_ports, open_ports)\n\n privileged_ports\n[1, 20, 21, 25, 80, 443]\n\n \n\n\n\n\n\n\nUsing Lambda\n\n\nLambda funtions are good when they are short and as throw away functions. If you plan on doing anything remotely complex with it, put lambda away and define a real function.", 
            "title": "Python"
        }, 
        {
            "location": "/python/python/index.html#python-lightspeed-revision", 
            "text": "", 
            "title": "Python - Lightspeed revision"
        }, 
        {
            "location": "/python/python/index.html#importing-modules", 
            "text": "import socket import argparse    dir()\n['__builtins__', '__doc__', '__name__', '__package__', 'socket', 'argparse']     from socket import *  from scapy.all import *  dir()\n['AF_APPLETALK', 'AF_ASH', 'SOCK_DGRAM', 'SOCK_RAW', 'SOCK_RDM', 'SOCK_SEQPACKET', 'SOCK_STREAM']\n[...snipped...]", 
            "title": "Importing modules"
        }, 
        {
            "location": "/python/python/index.html#introspection", 
            "text": "Extremely powerful pythonic feature.  Features in Python that help understand other features.  Everything in Python is an object, and introspection is to look at this objects in memory and provide information them(attributes   methods).", 
            "title": "Introspection"
        }, 
        {
            "location": "/python/python/index.html#help", 
            "text": "help(sys)", 
            "title": "help()"
        }, 
        {
            "location": "/python/python/index.html#dir", 
            "text": "dir(sys)\n['__displayhook__', '__doc__', '__excepthook__' [...snipped...]]", 
            "title": "dir()"
        }, 
        {
            "location": "/python/python/index.html#type", 
            "text": "import sys      type(sys) type 'module'   type(1) type 'int'   type()", 
            "title": "type()"
        }, 
        {
            "location": "/python/python/index.html#doc-string", 
            "text": "sys.__doc__ This module provides access to some objects used [...snipped...]", 
            "title": "doc string"
        }, 
        {
            "location": "/python/python/index.html#python-lists", 
            "text": "Syntax:  my_list = [item0, item1,item2]  Collection of elements of any data type.  Lists are  mutable  (Can be changed even after creation).  Python provides numerous methods on lists. Just  dir(list_name)  to get a list of all the methods available.  Indexing   Slicing mechanism is consistent with strings.  Lists have very useful methods to manipulate them such as append, count, extend, index, insert, pop, remove, reverse,sort.   colors = ['red', 'blue', 'green']\nprint colors[0]    ## red\nprint colors[2]    ## green\nprint len(colors)  ## 3     \nAssignment with an = on lists does not make a copy. Instead, assignment makes the two variables point to the one list in memory.", 
            "title": "Python - Lists"
        }, 
        {
            "location": "/python/python/index.html#list-of-lists-or-sublists", 
            "text": "Lists can have sublists as elements. These sublists may contain sublists as well, i.e. lists can be recursively constructed by sublist structures.      employee_details = [('Mark','22489'),('Steph','88153'),('Ajay','99112')]   for i in xrange(len(employee_details)):\n...          print employee_details[i][0], employee_details[i][1]\n... \nMark 22489\nSteph 88153\nAjay 99112", 
            "title": "List of lists or sublists"
        }, 
        {
            "location": "/python/python/index.html#tuples", 
            "text": "Syntax  my_tuple = (val0, val1)  A tuple is a  fixed size  grouping of elements.  Tuples are like lists but are  immutable  and do not change size (tuples are not strictly immutable since one of the contained elements could be mutable).  Tuples have no other methods other than builtin s  Tuples are faster than lists.  Tuples are immutable so they protect from data being changed.  Tuples can be used as keys in a dictionary.     tuple = (1, 2, 'hi')\n  print len(tuple)  ## 3\n  print tuple[2]    ## hi\n  tuple[2] = 'bye'  ## NO, tuples cannot be changed\n  tuple = (1, 2, 'bye')  ## this works", 
            "title": "Tuples"
        }, 
        {
            "location": "/python/python/index.html#ifelifelse", 
            "text": "Any value can be used as an if-test. The  zero  values all count as false: None, 0, empty string, empty list, empty dictionary.  Comparision operations: ==, !=,  ,  =,  ,  =  The boolean operators are the spelled out words  and ,  or ,  not  (Python does not use the C-style   || !).   \nreturn = scan_target('10.5.0.6')\nif return == 0:\n    print  [+] Scan sucessful!! \n    print packet\nelif return ==1:\n    print  [-] Scan unsucessful!! \n    print  [*] Inspect with wireshark \nelse:\n    print  [!] Unknown error     if speed  = 80:\n    print 'License and registration please'\n    if mood == 'terrible' or speed  = 100:\n      print 'You have the right to remain silent.'\n    elif mood == 'bad' or speed  = 90:\n      print  I'm going to have to write you a ticket. \n      write_ticket()\n    else:\n      print  Let's try to keep it under 80 ok?", 
            "title": "If/elif/else"
        }, 
        {
            "location": "/python/python/index.html#while-loop", 
            "text": "Python also has the standard while-loop, and the  break  and  continue  statements work as in C++ and Java, altering the course of the innermost loop. The above for/in loops solves the common case of iterating over every element in a list, but the while loop gives you total control over the index numbers. Here s a while loop which accesses every 3rd element in a list:    ## Access every 3rd element in a list\n  i = 0\n  while i   len(a):\n    print a[i]\n    i = i + 3", 
            "title": "While loop"
        }, 
        {
            "location": "/python/python/index.html#for-loop", 
            "text": "", 
            "title": "For Loop"
        }, 
        {
            "location": "/python/python/index.html#for-in-construct", 
            "text": "Python s  for  and  in  constructs are extremely useful.  The  for  construct    for var in list    is an easy way to look at each element in a list (or other collection). Do not add or remove from the list during iteration.     squares = [1, 4, 9, 16]\n  sum = 0\n  for num in squares:\n    sum += num\n  print sum  ## 30   The  in  construct on its own is an easy way to test if an element appears in a list (or other collection)    value in collection    tests if the value is in the collection, returning True/False.     list = ['larry', 'curly', 'moe']\n  if 'curly' in list:\n    print 'yay'", 
            "title": "FOR - IN construct"
        }, 
        {
            "location": "/python/python/index.html#range-xrange", 
            "text": "Python for loop iterates over a range of numbers, list of elements.  The  range(n)  function yields the numbers 0, 1,   n-1, and range(a, b) returns a, a+1,   b-1     from socket import *  open_ports = [21, 23, 25, 80, 139, 8080]    for a in xrange(len(open_ports)):\n...     print  [+] Port num: {} {} is open. .format(open_ports[a], getservbyport(open_ports[a]))\n... \n[+] Port num: 21 ftp is open.\n[+] Port num: 23 telnet is open.\n[+] Port num: 25 smtp is open.\n[+] Port num: 80 http is open.\n[+] Port num: 139 netbios-ssn is open.\n[+] Port num: 8080 http-alt is open.", 
            "title": "Range &amp; Xrange"
        }, 
        {
            "location": "/python/python/index.html#print-as-a-statement", 
            "text": "In  Python2.X  print  is a statement  not a function.  Very intutive but not very powerful.    answer = 42  print  The answer is:   + str(answer)\nThe answer is: 42", 
            "title": "print as a statement"
        }, 
        {
            "location": "/python/python/index.html#print-as-a-function", 
            "text": "In  Python 3.X  print  is a function  which gives it more control on how to print stuff.  You can import print funtion into python 2.7.X using the statement  from future import print_function  I would recommend using print as a function even in Python2.X, for one your code will be more compatiable with Python3.X and also print function gives you more control on the output.    from __future__ import print_function       # This internally sets a flag that lets interpreter enable print function  answer = 42  print('The answer is: '+str(42))\nThe answer is: 42   Print as a funtion can take arguments which provide more control on how you ptint stuff.   print(value1, ..., sep=' ', end='\\n', file=sys.stdout, flush=False)\n#\n#    file: a file-like object (stream); defaults to the current sys.stdout.\n#    sep:  string inserted between values, default a space.\n#    end:  string appended after the last value, default a newline.\n#   With the  end  argument you can choose what is appended as the last value.   # Building a simple NOP sled for memory exploits\n# Only one of the output works for a NOP sled. Which one? Why?(Out of this workshop context though)   print('\\x90'*30)\n\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd    print('\\x90'*30, end='')\n\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd      By redefining the keyword parameter  file  we can send the output into a different stream e.g. to a file or stderr    fh = open( data.txt , w )  print( 42 is the answer, but what is the question? , file=fh)   fh.close()      # we see no ouput  to console after print because it's directed into the file fh", 
            "title": "print as a function"
        }, 
        {
            "location": "/python/python/index.html#c-style-format-strings", 
            "text": "The nearest thing to c-style printf equivalent in python.  '%s %s' % ('one', 'two')       port_number = 139    host = '10.5.0.6'    print  Port num: %d is open on Host: %s %(port_number, host)\nPort num: 139 is open on Host: 10.5.0.6   For more on format string modulo:  http://www.python-course.eu/python3_formatted_output.php", 
            "title": "C-Style format strings"
        }, 
        {
            "location": "/python/python/index.html#pythonic-style-string-format-method", 
            "text": "Python has awesome string formatters to produce beautifully formatted output.    The  fields to be replaced  are surrounded by curly braces {}. '{} {}'.format('one', 'two')     print  [+] Port num: {} on host {} is open. .format(port_number, hostname)", 
            "title": "Pythonic style - string format method."
        }, 
        {
            "location": "/python/python/index.html#placeholders", 
            "text": "Python string format method supports placeholders and an explicit positional index.  {1} {0}'.format('one', 'two')  A positional parameter of the format method can be accessed by placing the index of the parameter after the opening brace, e.g. {0} accesses the first parameter.      \n- Keywords can be used to index parameters as well.(Named placeholders)    Art: {a:5d},  Price: {p:8.2f} .format(a=453, p=59.058)\n'Art:   453,  Price:    59.06'", 
            "title": "Placeholders"
        }, 
        {
            "location": "/python/python/index.html#padding-and-aligning-strings", 
            "text": "By default values are formatted to take up only as many characters as needed to represent the content. It is however also possible to define that a value should be padded to a specific length.   We can precede the formatting with a   (left justify) or   (right justify)    '{: 10}'.format('test')                             # right align\n'      test'    {0: 20s} {1:6.2f} .format('Spam   Eggs:', 6.99)    # left align\n'Spam   Eggs:           6.99'  '{:^10}'.format('test')                          #center align\n'   test   '   Choose your character for padding.  '{:_ 10}'.format('test')    '{:_ 10}'.format('test')\n'test______'  \nFurther reading on string format method  https://pyformat.info/", 
            "title": "Padding and aligning strings"
        }, 
        {
            "location": "/python/python/index.html#sysstdoutwrite", 
            "text": "This could be used to write to standard output or consoles when print doesn\u2019t seem to work.   pack = '\\x90\\x32\\x67\\x70'  sys.stdout.write(pack)\n\ufffd2gp", 
            "title": "sys.stdout.write()"
        }, 
        {
            "location": "/python/python/index.html#list-comprehensions", 
            "text": "A list comprehension is a compact way to write an expression that expands to a whole list.  List comprehension can almost substitute for the lambda function especially as map(), filter() and reduce().", 
            "title": "List Comprehensions"
        }, 
        {
            "location": "/python/python/index.html#examples", 
            "text": "# compute a list of their squares of elements in a list\nnums = [1, 2, 3, 4]\n\nsquares = [ n * n for n in nums ]   ## [1, 4, 9, 16]   port_numbers = [22,25,80,139,443]  [k for k in port_numbers]\n[22, 25, 80, 139, 443]   numbers = [2,4,6,8]   [k*2 for k in numbers]\n[4, 8, 12, 16]   You can add an if test to the right of the for-loop to narrow the result. The if test is evaluated for each element, including only the elements where the test is true.    port_numbers = [22,25,80,139,443,8080,9999,55555]    [k for k in port_numbers if k 1023]\n[22, 25, 80, 139, 443]", 
            "title": "Examples"
        }, 
        {
            "location": "/python/python/index.html#lambda-functions", 
            "text": "Syntax:  lambda arg1, arg2,  argN : expression using arguments .      \n- Python supports the creation of anonymous functions (i.e. functions that are not bound to a name) at runtime, using a construct called  lambda . \n- Lambda functions take any number of arguments but only has one expression, the result of this expression is returned.   def f (x): return x**2\n...   print f(8)\n64    g = lambda x: x**2    print g(8)\n64   Lambda functions can be used anywhere a function is expected, not necessary to assign it to a variable.  You can pass lambda functions to other functions to do stuff(for example lambda function as key to sorted())     Extracting numbers that are multiples of 3.  One element of data structure(a list here) gets passed to the lambda function at a time.  Lambda function can only have one expression.  filter  is a built-in function in Python that take a function and a data structure as arguments, passes one element of data structure at a time to the function.    mult3 = filter(lambda x: x % 3 == 0, [1, 2, 3, 4, 5, 6, 7, 8, 9])  mult3\n[3, 6, 9]   Sort elements in list by last character.    lis = ['az', 'bbbbbbt', 'cccx']   sorted_by_last = sorted(lis, key = lambda(x): x[-1] )      sorted_by_last\n['bbbbbbt', 'cccx', 'az']   Extracting privileged ports(under 1024) from a list of port numbers using lambda function.    open_ports = [1,20,21,25,80,443,1639,4444,6798]    privileged_ports = filter(lambda x: x  1024, open_ports)  privileged_ports\n[1, 20, 21, 25, 80, 443]     Doing the same with normal function.  If you are not comfortable with using lambda functions, you can simply use normal functions.    def extract_priv_ports(port_number):\n...     if port_number   1024:\n...         return port_number   privileged_ports = filter(extract_priv_ports, open_ports)  privileged_ports\n[1, 20, 21, 25, 80, 443]     Using Lambda  Lambda funtions are good when they are short and as throw away functions. If you plan on doing anything remotely complex with it, put lambda away and define a real function.", 
            "title": "Lambda functions"
        }, 
        {
            "location": "/scapy/scapy_intro/index.html", 
            "text": "Scapy - Intro\n\n\nTrivia\n\n\n\n\nScapy is packet crafting, manipulating and analysis suite . \n\n\nPython interpreter disguised as a Domain Specific Language. \n\n\nCreated by Philippe Biondi.\n\n\n\n\nOverview\n\n\n\n\nHelps to forge packets, send \n recieve packets, R\nW pcaps, alter packets.\n\n\nEasy \n faster packet desgining.\n\n\nDozens of in-built functions to automate various network utilities/attacks..\n\n\n\n\nWhat\ns different about Scapy?\n\n\nYou might be wondering that there are dozens of packet crafting tools and why use Scapy?\n\n\n\n\n\n\nDecode, Not Interpret .\n\n\n\n\n\n\nProbe Once, Interpret Many Times.\n\n\n\n\n\n\nScapy is not a simple shell command program; \nScapy runs inside Python interpreter\n, provides you the whole language when dealing with packets but you don\u2019t need to master Python to use Scapy though.\n\n\n\n\n\n\nScapy Limitations\n\n\n\n\n\n\nScapy is not designed for fast throughput. It\ns written in Python which comes with many layers of abstraction.\n\n\n\n\n\n\nScapy does not go easy on memory(Each packet is a class instance). Not a right choice for analysing large packet captures.", 
            "title": "Scapy Intro"
        }, 
        {
            "location": "/scapy/scapy_intro/index.html#scapy-intro", 
            "text": "", 
            "title": "Scapy - Intro"
        }, 
        {
            "location": "/scapy/scapy_intro/index.html#trivia", 
            "text": "Scapy is packet crafting, manipulating and analysis suite .   Python interpreter disguised as a Domain Specific Language.   Created by Philippe Biondi.", 
            "title": "Trivia"
        }, 
        {
            "location": "/scapy/scapy_intro/index.html#overview", 
            "text": "Helps to forge packets, send   recieve packets, R W pcaps, alter packets.  Easy   faster packet desgining.  Dozens of in-built functions to automate various network utilities/attacks..", 
            "title": "Overview"
        }, 
        {
            "location": "/scapy/scapy_intro/index.html#whats-different-about-scapy", 
            "text": "You might be wondering that there are dozens of packet crafting tools and why use Scapy?    Decode, Not Interpret .    Probe Once, Interpret Many Times.    Scapy is not a simple shell command program;  Scapy runs inside Python interpreter , provides you the whole language when dealing with packets but you don\u2019t need to master Python to use Scapy though.", 
            "title": "What's different about Scapy?"
        }, 
        {
            "location": "/scapy/scapy_intro/index.html#scapy-limitations", 
            "text": "Scapy is not designed for fast throughput. It s written in Python which comes with many layers of abstraction.    Scapy does not go easy on memory(Each packet is a class instance). Not a right choice for analysing large packet captures.", 
            "title": "Scapy Limitations"
        }, 
        {
            "location": "/scapy/scapy_modes/index.html", 
            "text": "Scapy - Interactive mode\n\n\n\n\nJust run \nscapy\n command in your terminal. You will be presented with an interactive interpreter.\n\n\nIt\ns just a Python interpreter disguised as a Domain Specific Language i.e. python interpreter loaded with scapy classes and objects.\n\n\nScapy in interactive mode suits well for one-liners.\n\n\n\n\nverax@humla ~/humla $ scapy\nWelcome to Scapy (2.3.1)\n\n \n\n \n\n sniff()\n^C\nSniffed: TCP:281 UDP:0 ICMP:0 Other:2\n\n\n\n\n\n\n\nImporting Scapy as a module\n\n\n\n\nScapy can be imported as an externam module into any python scipt.\n\n\n\n\n from scapy.all import *\n\n dir()\n['AES', 'AH', 'ARC2', 'ARC4', 'ARP', 'ARPHDR_ETHER', 'ARPHDR_LOOPBACK', 'ARPHDR_METRICOM'   [...snipped...]\n\n IP\n\nclass 'scapy.layers.inet.IP'\n\n\n TCP\n\nclass 'scapy.layers.inet.TCP'", 
            "title": "Scapy Modes"
        }, 
        {
            "location": "/scapy/scapy_modes/index.html#scapy-interactive-mode", 
            "text": "Just run  scapy  command in your terminal. You will be presented with an interactive interpreter.  It s just a Python interpreter disguised as a Domain Specific Language i.e. python interpreter loaded with scapy classes and objects.  Scapy in interactive mode suits well for one-liners.   verax@humla ~/humla $ scapy\nWelcome to Scapy (2.3.1)      sniff()\n^C Sniffed: TCP:281 UDP:0 ICMP:0 Other:2", 
            "title": "Scapy - Interactive mode"
        }, 
        {
            "location": "/scapy/scapy_modes/index.html#importing-scapy-as-a-module", 
            "text": "Scapy can be imported as an externam module into any python scipt.    from scapy.all import *  dir()\n['AES', 'AH', 'ARC2', 'ARC4', 'ARP', 'ARPHDR_ETHER', 'ARPHDR_LOOPBACK', 'ARPHDR_METRICOM'   [...snipped...]  IP class 'scapy.layers.inet.IP'   TCP class 'scapy.layers.inet.TCP'", 
            "title": "Importing Scapy as a module"
        }, 
        {
            "location": "/scapy/scapy_exploring/index.html", 
            "text": "Exploring scapy\n\n\nList of protocols supported\n\n\n ls()\nARP        : ARP\nDNS        : DNS\nDot11      : 802.11\nTCP        : TCP\nEther      : Ethernet\n[...]\n\n\n\n\nDissecting protocols\n\n\n ls(IP)\nversion    : BitField             = (4)\nihl        : BitField             = (None)\ntos        : XByteField           = (0)\nlen        : ShortField           = (None)\nid         : ShortField           = (1)\nflags      : FlagsField           = (0)\nfrag       : BitField             = (0)\nttl        : ByteField            = (64)\nproto      : ByteEnumField        = (0)\nchksum     : XShortField          = (None)\nsrc        : Emph                 = (None)\ndst        : Emph                 = ('127.0.0.1')\noptions    : PacketListField      = ([])\n\n\n\n\nList of all the scapy commands\n\n\n lsc()\nrdpcap     : Read a pcap file and return a packet \nsend       : Send packets at layer 3\nsendp      : Send packets at layer 2\nsendpfast  : Send packets at layer 2 using tcpreplay\n[...]\n\n\n\n\nGetting help on any function\n\n\n help(arpcachepoison)\n\nHelp on function arpcachepoison in module scapy.layers.l2:\n\narpcachepoison(target, victim, interval=60)\n    Poison target's cache with (your MAC,victim's IP) couple\n    arpcachepoison(target, victim, [interval=60]) -\n None\n\n[...]\n\n\n\n\nChange Scapy configuration\n\n\n conf\niface      = 'eth3'\niface6     = 'wlan0'\nwepkey     = ''\nsniff_promisc = 1\n[...]\n\n\n\n\n\n\nRoot Alert!\n\n\nAssembling and sending raw packets requires UID 0(root access) . Use sudo to become root.", 
            "title": "Exploring scapy"
        }, 
        {
            "location": "/scapy/scapy_exploring/index.html#exploring-scapy", 
            "text": "", 
            "title": "Exploring scapy"
        }, 
        {
            "location": "/scapy/scapy_exploring/index.html#list-of-protocols-supported", 
            "text": "ls()\nARP        : ARP\nDNS        : DNS\nDot11      : 802.11\nTCP        : TCP\nEther      : Ethernet\n[...]", 
            "title": "List of protocols supported"
        }, 
        {
            "location": "/scapy/scapy_exploring/index.html#dissecting-protocols", 
            "text": "ls(IP)\nversion    : BitField             = (4)\nihl        : BitField             = (None)\ntos        : XByteField           = (0)\nlen        : ShortField           = (None)\nid         : ShortField           = (1)\nflags      : FlagsField           = (0)\nfrag       : BitField             = (0)\nttl        : ByteField            = (64)\nproto      : ByteEnumField        = (0)\nchksum     : XShortField          = (None)\nsrc        : Emph                 = (None)\ndst        : Emph                 = ('127.0.0.1')\noptions    : PacketListField      = ([])", 
            "title": "Dissecting protocols"
        }, 
        {
            "location": "/scapy/scapy_exploring/index.html#list-of-all-the-scapy-commands", 
            "text": "lsc()\nrdpcap     : Read a pcap file and return a packet \nsend       : Send packets at layer 3\nsendp      : Send packets at layer 2\nsendpfast  : Send packets at layer 2 using tcpreplay\n[...]", 
            "title": "List of all the scapy commands"
        }, 
        {
            "location": "/scapy/scapy_exploring/index.html#getting-help-on-any-function", 
            "text": "help(arpcachepoison)\n\nHelp on function arpcachepoison in module scapy.layers.l2:\n\narpcachepoison(target, victim, interval=60)\n    Poison target's cache with (your MAC,victim's IP) couple\n    arpcachepoison(target, victim, [interval=60]) -  None\n\n[...]", 
            "title": "Getting help on any function"
        }, 
        {
            "location": "/scapy/scapy_exploring/index.html#change-scapy-configuration", 
            "text": "conf\niface      = 'eth3'\niface6     = 'wlan0'\nwepkey     = ''\nsniff_promisc = 1\n[...]   Root Alert!  Assembling and sending raw packets requires UID 0(root access) . Use sudo to become root.", 
            "title": "Change Scapy configuration"
        }, 
        {
            "location": "/scapy/creating_packets/index.html", 
            "text": "Creating packets with Scapy\n\n\nCreating a packet\n\n\n\n\nScapy packet creation is consistent with layered approach in networking.\n\n\nThe basic building block of a packet is a layer, and a whole packet is built by stack- ing layers on top of one another.\n\n\nIn scapy, packets are constructed by defining packet headers for each protocol at different layers of TCP/IP and then stacking these layers in order.\n\n\nTo create a DNS query, you need to build Ether(sometimes optional), IP,UDP headers and stack them using \n/\n operator.\n\n\n\n\nCreating packet in one line\n\n\n packet = Ether()/IP(dst='8.8.8.8')/TCP(dport=53,flags='S')\n\n\n\n\n\n\nA full-fledged DNS request packet\n\n\n\n\n dns_query = Ether()/IP(dst='8.8.8.8')/UDP(dport=53)/DNS(opcode='QUERY')/DNSQR(qname='null.co.in', qtype = 'A')\n\n \n\n dns_query\n\nEther  type=0x800 |\nIP  frag=0 proto=udp dst=8.8.8.8 |\nUDP  sport=domain dport=domain |\nDNS  opcode=QUERY |\nDNSQR  qname='null.co.in' qtype=A |\n\n\n\n\n\nCreate each layer individually and stack them using \n/\n operator\n\n\n l2 = Ether()\n\n l3 = IP(dst='8.8.8.8/30')\n\n l4 = TCP(dport=53, flags = 'S')\n\n packet = l2/l3/l4\n\n\n\n\n\n\nScapy IP notations\n\n\nScapy accepts plain dotted-quad IP notation, CIDR notation, hostnames.\n\n\n packet = IP(dst = '8.8.8.8')\n\n \n\n packet = IP(dst = 'scanme.nmap.org')\n\n \n\n packet = IP(dst = '8.8.8.8/30')\n\n# Above line created 4 packets in one statements implicitly.\n# Using list comprehensions to view all the packets.\n\n [a for a in packet]\n[\nIP  dst=8.8.8.8 |\n, \nIP  dst=8.8.8.9 |\n, \nIP  dst=8.8.8.10 |\n, \nIP  dst=8.8.8.11 |\n]\n\n\n packet = IP(dst = 'egadz.metasploit.com/30')", 
            "title": "Creating packets"
        }, 
        {
            "location": "/scapy/creating_packets/index.html#creating-packets-with-scapy", 
            "text": "", 
            "title": "Creating packets with Scapy"
        }, 
        {
            "location": "/scapy/creating_packets/index.html#creating-a-packet", 
            "text": "Scapy packet creation is consistent with layered approach in networking.  The basic building block of a packet is a layer, and a whole packet is built by stack- ing layers on top of one another.  In scapy, packets are constructed by defining packet headers for each protocol at different layers of TCP/IP and then stacking these layers in order.  To create a DNS query, you need to build Ether(sometimes optional), IP,UDP headers and stack them using  /  operator.   Creating packet in one line   packet = Ether()/IP(dst='8.8.8.8')/TCP(dport=53,flags='S')   A full-fledged DNS request packet    dns_query = Ether()/IP(dst='8.8.8.8')/UDP(dport=53)/DNS(opcode='QUERY')/DNSQR(qname='null.co.in', qtype = 'A')    dns_query Ether  type=0x800 | IP  frag=0 proto=udp dst=8.8.8.8 | UDP  sport=domain dport=domain | DNS  opcode=QUERY | DNSQR  qname='null.co.in' qtype=A |   Create each layer individually and stack them using  /  operator   l2 = Ether()  l3 = IP(dst='8.8.8.8/30')  l4 = TCP(dport=53, flags = 'S')  packet = l2/l3/l4", 
            "title": "Creating a packet"
        }, 
        {
            "location": "/scapy/creating_packets/index.html#scapy-ip-notations", 
            "text": "Scapy accepts plain dotted-quad IP notation, CIDR notation, hostnames.   packet = IP(dst = '8.8.8.8')    packet = IP(dst = 'scanme.nmap.org')    packet = IP(dst = '8.8.8.8/30')\n\n# Above line created 4 packets in one statements implicitly.\n# Using list comprehensions to view all the packets.  [a for a in packet]\n[ IP  dst=8.8.8.8 | ,  IP  dst=8.8.8.9 | ,  IP  dst=8.8.8.10 | ,  IP  dst=8.8.8.11 | ]  packet = IP(dst = 'egadz.metasploit.com/30')", 
            "title": "Scapy IP notations"
        }, 
        {
            "location": "/scapy/inspecting_packets/index.html", 
            "text": "Inspecting packets\n\n\nGet detailed description of the packet along with datatypes\n\n\n packet = IP()/TCP()\n\n ls(packet)\nversion    : BitField             = 4               (4)\nihl        : BitField             = None            (None)\ntos        : XByteField           = 0               (0)\nlen        : ShortField           = None            (None)\nid         : ShortField           = 1               (1)\nflags      : FlagsField           = 0               (0)\nfrag       : BitField             = 0               (0)\nttl        : ByteField            = 64              (64)\nproto      : ByteEnumField        = 6               (0)\nchksum     : XShortField          = None            (None)\nsrc        : Emph                 = '127.0.0.1'     (None)\ndst        : Emph                 = '127.0.0.1'     ('127.0.0.1')\noptions    : PacketListField      = []              ([])\n[-- snipped --]\n\n\n\n\n\n\n\nDisplay short  \n interesting summary of a packet.\n\n\n packet.summary()\n'Ether / IP / TCP 192.168.1.100:ftp_data \n 8.8.8.8:domain S'\n\n\n\n\n\n\nShow() function displays detailed headers but \ndoes not assemble\n the packet\n\n\n packet.show()\n###[ IP ]###\n  version= 4\n  ihl= None\n  len= None\n  [...]\n  proto= hopopt\n  chksum= None\n  src= 192.168.1.100\n  dst= Net('8.8.8.8/30')\n\n\n\n\n\n\nShow2() is similar to show() but also assembles\nthe packet and calculates the checksums and IHL.\n\n\n packet.show2()\n###[ IP ]###\n  version= 4L\n  ihl= 5L\n  [...]\n  ttl= 64\n  proto= hopopt\n  chksum= 0xa8cd\n  src= 192.168.1.100\n  dst= 8.8.8.8\n\n### ** Get only the values supplied by the user.\n\n\n\n\n\n\nGet only user supplied values\n\n\n b.hide_defaults( )\n\n\n\n\n\n\nInteracting with fields inside packet\n\n\nTo access a specific field: [packet_name].[field]\n\n\n packet.dst\n'd8:55:a3:fe:80:78'\n\n\n\n\n\n\nFor fields that are not unique [packet_name][proto].[field]\n\n\n packet[Ether].dst\n'd8:55:a3:fe:80:78'\n\n packet[IP].dst\n'8.8.8.8'\n\n\n\n\n\n\n.payload\n ignores the lowest layer and parses the next layer.\n\n\n packet.payload.flags\n0\n\n packet.payload.payload.flags\n2\n\n\n\n\n\n\n.haslayer\n checks for presence of a layer in a packet\n\n\n if packet.haslayer(TCP):\n...     print packet[TCP].flags\n... \n2\n\n\n\n\n\n\n\n\nScapy\ns sprintf\n\n\n\n\nsprintf()\n method is one of the very powerful features of Scapy.\nsprintf\n comes very handy while writing custom tools.\n\n\nsprintf\n fills a format string with values from the packet , much like it sprintf from C Library, except here it fills the format string with field values from packets.\n\n\n\n\n packet.sprintf(\nEthernet source is %Ether.src% and IP proto is %IP.proto%\n)\n'Ethernet source is 00:00:00:00:00:00 and IP proto is icmp'\n\n\n\n\n\n a=Ether( )/Dot1Q(vlan=42)/IP(dst=\n192.168.0.1\n)/TCP(flags=\nRA\n)\n\n\n\n a.sprintf(\n%dst% %IP.dst% vlan=%Dot1Q.vlan%\n)\n'00:00:d4:ae:3f:71 192.168.0.1 vlan=42'\n\n\n\na.sprintf(\n %TCP.flags% | %5s,TCP.flags% | %#05xr,TCP.flags%\n)\n' RA | RA    | 0x014'\n\n\n\n\n res.nsummary(lfilter = lambda (s,r): r[TCP].flags \n 2)\n0008 IP / TCP 192.168.5.20:ftp-data \n 192.168.5.22:discard S ==\n\nIP / TCP 192.168.5.22:discard \n 192.168.5.20:ftp-data SA / Padding\n\n\n\n\n res.nsummary(lfilter = lambda (s,r): r[TCP].flags \n 2, prn = lambda (s,r):s.dport)\n0008 9\n0012 13\n0021 22\n0024 25\n\n\n\n\n\n\nPython\u2019s format method\n\n\n\n\nPython string format method generates beautiful output but unlike sprintf it prints literal values.\n\n\n\n\n\n \nEther source is: {} \n IP proto is: {}\n.format(packet.src, packet.proto)\n'Ether source is: 00:00:00:00:00:00 \n IP proto is: 1'", 
            "title": "Inspecting packets"
        }, 
        {
            "location": "/scapy/inspecting_packets/index.html#inspecting-packets", 
            "text": "Get detailed description of the packet along with datatypes   packet = IP()/TCP()  ls(packet)\nversion    : BitField             = 4               (4)\nihl        : BitField             = None            (None)\ntos        : XByteField           = 0               (0)\nlen        : ShortField           = None            (None)\nid         : ShortField           = 1               (1)\nflags      : FlagsField           = 0               (0)\nfrag       : BitField             = 0               (0)\nttl        : ByteField            = 64              (64)\nproto      : ByteEnumField        = 6               (0)\nchksum     : XShortField          = None            (None)\nsrc        : Emph                 = '127.0.0.1'     (None)\ndst        : Emph                 = '127.0.0.1'     ('127.0.0.1')\noptions    : PacketListField      = []              ([])\n[-- snipped --]   Display short    interesting summary of a packet.   packet.summary()\n'Ether / IP / TCP 192.168.1.100:ftp_data   8.8.8.8:domain S'   Show() function displays detailed headers but  does not assemble  the packet   packet.show()\n###[ IP ]###\n  version= 4\n  ihl= None\n  len= None\n  [...]\n  proto= hopopt\n  chksum= None\n  src= 192.168.1.100\n  dst= Net('8.8.8.8/30')   Show2() is similar to show() but also assembles\nthe packet and calculates the checksums and IHL.   packet.show2()\n###[ IP ]###\n  version= 4L\n  ihl= 5L\n  [...]\n  ttl= 64\n  proto= hopopt\n  chksum= 0xa8cd\n  src= 192.168.1.100\n  dst= 8.8.8.8\n\n### ** Get only the values supplied by the user.   Get only user supplied values   b.hide_defaults( )", 
            "title": "Inspecting packets"
        }, 
        {
            "location": "/scapy/inspecting_packets/index.html#interacting-with-fields-inside-packet", 
            "text": "To access a specific field: [packet_name].[field]   packet.dst\n'd8:55:a3:fe:80:78'   For fields that are not unique [packet_name][proto].[field]   packet[Ether].dst\n'd8:55:a3:fe:80:78'  packet[IP].dst\n'8.8.8.8'   .payload  ignores the lowest layer and parses the next layer.   packet.payload.flags\n0  packet.payload.payload.flags\n2   .haslayer  checks for presence of a layer in a packet   if packet.haslayer(TCP):\n...     print packet[TCP].flags\n... \n2", 
            "title": "Interacting with fields inside packet"
        }, 
        {
            "location": "/scapy/inspecting_packets/index.html#scapys-sprintf", 
            "text": "sprintf()  method is one of the very powerful features of Scapy. sprintf  comes very handy while writing custom tools.  sprintf  fills a format string with values from the packet , much like it sprintf from C Library, except here it fills the format string with field values from packets.    packet.sprintf( Ethernet source is %Ether.src% and IP proto is %IP.proto% )\n'Ethernet source is 00:00:00:00:00:00 and IP proto is icmp'   a=Ether( )/Dot1Q(vlan=42)/IP(dst= 192.168.0.1 )/TCP(flags= RA )   a.sprintf( %dst% %IP.dst% vlan=%Dot1Q.vlan% )\n'00:00:d4:ae:3f:71 192.168.0.1 vlan=42'  a.sprintf(  %TCP.flags% | %5s,TCP.flags% | %#05xr,TCP.flags% )\n' RA | RA    | 0x014'   res.nsummary(lfilter = lambda (s,r): r[TCP].flags   2)\n0008 IP / TCP 192.168.5.20:ftp-data   192.168.5.22:discard S == \nIP / TCP 192.168.5.22:discard   192.168.5.20:ftp-data SA / Padding   res.nsummary(lfilter = lambda (s,r): r[TCP].flags   2, prn = lambda (s,r):s.dport)\n0008 9\n0012 13\n0021 22\n0024 25", 
            "title": "Scapy's sprintf"
        }, 
        {
            "location": "/scapy/inspecting_packets/index.html#pythons-format-method", 
            "text": "Python string format method generates beautiful output but unlike sprintf it prints literal values.     Ether source is: {}   IP proto is: {} .format(packet.src, packet.proto)\n'Ether source is: 00:00:00:00:00:00   IP proto is: 1'", 
            "title": "Python\u2019s format method"
        }, 
        {
            "location": "/scapy/sending_recieving/index.html", 
            "text": "Sending \n recieving packets\n\n\n\n\nSend \n recieve funtions are the heart of scapy\ns functionality.\n\n\n\n\n\n\nFine grained options\n\n\nMost scapy funtions like send(), sniff() functions has fine grain options like applying bpf filters, timeout, retry, verbosity etc. Use help(function_name) to find out more options.\n\n\n\n\nsend()\n\n\nSend packets at Layer 3(Scapy creates Layer 2 header), Does not recieve any packets.\n\n\n send(IP(dst=\n1.2.3.4\n)/ICMP())\n.\nSent 1 packets.\n\n\n\n\nsendp()\n\n\nSend packets at Layer 2(Must provide Layer 2 header), Does not recieve any packets.\n\n\n sendp(Ether()/IP(dst=\n1.2.3.4\n,ttl=(1,4)), iface=\neth1\n)\n....\nSent 4 packets.\n\n\n sendp(\nI\u2019m travelling on Ethernet\n, iface=\neth1\n, loop=1, inter=0.2)\n\n\n sendp(rdpcap(\n/tmp/pcapfile\n)) # tcpreplay\n...........\nSent 11 packets.\n\n\n\n\nsr()\n\n\n\n\nSends packets and receiving answers. \n\n\nsr() returns a list of tuples of probe and answer in a packet list, and the unanswered packets.\n\n\n\n\n sr(IP(dst=\n192.168.8.1\n)/TCP(dport=[21,22,23]))\n\nReceived 6 packets, got 3 answers, remaining 0 packets\n(\nResults: UDP:0 TCP:3 ICMP:0 Other:0\n, \nUnanswered: UDP:0\n\n\n ans,unans=_\n\n ans.summary()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nsr1()\n\n\n\n\nSends packets and recieves only the first response . \n\n\nThe function returns a couple of packet and answers, and the unanswered packets.\n\n\n\n\n p=sr1(IP(dst=\nscanme.nmap.org\n)/ICMP()/\nXXXXXXXXXXX\n)\nBegin emission:\n...Finished to send 1 packets.\n.*\nReceived 5 packets, got 1 answers, remaining 0 packets\n\n\n\n\nsrloop()\n\n\n\n\nSends packets, recieves and displays responses, in a loop . \n\n\nThe function returns a couple of packet and answers, and the unanswered\n\n\n\n\n packet = IP(dst='192.168.56.102')/ICMP()\n\n srloop(packet)\nRECV 1: IP / ICMP 192.168.56.102 \n 192.168.56.1 echo-reply 0\nRECV 1: IP / ICMP 192.168.56.102 \n 192.168.56.1 echo-reply 0\nRECV 1: IP / ICMP 192.168.56.102 \n 192.168.56.1 echo-reply 0\n^C        \nSent 3 packets, received 3 packets. 100.0% hits.\n(\nResults: TCP:0 UDP:0 ICMP:3 Other:0\n, \nPacketList: TCP:0 UDP:0 ICMP:0 Other:0\n)\n\n\n\n\n\n\nCorner cases: Curious case of 127.0.0.1\n\n\nThe loopback interface is a very special. Packets going through it are not really assembled and dissassembled.\n\n\nThe kernel routes the packet to its destination while it is still stored an internal structure. The kernel is not aware of what Scapy is doing behind his back, so what you see on the lo interface is also a fake. Except this one did not come from a local structure. Thus the kernel will never receive it.\n\n\nTo speak to local applications, you need to build your packets one layer upper, using a PF_INET/SOCK_RAW socket instead of a PF_PACKET/SOCK_RAW (or its equivalent on other systems that Linux).", 
            "title": "Sending & Recieving"
        }, 
        {
            "location": "/scapy/sending_recieving/index.html#sending-recieving-packets", 
            "text": "Send   recieve funtions are the heart of scapy s functionality.    Fine grained options  Most scapy funtions like send(), sniff() functions has fine grain options like applying bpf filters, timeout, retry, verbosity etc. Use help(function_name) to find out more options.", 
            "title": "Sending &amp; recieving packets"
        }, 
        {
            "location": "/scapy/sending_recieving/index.html#send", 
            "text": "Send packets at Layer 3(Scapy creates Layer 2 header), Does not recieve any packets.   send(IP(dst= 1.2.3.4 )/ICMP())\n.\nSent 1 packets.", 
            "title": "send()"
        }, 
        {
            "location": "/scapy/sending_recieving/index.html#sendp", 
            "text": "Send packets at Layer 2(Must provide Layer 2 header), Does not recieve any packets.   sendp(Ether()/IP(dst= 1.2.3.4 ,ttl=(1,4)), iface= eth1 )\n....\nSent 4 packets.  sendp( I\u2019m travelling on Ethernet , iface= eth1 , loop=1, inter=0.2)  sendp(rdpcap( /tmp/pcapfile )) # tcpreplay\n...........\nSent 11 packets.", 
            "title": "sendp()"
        }, 
        {
            "location": "/scapy/sending_recieving/index.html#sr", 
            "text": "Sends packets and receiving answers.   sr() returns a list of tuples of probe and answer in a packet list, and the unanswered packets.    sr(IP(dst= 192.168.8.1 )/TCP(dport=[21,22,23]))\n\nReceived 6 packets, got 3 answers, remaining 0 packets\n( Results: UDP:0 TCP:3 ICMP:0 Other:0 ,  Unanswered: UDP:0  ans,unans=_  ans.summary()", 
            "title": "sr()"
        }, 
        {
            "location": "/scapy/sending_recieving/index.html#sr1", 
            "text": "Sends packets and recieves only the first response .   The function returns a couple of packet and answers, and the unanswered packets.    p=sr1(IP(dst= scanme.nmap.org )/ICMP()/ XXXXXXXXXXX )\nBegin emission:\n...Finished to send 1 packets.\n.*\nReceived 5 packets, got 1 answers, remaining 0 packets", 
            "title": "sr1()"
        }, 
        {
            "location": "/scapy/sending_recieving/index.html#srloop", 
            "text": "Sends packets, recieves and displays responses, in a loop .   The function returns a couple of packet and answers, and the unanswered    packet = IP(dst='192.168.56.102')/ICMP()  srloop(packet)\nRECV 1: IP / ICMP 192.168.56.102   192.168.56.1 echo-reply 0\nRECV 1: IP / ICMP 192.168.56.102   192.168.56.1 echo-reply 0\nRECV 1: IP / ICMP 192.168.56.102   192.168.56.1 echo-reply 0\n^C        \nSent 3 packets, received 3 packets. 100.0% hits.\n( Results: TCP:0 UDP:0 ICMP:3 Other:0 ,  PacketList: TCP:0 UDP:0 ICMP:0 Other:0 )   Corner cases: Curious case of 127.0.0.1  The loopback interface is a very special. Packets going through it are not really assembled and dissassembled.  The kernel routes the packet to its destination while it is still stored an internal structure. The kernel is not aware of what Scapy is doing behind his back, so what you see on the lo interface is also a fake. Except this one did not come from a local structure. Thus the kernel will never receive it.  To speak to local applications, you need to build your packets one layer upper, using a PF_INET/SOCK_RAW socket instead of a PF_PACKET/SOCK_RAW (or its equivalent on other systems that Linux).", 
            "title": "srloop()"
        }, 
        {
            "location": "/scapy/import_export/index.html", 
            "text": "Importing \n exporting data\n\n\nPCAP format\n\n\n\n\nImport packets from PCAP file.\n\n\n\n\n pkts = rdpcap(\ntemp.cap\n)\n\n\n\n\n pkts = sniff(offline=\ntemp.cap\n)\n\n\n\n\n\n\n\nExport packets to pcap file.\n\n\n\n\n wrpcap(\ntemp.cap\n,pkts)\n\n\n\n\nhexdump format\n\n\n\n\nScapy allows you to export recorded packets in various hex formats.\n\n\nUse hexdump() function to display one or more packets using classic hexdump format:\n\n\n\n\n hexdump(pkt)\n0000   00 50 56 FC CE 50 00 0C  29 2B 53 19 08 00 45 00   .PV..P..)+S...E.\n0010   00 54 00 00 40 00 40 01  5A 7C C0 A8 19 82 04 02   .T..@.@.Z|......\n0020   02 01 08 00 9C 90 5A 61  00 01 E6 DA 70 49 B6 E5   ......Za....pI..\n0030   08 00 08 09 0A 0B 0C 0D  0E 0F 10 11 12 13 14 15   ................\n0040   16 17 18 19 1A 1B 1C 1D  1E 1F 20 21 22 23 24 25   .......... !\n#$%\n0050   26 27 28 29 2A 2B 2C 2D  2E 2F 30 31 32 33 34 35   \n'()*+,-./012345\n0060   36 37                                              67\n\n\n\n\n\n\nHexdump above can be reimported back into Scapy using import_hexcap() function:\n\n\n\n\n pkt_hex = Ether(import_hexcap())\n0000   00 50 56 FC CE 50 00 0C  29 2B 53 19 08 00 45 00   .PV..P..)+S...E.\n0010   00 54 00 00 40 00 40 01  5A 7C C0 A8 19 82 04 02   .T..@.@.Z|......\n0020   02 01 08 00 9C 90 5A 61  00 01 E6 DA 70 49 B6 E5   ......Za....pI..\n0030   08 00 08 09 0A 0B 0C 0D  0E 0F 10 11 12 13 14 15   ................\n0040   16 17 18 19 1A 1B 1C 1D  1E 1F 20 21 22 23 24 25   .......... !\n#$%\n0050   26 27 28 29 2A 2B 2C 2D  2E 2F 30 31 32 33 34 35   \n'()*+,-./012345\n0060   36 37                                              67\n\n pkt_hex\n\nEther  dst=00:50:56:fc:ce:50 src=00:0c:29:2b:53:19 type=0x800 |\nIP  version=4L \nihl=5L tos=0x0 len=84 id=0 flags=DF frag=0L ttl=64 proto=icmp chksum=0x5a7c \nsrc=192.168.25.130 dst=4.2.2.1 options='' |\nICMP  type=echo-request code=0 \nchksum=0x9c90 id=0x5a61 seq=0x1 |\nRaw  load='\\xe6\\xdapI\\xb6\\xe5\\x08\\x00\\x08\\t\\n\n\\x0b\\x0c\\r\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\n\\x1f !\n#$%\n\\'()*+,-./01234567' |\n\n\n\n\n\nhex string\n\n\n\n\nYou can also convert entire packet into a hex string using /str() function:\n\n\n\n\n pkt\n\nEther  dst=00:50:56:fc:ce:50 src=00:0c:29:2b:53:19 type=0x800 |\nIP  version=4L \nihl=5L tos=0x0 len=84 id=0 flags=DF frag=0L ttl=64 proto=icmp chksum=0x5a7c \nsrc=192.168.25.130 dst=4.2.2.1 options='' |\nICMP  type=echo-request code=0 \nchksum=0x9c90 id=0x5a61 seq=0x1 |\nRaw  load='\\xe6\\xdapI\\xb6\\xe5\\x08\\x00\\x08\\t\\n\n\\x0b\\x0c\\r\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\n\\x1f !\n#$%\n\\'()*+,-./01234567' |\n\n\n pkt_str = str(pkt)\n\n pkt_str\n'\\x00PV\\xfc\\xceP\\x00\\x0c)+S\\x19\\x08\\x00E\\x00\\x00T\\x00\\x00@\\x00@\\x01Z|\\xc0\\xa8\n\\x19\\x82\\x04\\x02\\x02\\x01\\x08\\x00\\x9c\\x90Za\\x00\\x01\\xe6\\xdapI\\xb6\\xe5\\x08\\x00\n\\x08\\t\\n\\x0b\\x0c\\r\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\n\\x1c\\x1d\\x1e\\x1f !\n#$%\n\\'()*+,-./01234567'\n\n\n\n\nBase64\n\n\n\n\nScapy can export base64 encoded python data structure representing a packet using export_object() function.\n\n\n\n\n pkt\n\nEther  dst=00:50:56:fc:ce:50 src=00:0c:29:2b:53:19 type=0x800 |\nIP  version=4L \nihl=5L tos=0x0 len=84 id=0 flags=DF frag=0L ttl=64 proto=icmp chksum=0x5a7c \nsrc=192.168.25.130 dst=4.2.2.1 options='' |\nICMP  type=echo-request code=0 \nchksum=0x9c90 id=0x5a61 seq=0x1 |\nRaw  load='\\xe6\\xdapI\\xb6\\xe5\\x08\\x00\\x08\\t\\n\n\\x0b\\x0c\\r\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f \n!\n#$%\n\\'()*+,-./01234567' |\n\n\n export_object(pkt)\neNplVwd4FNcRPt2dTqdTQ0JUUYwN+CgS0gkJONFEs5WxFDB+CdiI8+pupVl0d7uzRUiYtcEGG4ST\nOD1OnB6nN6c4cXrvwQmk2U5xA9tgO70XMm+1rA78qdzbfTP/lDfzz7tD4WwmU1C0YiaT2Gqjaiao\nbMlhCrsUSYrYoKbmcxZFXSpPiohlZikm6ltb063ZdGpNOjWQ7mhPt62hChHJWTbFvb0O/u1MD2bT\nWZXXVCmi9pihUqI3FHdEQslriiVfWFTVT9VYpog6Q7fsjG0qRWtQNwsW1fRTrUg4xZxq5pUx1aS6\n\n\n\n\n\n\nOutput above can be reimported back into Skype using import_object() function:\n\n\n\n\n new_pkt = import_object()\neNplVwd4FNcRPt2dTqdTQ0JUUYwN+CgS0gkJONFEs5WxFDB+CdiI8+pupVl0d7uzRUiYtcEGG4ST\nOD1OnB6nN6c4cXrvwQmk2U5xA9tgO70XMm+1rA78qdzbfTP/lDfzz7tD4WwmU1C0YiaT2Gqjaiao\nbMlhCrsUSYrYoKbmcxZFXSpPiohlZikm6ltb063ZdGpNOjWQ7mhPt62hChHJWTbFvb0O/u1MD2bT\nWZXXVCmi9pihUqI3FHdEQslriiVfWFTVT9VYpog6Q7fsjG0qRWtQNwsW1fRTrUg4xZxq5pUx1aS6\n...\n\n new_pkt\n\nEther  dst=00:50:56:fc:ce:50 src=00:0c:29:2b:53:19 type=0x800 |\nIP  version=4L \nihl=5L tos=0x0 len=84 id=0 flags=DF frag=0L ttl=64 proto=icmp chksum=0x5a7c \nsrc=192.168.25.130 dst=4.2.2.1 options='' |\nICMP  type=echo-request code=0 \nchksum=0x9c90 id=0x5a61 seq=0x1 |\nRaw  load='\\xe6\\xdapI\\xb6\\xe5\\x08\\x00\\x08\\t\\n\n\\x0b\\x0c\\r\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f \n!\n#$%\n\\'()*+,-./01234567' |", 
            "title": "Import & Export data"
        }, 
        {
            "location": "/scapy/import_export/index.html#importing-exporting-data", 
            "text": "", 
            "title": "Importing &amp; exporting data"
        }, 
        {
            "location": "/scapy/import_export/index.html#pcap-format", 
            "text": "Import packets from PCAP file.    pkts = rdpcap( temp.cap )   pkts = sniff(offline= temp.cap )   Export packets to pcap file.    wrpcap( temp.cap ,pkts)", 
            "title": "PCAP format"
        }, 
        {
            "location": "/scapy/import_export/index.html#hexdump-format", 
            "text": "Scapy allows you to export recorded packets in various hex formats.  Use hexdump() function to display one or more packets using classic hexdump format:    hexdump(pkt)\n0000   00 50 56 FC CE 50 00 0C  29 2B 53 19 08 00 45 00   .PV..P..)+S...E.\n0010   00 54 00 00 40 00 40 01  5A 7C C0 A8 19 82 04 02   .T..@.@.Z|......\n0020   02 01 08 00 9C 90 5A 61  00 01 E6 DA 70 49 B6 E5   ......Za....pI..\n0030   08 00 08 09 0A 0B 0C 0D  0E 0F 10 11 12 13 14 15   ................\n0040   16 17 18 19 1A 1B 1C 1D  1E 1F 20 21 22 23 24 25   .......... ! #$%\n0050   26 27 28 29 2A 2B 2C 2D  2E 2F 30 31 32 33 34 35    '()*+,-./012345\n0060   36 37                                              67   Hexdump above can be reimported back into Scapy using import_hexcap() function:    pkt_hex = Ether(import_hexcap())\n0000   00 50 56 FC CE 50 00 0C  29 2B 53 19 08 00 45 00   .PV..P..)+S...E.\n0010   00 54 00 00 40 00 40 01  5A 7C C0 A8 19 82 04 02   .T..@.@.Z|......\n0020   02 01 08 00 9C 90 5A 61  00 01 E6 DA 70 49 B6 E5   ......Za....pI..\n0030   08 00 08 09 0A 0B 0C 0D  0E 0F 10 11 12 13 14 15   ................\n0040   16 17 18 19 1A 1B 1C 1D  1E 1F 20 21 22 23 24 25   .......... ! #$%\n0050   26 27 28 29 2A 2B 2C 2D  2E 2F 30 31 32 33 34 35    '()*+,-./012345\n0060   36 37                                              67  pkt_hex Ether  dst=00:50:56:fc:ce:50 src=00:0c:29:2b:53:19 type=0x800 | IP  version=4L \nihl=5L tos=0x0 len=84 id=0 flags=DF frag=0L ttl=64 proto=icmp chksum=0x5a7c \nsrc=192.168.25.130 dst=4.2.2.1 options='' | ICMP  type=echo-request code=0 \nchksum=0x9c90 id=0x5a61 seq=0x1 | Raw  load='\\xe6\\xdapI\\xb6\\xe5\\x08\\x00\\x08\\t\\n\n\\x0b\\x0c\\r\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\n\\x1f ! #$% \\'()*+,-./01234567' |", 
            "title": "hexdump format"
        }, 
        {
            "location": "/scapy/import_export/index.html#hex-string", 
            "text": "You can also convert entire packet into a hex string using /str() function:    pkt Ether  dst=00:50:56:fc:ce:50 src=00:0c:29:2b:53:19 type=0x800 | IP  version=4L \nihl=5L tos=0x0 len=84 id=0 flags=DF frag=0L ttl=64 proto=icmp chksum=0x5a7c \nsrc=192.168.25.130 dst=4.2.2.1 options='' | ICMP  type=echo-request code=0 \nchksum=0x9c90 id=0x5a61 seq=0x1 | Raw  load='\\xe6\\xdapI\\xb6\\xe5\\x08\\x00\\x08\\t\\n\n\\x0b\\x0c\\r\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\n\\x1f ! #$% \\'()*+,-./01234567' |   pkt_str = str(pkt)  pkt_str\n'\\x00PV\\xfc\\xceP\\x00\\x0c)+S\\x19\\x08\\x00E\\x00\\x00T\\x00\\x00@\\x00@\\x01Z|\\xc0\\xa8\n\\x19\\x82\\x04\\x02\\x02\\x01\\x08\\x00\\x9c\\x90Za\\x00\\x01\\xe6\\xdapI\\xb6\\xe5\\x08\\x00\n\\x08\\t\\n\\x0b\\x0c\\r\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\n\\x1c\\x1d\\x1e\\x1f ! #$% \\'()*+,-./01234567'", 
            "title": "hex string"
        }, 
        {
            "location": "/scapy/import_export/index.html#base64", 
            "text": "Scapy can export base64 encoded python data structure representing a packet using export_object() function.    pkt Ether  dst=00:50:56:fc:ce:50 src=00:0c:29:2b:53:19 type=0x800 | IP  version=4L \nihl=5L tos=0x0 len=84 id=0 flags=DF frag=0L ttl=64 proto=icmp chksum=0x5a7c \nsrc=192.168.25.130 dst=4.2.2.1 options='' | ICMP  type=echo-request code=0 \nchksum=0x9c90 id=0x5a61 seq=0x1 | Raw  load='\\xe6\\xdapI\\xb6\\xe5\\x08\\x00\\x08\\t\\n\n\\x0b\\x0c\\r\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f \n! #$% \\'()*+,-./01234567' |   export_object(pkt)\neNplVwd4FNcRPt2dTqdTQ0JUUYwN+CgS0gkJONFEs5WxFDB+CdiI8+pupVl0d7uzRUiYtcEGG4ST\nOD1OnB6nN6c4cXrvwQmk2U5xA9tgO70XMm+1rA78qdzbfTP/lDfzz7tD4WwmU1C0YiaT2Gqjaiao\nbMlhCrsUSYrYoKbmcxZFXSpPiohlZikm6ltb063ZdGpNOjWQ7mhPt62hChHJWTbFvb0O/u1MD2bT\nWZXXVCmi9pihUqI3FHdEQslriiVfWFTVT9VYpog6Q7fsjG0qRWtQNwsW1fRTrUg4xZxq5pUx1aS6   Output above can be reimported back into Skype using import_object() function:    new_pkt = import_object()\neNplVwd4FNcRPt2dTqdTQ0JUUYwN+CgS0gkJONFEs5WxFDB+CdiI8+pupVl0d7uzRUiYtcEGG4ST\nOD1OnB6nN6c4cXrvwQmk2U5xA9tgO70XMm+1rA78qdzbfTP/lDfzz7tD4WwmU1C0YiaT2Gqjaiao\nbMlhCrsUSYrYoKbmcxZFXSpPiohlZikm6ltb063ZdGpNOjWQ7mhPt62hChHJWTbFvb0O/u1MD2bT\nWZXXVCmi9pihUqI3FHdEQslriiVfWFTVT9VYpog6Q7fsjG0qRWtQNwsW1fRTrUg4xZxq5pUx1aS6\n...  new_pkt Ether  dst=00:50:56:fc:ce:50 src=00:0c:29:2b:53:19 type=0x800 | IP  version=4L \nihl=5L tos=0x0 len=84 id=0 flags=DF frag=0L ttl=64 proto=icmp chksum=0x5a7c \nsrc=192.168.25.130 dst=4.2.2.1 options='' | ICMP  type=echo-request code=0 \nchksum=0x9c90 id=0x5a61 seq=0x1 | Raw  load='\\xe6\\xdapI\\xb6\\xe5\\x08\\x00\\x08\\t\\n\n\\x0b\\x0c\\r\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f \n! #$% \\'()*+,-./01234567' |", 
            "title": "Base64"
        }, 
        {
            "location": "/scapy/sniffing/index.html", 
            "text": "Sniffing\n\n\nSniff()\n\n\n\n\nScapy\ns in-built \nsniff()\n function helps us capture all traffic:\n\n\nsniff()\n hasCount, filters, iface, timeout options. \n\n\nCan apply BPF filters .(Same as TCPDUMP).\n\n\n\n\n sniff(count=4, iface='eth3')\n\nSniffed: TCP:0 UDP:0 ICMP:0 Other:4\n\n\n\n\n\n\n\nSniffing with Scapy\nScapy sniffer is not designed to be super fast so it can miss packets   sometimes.\nAlways use use tcpdump when you can, which is more simpler and efficient.\n\n\n\n\n\n\n\n\nWe can add filtering to capture only packets that are interesting to us. Use standard tcpdump/libpcap syntax:\n\n\n\n\n pkts = sniff(count=1,filter=\ntcp and host 64.233.167.99 and port 80\n)\n\n\n\n\n sniff(filter='arp', count=5, iface='vboxnet0')\n\nSniffed: TCP:0 UDP:0 ICMP:0 Other:5\n\n\n\n\n _.summary()\nEther / ARP who has 192.168.56.101 says 192.168.56.1\nEther / ARP who has 192.168.56.101 says 192.168.56.1\nEther / ARP who has 192.168.56.101 says 192.168.56.1\nEther / ARP who has 192.168.56.101 says 192.168.56.1\nEther / ARP who has 192.168.56.101 says 192.168.56.1\n\n\n\n\n\n\nSimple traffic analyzer like tcpdump.\n\n\n\n\n pkts = sniff(count=5,filter=\nhost 64.233.167.99\n,prn=lambda x:x.summary())\nEther / IP / TCP 192.168.1.100:33168 \n 64.233.167.99:www S\nEther / IP / TCP 64.233.167.99:www \n 192.168.1.100:33168 SA\nEther / IP / TCP 192.168.1.100:33168 \n 64.233.167.99:www A\nEther / IP / TCP 192.168.1.100:33168 \n 64.233.167.99:www PA / Raw\nEther / IP / TCP 64.233.167.99:www \n 192.168.1.100:33168 A\n\n\n\n\n\n TBD", 
            "title": "Sniffing"
        }, 
        {
            "location": "/scapy/sniffing/index.html#sniffing", 
            "text": "", 
            "title": "Sniffing"
        }, 
        {
            "location": "/scapy/sniffing/index.html#sniff", 
            "text": "Scapy s in-built  sniff()  function helps us capture all traffic:  sniff()  hasCount, filters, iface, timeout options.   Can apply BPF filters .(Same as TCPDUMP).    sniff(count=4, iface='eth3') Sniffed: TCP:0 UDP:0 ICMP:0 Other:4    Sniffing with Scapy Scapy sniffer is not designed to be super fast so it can miss packets   sometimes.\nAlways use use tcpdump when you can, which is more simpler and efficient.     We can add filtering to capture only packets that are interesting to us. Use standard tcpdump/libpcap syntax:    pkts = sniff(count=1,filter= tcp and host 64.233.167.99 and port 80 )   sniff(filter='arp', count=5, iface='vboxnet0') Sniffed: TCP:0 UDP:0 ICMP:0 Other:5    _.summary()\nEther / ARP who has 192.168.56.101 says 192.168.56.1\nEther / ARP who has 192.168.56.101 says 192.168.56.1\nEther / ARP who has 192.168.56.101 says 192.168.56.1\nEther / ARP who has 192.168.56.101 says 192.168.56.1\nEther / ARP who has 192.168.56.101 says 192.168.56.1   Simple traffic analyzer like tcpdump.    pkts = sniff(count=5,filter= host 64.233.167.99 ,prn=lambda x:x.summary())\nEther / IP / TCP 192.168.1.100:33168   64.233.167.99:www S\nEther / IP / TCP 64.233.167.99:www   192.168.1.100:33168 SA\nEther / IP / TCP 192.168.1.100:33168   64.233.167.99:www A\nEther / IP / TCP 192.168.1.100:33168   64.233.167.99:www PA / Raw\nEther / IP / TCP 64.233.167.99:www   192.168.1.100:33168 A   TBD", 
            "title": "Sniff()"
        }, 
        {
            "location": "/network_recon/host_discovery/index.html", 
            "text": "Two steps to basic network reconnaissance.\n\n- Host Discovery.\n\n- Service Discovery(Port Scanning).\n\n\nHost Discovery\n\n\n\n\nFirst step to network recon. Goal is to \nreduce a large set of IP ranges into a list of active or interesting hosts.\n(A 10.0.0.0/8 network can accomdate 16777200 hosts).\n\n\nPort scanning is loud and also expensive on time and resources. More targets; More chances of being caught by an IDS.\n\n\nStrict narrowing down might miss interesting targets, Too lenient narrowing down can result in large set of machines to scan.. Strike a balance based on the requirements.\n\n\n\n\nTCP SYN Ping\n\n\n\n\nSend an empty TCP packet with only SYN bit set.\n\n\nSYN/ACK or RST in response indicates that a machine is up and running.\n\n\n\n\n ans,unans=sr( IP(dst=\n192.168.1.*\n)/TCP(dport=80,flags=\nS\n) )\n\n ans.summary( lambda(s,r) : r.sprintf(\n%IP.src% is alive\n) )\n192.168.56.101 is alive!\n\n\n\n\nTCP ACK Ping\n\n\n\n\nSend an empty TCP packet with only ACK bit set.\n\n\nUnsolicited ACK packets should be responded with RST which reveals a machine.\n\n\nSYN ping and ACK ping might seem redundant but most of the stateless firewalls won\nt filter unsolicited ACK packets so it\ns a better approach to use both ping tecnhiques.\n\n\n\n\n ans, unans = sr(IP(dst='192.168.56.99-105')/TCP(dport=80, flags='A'))\nBegin emission:\nFinished to send 7 packets.\n......................^C\nReceived 25 packets, got 1 answers, remaining 6 packets\n\n \n\n ans.summary(lambda(s,r): r.sprintf('{IP: %IP.src% is alive}'))\n 192.168.56.101 is alive\n\n \n\n\n\n\n\nUDP Ping\n\n\n\n\nSend UDP packet to the given ports with or without payload, though protocol specific payload makes the scan more effective.\n\n\nChoose a port that\ns most likely closed(Open UDP ports might recieve empty packets but ignore them).\n\n\nICMP port unreachable signifies that the machine is up.\n\n\n\n\nIP Protocol ping\n\n\n\n\nSend multiple packets with different protocol numbers set in their IP header, append proper protocol headers.\n\n\nLook for either responses using the same protocol as a probe, or ICMP protocol unreachable, either of the responses will signify a machine is alive.\n\n\n\n\nARP Ping\n\n\n\n\nARP Ping is employed when discovering active hosts on the same network/LAN.\n\n\nFaster and reliable because it operates on Layer 2 by using only ARP.\n\n\nARP is the backbone protocol for any Layer 2 communication so always employ ARP ping when discovering hosts on local network.\n\n\n\n\nARP doesn\nt exist in IPv6 standard. For the equivalent, use Neighbor Discovery Protocol techniques instead.\n\n\n\n\n\n\n\n\n\n\n ans,unans=srp(Ether(dst=\nff:ff:ff:ff:ff:ff\n)/ARP(pdst=\n192.168.56.0/24\n),timeout=2)\nBegin emission:\n**Finished to send 256 packets.\n\nReceived 2 packets, got 2 answers, remaining 254 packets\n\n \n\n ans.summary(lambda (s,r): r.sprintf(\n%Ether.src% %ARP.psrc%\n) )\n08:00:27:7b:2a:a9 192.168.56.100\n08:00:27:37:86:85 192.168.56.101\n\n \n\n\n\n\nICMP Ping\n\n\n\n\nICMP scan involves the standard packets sent by the ubiquitous \nping program\n .\n\n\nSend an \nICMP type 8 (echo request)\n packet to the target IP, a \nICMP type 0 (echo reply) \nindicates that the target is alive.\n\n\nUnfortunately, \nmany hosts and firewalls now block these packets\n so a basic ICMP scan is unreliable.\n\n\nICMP also supports\n timestamp request(13), and address mask request(17)\n which can reveal the availabilty of a machine.\n\n\n\n\n ans,unans=sr(IP(dst=\n192.168.56.99-110\n)/ICMP())\nBegin emission:\nFinished to send 12 packets.\nReceived 170 packets, got 1 answers, remaining 11 packets\n\n \n\n ans.summary( lambda(s,r) : r.sprintf(\n{IP: %IP.src% is alive}\n) )\n192.168.56.101 is alive", 
            "title": "Host discovery"
        }, 
        {
            "location": "/network_recon/host_discovery/index.html#host-discovery", 
            "text": "First step to network recon. Goal is to  reduce a large set of IP ranges into a list of active or interesting hosts. (A 10.0.0.0/8 network can accomdate 16777200 hosts).  Port scanning is loud and also expensive on time and resources. More targets; More chances of being caught by an IDS.  Strict narrowing down might miss interesting targets, Too lenient narrowing down can result in large set of machines to scan.. Strike a balance based on the requirements.", 
            "title": "Host Discovery"
        }, 
        {
            "location": "/network_recon/host_discovery/index.html#tcp-syn-ping", 
            "text": "Send an empty TCP packet with only SYN bit set.  SYN/ACK or RST in response indicates that a machine is up and running.    ans,unans=sr( IP(dst= 192.168.1.* )/TCP(dport=80,flags= S ) )  ans.summary( lambda(s,r) : r.sprintf( %IP.src% is alive ) )\n192.168.56.101 is alive!", 
            "title": "TCP SYN Ping"
        }, 
        {
            "location": "/network_recon/host_discovery/index.html#tcp-ack-ping", 
            "text": "Send an empty TCP packet with only ACK bit set.  Unsolicited ACK packets should be responded with RST which reveals a machine.  SYN ping and ACK ping might seem redundant but most of the stateless firewalls won t filter unsolicited ACK packets so it s a better approach to use both ping tecnhiques.    ans, unans = sr(IP(dst='192.168.56.99-105')/TCP(dport=80, flags='A'))\nBegin emission:\nFinished to send 7 packets.\n......................^C\nReceived 25 packets, got 1 answers, remaining 6 packets    ans.summary(lambda(s,r): r.sprintf('{IP: %IP.src% is alive}'))\n 192.168.56.101 is alive", 
            "title": "TCP ACK Ping"
        }, 
        {
            "location": "/network_recon/host_discovery/index.html#udp-ping", 
            "text": "Send UDP packet to the given ports with or without payload, though protocol specific payload makes the scan more effective.  Choose a port that s most likely closed(Open UDP ports might recieve empty packets but ignore them).  ICMP port unreachable signifies that the machine is up.", 
            "title": "UDP Ping"
        }, 
        {
            "location": "/network_recon/host_discovery/index.html#ip-protocol-ping", 
            "text": "Send multiple packets with different protocol numbers set in their IP header, append proper protocol headers.  Look for either responses using the same protocol as a probe, or ICMP protocol unreachable, either of the responses will signify a machine is alive.", 
            "title": "IP Protocol ping"
        }, 
        {
            "location": "/network_recon/host_discovery/index.html#arp-ping", 
            "text": "ARP Ping is employed when discovering active hosts on the same network/LAN.  Faster and reliable because it operates on Layer 2 by using only ARP.  ARP is the backbone protocol for any Layer 2 communication so always employ ARP ping when discovering hosts on local network.   ARP doesn t exist in IPv6 standard. For the equivalent, use Neighbor Discovery Protocol techniques instead.       ans,unans=srp(Ether(dst= ff:ff:ff:ff:ff:ff )/ARP(pdst= 192.168.56.0/24 ),timeout=2)\nBegin emission:\n**Finished to send 256 packets.\n\nReceived 2 packets, got 2 answers, remaining 254 packets    ans.summary(lambda (s,r): r.sprintf( %Ether.src% %ARP.psrc% ) )\n08:00:27:7b:2a:a9 192.168.56.100\n08:00:27:37:86:85 192.168.56.101", 
            "title": "ARP Ping"
        }, 
        {
            "location": "/network_recon/host_discovery/index.html#icmp-ping", 
            "text": "ICMP scan involves the standard packets sent by the ubiquitous  ping program  .  Send an  ICMP type 8 (echo request)  packet to the target IP, a  ICMP type 0 (echo reply)  indicates that the target is alive.  Unfortunately,  many hosts and firewalls now block these packets  so a basic ICMP scan is unreliable.  ICMP also supports  timestamp request(13), and address mask request(17)  which can reveal the availabilty of a machine.    ans,unans=sr(IP(dst= 192.168.56.99-110 )/ICMP())\nBegin emission:\nFinished to send 12 packets.\nReceived 170 packets, got 1 answers, remaining 11 packets    ans.summary( lambda(s,r) : r.sprintf( {IP: %IP.src% is alive} ) )\n192.168.56.101 is alive", 
            "title": "ICMP Ping"
        }, 
        {
            "location": "/network_recon/service_discovery/index.html", 
            "text": "Service discovery(Port Scanning)\n\n\nTCP Three way handshake\n\n\n\n\n\n\n\n\n\nThree-way handshake captured using tcpdump\n\n\n192.168.56.1.35555 \n 192.168.56.102.4444: Flags [S] seq=12345   \n192.168.56.102.4444 \n 192.168.56.1.35555: Flags [S.],  seq=9998 ack=12346\n192.168.56.1.35555 \n 192.168.56.102.4444: Flags [.] seq=12346 ack=9999  \n\n\n\n\nA note on tcpdump output:\n\n\n\n\nA port number is appended to the IP address with an additional dot. \n192.168.56.1.35555\n is IP \n192.168.56.1\n port \n35555\n.\n\n\nAn ACK bit is represented by a \n.\n so \n[S.]\n is \nSYN-ACK\n, \n[.]\n is \nACK\n.\n\n\n\n\n\n\nCrafting the Three-way Handshake in Scapy\n\n\n\n\nTo craft three-way handshake we need to be able to record the response of the server and craft our responses based on server response.\n\n\n\n\nStep I - Send the client\u2019s SYN to a listening server (SYN)\n\n\n\n\nCraft an IP header with the source and destination IP addresses.\n\n\nCraft a TCP header where we generate the TCP source port, assign the destination port that the server listens on, set the TCP flags to turn the \nSYN bit on, and generate the client\u2019s ISN.\n\n\n\n\nip = IP(src='192.168.56.1', dst='192.168.56.101')\nsyn = TCP(sport=4000, dport=80, flags='S', seq='12345')\nsyn_pkt = ip/syn\n\n\n\n\nStep II - Listen for the server\ns response (SYN - ACK)\n\n\n\n\nSave the server\u2019s response. (ideally the response should be syn-ack).\n\n\nExtract the server\u2019s TCP sequence number and increment the value by one.\n\n\n\n\n syn_ack = sr1(packet)\n\n my_ack = syn_ack.seq+1\n\n\n\n\nSend an acknowledgement from client for server\ns response (ACK)\n\n\n\n\nIP header has the same source and destination as the intial SYN packet.\n\n\nTCP header has the same TCP source and destination ports as syn packet, only ACK bit is set, increment the client\u2019s ISN by one since the SYN packet consumes one sequence number, set the acknowledgement value to the incremented server\u2019s sequence number value.\n\n\n\n\nack = TCP(sport=4000, dport=80, flags='A', seq='12346', ack=my_ack)\nack_pkt = ip/ack\nsend(ack_pkt)\n\n\n\n\nIf everything went right, we have just sucessfully established TCP three-way handshake\n\n\n\n\nWhy RST??\n\n\n\n\nIf you have noticed whenever we recieve a packet, our machine automatically responds with an RST packet.\n\n\nThe kernel is not aware of what Scapy is doing behind it\ns back(Scapy is userland program). If Scapy sends a SYN, the target replies with a SYN-ACK and your kernel sees it as unsolicited packet, it will reply with an RST.\n\n\nTo prevent this, use local firewall rules (e.g. NetFilter/IPtables for Linux). Scapy does not mind about local firewalls.\n  iptables -A OUTPUT -p tcp --tcp-flags RST RST -s 192.168.1.1 -j DROP\n\n\n\n\n\n\n\n\n\nSYN scan\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSYN scan on single target, single port\n\n\n\n\nWe send packets using \nsr1\n function.\n\n\nThe response is just a single packet.\n\n\nWe use Scapy\ns \nsprintf\n method to print interesting fields in the response. (\nSA\n flags indicates open ports, \nRA\n flags indicates closed ports)\n\n\n\n\n syn_packet = IP(dst='192.168.56.102')/TCP(dport=4444,flags='S')\n\n resp = sr1(syn_packet)\n\n resp.sprintf('%TCP.src% \\t %TCP.sport% \\t %TCP.flags%')\n'192.168.56.102     4444      SA'\n\n\n\n\nSYN scan on single target, multiple ports\n\n\n\n\nWe use \nsr\n functions send our packets.\n\n\nsr\n returns answered probes and unanswered probes that we assign to two variables.\n\n\nans\n has all the answered probes in stimulus/response pairs(a tuple).\n\n\nWe use a simple lambda function to loop over the answered probes and print interesting fields.\n\n\nIn the below example, each entry in \nans\n i.e. a stimuli response pair is passed on to a lambda function(stimuli \n response as \ns\n, \nr\n respectively). Inside lambda function, we use sprintf to extract interesting fields.\n\n\n\n\n ans, unans = sr(IP(dst=\n192.168.56.90-110\n)/TCP(dport=(20,24),flags=\nS\n))\n\n ans.summary( lambda(s,r): r.sprintf(\n%TCP.sport% \\t %TCP.flags%\n) )\n'ftp_data    RA'\n'21          RA\n'ssh         SA'\n'telnet      RA'\n'24          RA'\n\n\n\n\nSYN scan on multiple targets, multiple ports\n\n\n\n\nmake_table\n is an advanced feature in scapy that helps you visualize larger and complex scans.\n\n\n\n\n ans,unans = sr(IP(dst=[\nscanme.nmap.org\n,\negadz.metasploit.com\n])/TCP(dport=[10,20,30],flags=\nS\n))\n\n\n\n ans.make_table(lambda(s,r): (s.dst, s.dport,r.sprintf(\n%TCP.flags%\n)))\n\n   45.33.32.156 198.58.109.32 \n10 RA           SA            \n20 RA           SA            \n30 RA           SA\n\n\n\n\nFin scan\n\n\n\n\n\n\n\n\n\nFin scan on open port - scapy\n\n\n fin_packet = IP(dst='192.168.56.102')/TCP(dport=4444,flags='F')\n\n resp = sr1(fin_packet)\nBegin emission:\nFinished to send 1 packets.\n^C\nReceived 0 packets, got 0 answers, remaining 1 packets\n\n\n\n\nFin scan on closed port - scapy\n\n\n fin_packet = IP(dst='192.168.56.102')/TCP(dport=6767,flags='F')\n\n resp = sr1(fin_packet)\n\n resp.sprintf('%TCP.flags%')\n'RA'\n\n\n\n\nNull scan\n\n\n\n\n\n\n\n\n\nXmas scan\n\n\n\n\n\n\n\n\n\nUDP scan\n\n\n\n\n\n\n\n\n\nIP ID Scan (nmap idle scan)\n\n\nIn 1998, security researcher Antirez posted to the Bugtraq mailing list an ingenious new port scanning technique. \nIdle scan\n, as it has become known, allows for completely blind port scanning. \nAttackers can actually scan a target without sending a single packet to the target from their own IP address!\n Instead, a clever side-channel attack allows for the scan to be bounced off a dumb \u201czombie host\u201d. Intrusion detection system (IDS) reports will finger the innocent zombie as the attacker.\n\n\nIdle scan can be explained in following steps:\n\n\n\n\n\n\n\nOne way to determine whether a TCP port is open is to send a SYN (session establishment) packet to the port. The target machine will respond with a SYN/ACK (session request acknowledgment) packet if the port is open, and RST (reset) if the port is closed. This is the basis of the previously discussed SYN scan.\n\n\n\n\n\n\nA machine that receives an unsolicited SYN/ACK packet will respond with a RST. An unsolicited RST will be ignored.\n\n\n\n\n\n\nEvery IP packet on the Internet has a fragment identification number (IP ID). Since many operating systems simply increment this number for each packet they send, probing for the IP ID can tell an attacker how many packets have been sent since the last probe.\n\n\n\n\n\n\nBy combining these traits, it is possible to scan a target network while forging your identity so that it looks like an innocent zombie machine did the scanning.", 
            "title": "Service discovery"
        }, 
        {
            "location": "/network_recon/service_discovery/index.html#service-discoveryport-scanning", 
            "text": "", 
            "title": "Service discovery(Port Scanning)"
        }, 
        {
            "location": "/network_recon/service_discovery/index.html#tcp-three-way-handshake", 
            "text": "Three-way handshake captured using tcpdump  192.168.56.1.35555   192.168.56.102.4444: Flags [S] seq=12345   \n192.168.56.102.4444   192.168.56.1.35555: Flags [S.],  seq=9998 ack=12346\n192.168.56.1.35555   192.168.56.102.4444: Flags [.] seq=12346 ack=9999    A note on tcpdump output:   A port number is appended to the IP address with an additional dot.  192.168.56.1.35555  is IP  192.168.56.1  port  35555 .  An ACK bit is represented by a  .  so  [S.]  is  SYN-ACK ,  [.]  is  ACK .", 
            "title": "TCP Three way handshake"
        }, 
        {
            "location": "/network_recon/service_discovery/index.html#crafting-the-three-way-handshake-in-scapy", 
            "text": "To craft three-way handshake we need to be able to record the response of the server and craft our responses based on server response.   Step I - Send the client\u2019s SYN to a listening server (SYN)   Craft an IP header with the source and destination IP addresses.  Craft a TCP header where we generate the TCP source port, assign the destination port that the server listens on, set the TCP flags to turn the  SYN bit on, and generate the client\u2019s ISN.   ip = IP(src='192.168.56.1', dst='192.168.56.101')\nsyn = TCP(sport=4000, dport=80, flags='S', seq='12345')\nsyn_pkt = ip/syn  Step II - Listen for the server s response (SYN - ACK)   Save the server\u2019s response. (ideally the response should be syn-ack).  Extract the server\u2019s TCP sequence number and increment the value by one.    syn_ack = sr1(packet)  my_ack = syn_ack.seq+1  Send an acknowledgement from client for server s response (ACK)   IP header has the same source and destination as the intial SYN packet.  TCP header has the same TCP source and destination ports as syn packet, only ACK bit is set, increment the client\u2019s ISN by one since the SYN packet consumes one sequence number, set the acknowledgement value to the incremented server\u2019s sequence number value.   ack = TCP(sport=4000, dport=80, flags='A', seq='12346', ack=my_ack)\nack_pkt = ip/ack\nsend(ack_pkt)  If everything went right, we have just sucessfully established TCP three-way handshake   Why RST??   If you have noticed whenever we recieve a packet, our machine automatically responds with an RST packet.  The kernel is not aware of what Scapy is doing behind it s back(Scapy is userland program). If Scapy sends a SYN, the target replies with a SYN-ACK and your kernel sees it as unsolicited packet, it will reply with an RST.  To prevent this, use local firewall rules (e.g. NetFilter/IPtables for Linux). Scapy does not mind about local firewalls.   iptables -A OUTPUT -p tcp --tcp-flags RST RST -s 192.168.1.1 -j DROP", 
            "title": "Crafting the Three-way Handshake in Scapy"
        }, 
        {
            "location": "/network_recon/service_discovery/index.html#syn-scan", 
            "text": "", 
            "title": "SYN scan"
        }, 
        {
            "location": "/network_recon/service_discovery/index.html#syn-scan-on-single-target-single-port", 
            "text": "We send packets using  sr1  function.  The response is just a single packet.  We use Scapy s  sprintf  method to print interesting fields in the response. ( SA  flags indicates open ports,  RA  flags indicates closed ports)    syn_packet = IP(dst='192.168.56.102')/TCP(dport=4444,flags='S')  resp = sr1(syn_packet)  resp.sprintf('%TCP.src% \\t %TCP.sport% \\t %TCP.flags%')\n'192.168.56.102     4444      SA'", 
            "title": "SYN scan on single target, single port"
        }, 
        {
            "location": "/network_recon/service_discovery/index.html#syn-scan-on-single-target-multiple-ports", 
            "text": "We use  sr  functions send our packets.  sr  returns answered probes and unanswered probes that we assign to two variables.  ans  has all the answered probes in stimulus/response pairs(a tuple).  We use a simple lambda function to loop over the answered probes and print interesting fields.  In the below example, each entry in  ans  i.e. a stimuli response pair is passed on to a lambda function(stimuli   response as  s ,  r  respectively). Inside lambda function, we use sprintf to extract interesting fields.    ans, unans = sr(IP(dst= 192.168.56.90-110 )/TCP(dport=(20,24),flags= S ))  ans.summary( lambda(s,r): r.sprintf( %TCP.sport% \\t %TCP.flags% ) )\n'ftp_data    RA'\n'21          RA\n'ssh         SA'\n'telnet      RA'\n'24          RA'", 
            "title": "SYN scan on single target, multiple ports"
        }, 
        {
            "location": "/network_recon/service_discovery/index.html#syn-scan-on-multiple-targets-multiple-ports", 
            "text": "make_table  is an advanced feature in scapy that helps you visualize larger and complex scans.    ans,unans = sr(IP(dst=[ scanme.nmap.org , egadz.metasploit.com ])/TCP(dport=[10,20,30],flags= S ))   ans.make_table(lambda(s,r): (s.dst, s.dport,r.sprintf( %TCP.flags% )))\n\n   45.33.32.156 198.58.109.32 \n10 RA           SA            \n20 RA           SA            \n30 RA           SA", 
            "title": "SYN scan on multiple targets, multiple ports"
        }, 
        {
            "location": "/network_recon/service_discovery/index.html#fin-scan", 
            "text": "Fin scan on open port - scapy   fin_packet = IP(dst='192.168.56.102')/TCP(dport=4444,flags='F')  resp = sr1(fin_packet)\nBegin emission:\nFinished to send 1 packets.\n^C\nReceived 0 packets, got 0 answers, remaining 1 packets  Fin scan on closed port - scapy   fin_packet = IP(dst='192.168.56.102')/TCP(dport=6767,flags='F')  resp = sr1(fin_packet)  resp.sprintf('%TCP.flags%')\n'RA'", 
            "title": "Fin scan"
        }, 
        {
            "location": "/network_recon/service_discovery/index.html#null-scan", 
            "text": "", 
            "title": "Null scan"
        }, 
        {
            "location": "/network_recon/service_discovery/index.html#xmas-scan", 
            "text": "", 
            "title": "Xmas scan"
        }, 
        {
            "location": "/network_recon/service_discovery/index.html#udp-scan", 
            "text": "", 
            "title": "UDP scan"
        }, 
        {
            "location": "/network_recon/service_discovery/index.html#ip-id-scan-nmap-idle-scan", 
            "text": "In 1998, security researcher Antirez posted to the Bugtraq mailing list an ingenious new port scanning technique.  Idle scan , as it has become known, allows for completely blind port scanning.  Attackers can actually scan a target without sending a single packet to the target from their own IP address!  Instead, a clever side-channel attack allows for the scan to be bounced off a dumb \u201czombie host\u201d. Intrusion detection system (IDS) reports will finger the innocent zombie as the attacker. \nIdle scan can be explained in following steps:    One way to determine whether a TCP port is open is to send a SYN (session establishment) packet to the port. The target machine will respond with a SYN/ACK (session request acknowledgment) packet if the port is open, and RST (reset) if the port is closed. This is the basis of the previously discussed SYN scan.    A machine that receives an unsolicited SYN/ACK packet will respond with a RST. An unsolicited RST will be ignored.    Every IP packet on the Internet has a fragment identification number (IP ID). Since many operating systems simply increment this number for each packet they send, probing for the IP ID can tell an attacker how many packets have been sent since the last probe.    By combining these traits, it is possible to scan a target network while forging your identity so that it looks like an innocent zombie machine did the scanning.", 
            "title": "IP ID Scan (nmap idle scan)"
        }, 
        {
            "location": "/network_recon/os_detection/index.html", 
            "text": "Remote OS Detection\n\n\nThere are two approaches to finger printing remote Operating Systems:\n\n\n\n\n\n\nActive OS finger printing\n\n\n\n\nActive finger printing is when attacker sends a series of TCP and UDP packets to the remote host and  examines practically every bit in the responses. After the tests the results are compared against the general behaviour of Operating Systems for a match.\n\n\nNmap is the most popular active OS detection tool. Nmap probes a target with large number of well crafted packets and the results are compared against Nmap\ns database of OS fingerprints (\nnmap-os-db\n).\n\n\nFor more details on Nmap\ns active OS detection techniques \nNmap OS Detection\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPassive OS fingerprinting\n\n\n\n\nPassive OS finger prining is analyzing network traffic to detect what operating system the client/server are running. This possible because of the difference in TCP/IP stack implemention in various operating systems. P0f is a popular passive finger printing tool with large database of finger prints.\n\n\nFor more details on p0f finger printing \nPassive OS finger printing with p0f\n \n\n\n\n\n\n\n\n\nActive OS finger printing\n\n\nDifferences in protocol implementations\n\n\nRFC 793 says:\n\nACK (1 bit) \u2013 indicates that the Acknowledgment field is significant. \nAll packets after the initial SYN packet sent by the client should have this flag set\n.\n\n\nBut, IP stacks are written for different OSs by different people who read the RFCs and then write their interpretation of what the RFC outlines into code. This leads to a difference in how IP stacks are implemeted across OSes.\n\n\nLinux implementation\n\n\nLinux kernel 2.4+ accepts and acknowledges a segment in an established session where no TCP flags are set and where the segment has payload\n No other well known current operating system accepts this same segment. \n\nThis behaviour of Linux network stack is complied into the kernel so it isn\nt easy to alter it. This makes it a very foolproof technique for remote Linux OS detection.\n\n\nThe Technique:\n\n\n\n\n\n\n\n\n\n\n\nEstablish a TCP three-way handshake with the target.\n\n\nAll we have to do after handshake is to create a segment with \nno TCP flags and add some payload\n and send it.\n\n\n\n\nPUSH=(sport=1024,dport=80,flags=\u201d\u201d,seq=12346,ack=my_ack)  # No flags set.\n\ndata=\u201dJUST A FILLER\u201d\n\nsend(ip/PUSH/data)\n\n\n\n\n\n\nIf the target is Linux server(2.4+ kernel), you\nll see an ACK bit set in the response.\n\n\nIn case of other operating systems, the response will most likely be a RST packet.\n\n\n\n\nPassive OS fingerprinting\n\n\nTTL \n Window size analysis", 
            "title": "OS detection"
        }, 
        {
            "location": "/network_recon/os_detection/index.html#remote-os-detection", 
            "text": "There are two approaches to finger printing remote Operating Systems:    Active OS finger printing   Active finger printing is when attacker sends a series of TCP and UDP packets to the remote host and  examines practically every bit in the responses. After the tests the results are compared against the general behaviour of Operating Systems for a match.  Nmap is the most popular active OS detection tool. Nmap probes a target with large number of well crafted packets and the results are compared against Nmap s database of OS fingerprints ( nmap-os-db ).  For more details on Nmap s active OS detection techniques  Nmap OS Detection          Passive OS fingerprinting   Passive OS finger prining is analyzing network traffic to detect what operating system the client/server are running. This possible because of the difference in TCP/IP stack implemention in various operating systems. P0f is a popular passive finger printing tool with large database of finger prints.  For more details on p0f finger printing  Passive OS finger printing with p0f", 
            "title": "Remote OS Detection"
        }, 
        {
            "location": "/network_recon/os_detection/index.html#active-os-finger-printing", 
            "text": "", 
            "title": "Active OS finger printing"
        }, 
        {
            "location": "/network_recon/os_detection/index.html#differences-in-protocol-implementations", 
            "text": "RFC 793 says: ACK (1 bit) \u2013 indicates that the Acknowledgment field is significant.  All packets after the initial SYN packet sent by the client should have this flag set .  But, IP stacks are written for different OSs by different people who read the RFCs and then write their interpretation of what the RFC outlines into code. This leads to a difference in how IP stacks are implemeted across OSes.", 
            "title": "Differences in protocol implementations"
        }, 
        {
            "location": "/network_recon/os_detection/index.html#linux-implementation", 
            "text": "Linux kernel 2.4+ accepts and acknowledges a segment in an established session where no TCP flags are set and where the segment has payload  No other well known current operating system accepts this same segment.  \nThis behaviour of Linux network stack is complied into the kernel so it isn t easy to alter it. This makes it a very foolproof technique for remote Linux OS detection.", 
            "title": "Linux implementation"
        }, 
        {
            "location": "/network_recon/os_detection/index.html#the-technique", 
            "text": "Establish a TCP three-way handshake with the target.  All we have to do after handshake is to create a segment with  no TCP flags and add some payload  and send it.   PUSH=(sport=1024,dport=80,flags=\u201d\u201d,seq=12346,ack=my_ack)  # No flags set. data=\u201dJUST A FILLER\u201d send(ip/PUSH/data)   If the target is Linux server(2.4+ kernel), you ll see an ACK bit set in the response.  In case of other operating systems, the response will most likely be a RST packet.", 
            "title": "The Technique:"
        }, 
        {
            "location": "/network_recon/os_detection/index.html#passive-os-fingerprinting", 
            "text": "", 
            "title": "Passive OS fingerprinting"
        }, 
        {
            "location": "/network_recon/os_detection/index.html#ttl-window-size-analysis", 
            "text": "", 
            "title": "TTL &amp; Window size analysis"
        }, 
        {
            "location": "/network_recon/promisc/index.html", 
            "text": "Promiscuous node detection\n\n\n\n\nYou have an attacker sitting in your internal network, listening to all the traffic, you are running against time to find him/shut him down! What do you do?\n\n\n\n\nPromiscuous mode\n\n\n\n\nPromiscuous mode allows a network device to intercept and read each network packet that arrives in its entirety.\n\n\n\n\nUnlike Monitor mode, in promisc mode the listener has to be connected to the network.\n\n\n\n\n\n\nSome tools that use promiscuous mode - Wireshark, Tcpdump, Aircrack-ng, cain and abel, Snort, Virtualbox\n\n\n\n\nExtremely effective because of it\ns passive nature.\n\n\n\n\nEnable promiscuous mode:\n\n\n$ sudo ifconfig \niface\n promisc   \n\n\n\n\nDisable promiscuous mode:\n\n\n$ sudo ifconfig \niface\n -promisc   \n\n\n\n\n\n\n Detecting promisc node -  The idea:\n\n\n\n\n\n\nAll the packets recieved by promisc NIC are passed on to the kernel, so the basic idea of detection is to send specially crafted packets that may trick the system kernel to respond to packets that it is not supposed to respond to.\n\n\n\n\n\n\nFake ARP request packets, ICMP Ping(echo request) with wrong MAC but right IP address could do the job.\n\n\n\n\n\n\nARP Protocol\n\n\n\n\nARP protocol is used for resolution of network layer addresses into link layer addresses, IPV4 over Ethernet generally.\n\n\n\n\n\n\nARP is depricated in IPv6 and the functionality is provided by  Network Discovery Protocol(NDP).\n\n\n\n\n\n\nARP works inside a network and it is \nnever routed\n outside.\n\n\nARP is a \nlayer 2 protocol\n(well, yeah yeah, \n2.5 layer maybe\n, for all the CCNA people)\n\n\nARP is generally \nbroadcasted\n in the local network.\n\n\n\n\n \n\n \n\n\nHardware filter\n\n\nNormally,  NIC of a machine filters and accepts only packets that have destination address set to the NIC\ns own hardware address, broadcast address (FF FF FF FF FF FF), and multicast address 1(01 00 5E 00 00 01). Let\ns call this a hardware filter.\nBut in promiscuous mode NIC is set to accept every packet that it recieves.\n\n\n\n\nShould be easy to find promisc nodes, right?\nJust send packet that is supposed to be filtered by normal mode hardware filter, only a promisc node would pass it to kernel and respond to that.\n\n\nLet\ns try: \n00:00:00:00:00:01\n. What happens??\n\n\n\n\nSoftware Filter\n\n\nOperating system kernels implement a filter, let\ns call it \nsoftware filter\n.\nEven though a packet passes through hardware filter, kernel is implementing another filter.\n\n\nHardware filter vs Software filter\n\n\nThe hardware filter usually blocks packets that are not supposed to arrive to the system kernel. \n\n\nWe need to craft a packet that is:\n\na. Blocked by the hardware filter in normal mode.\n\nb. Should be able to pass the software filter.", 
            "title": "Promisc detection"
        }, 
        {
            "location": "/network_recon/promisc/index.html#promiscuous-node-detection", 
            "text": "You have an attacker sitting in your internal network, listening to all the traffic, you are running against time to find him/shut him down! What do you do?", 
            "title": "Promiscuous node detection"
        }, 
        {
            "location": "/network_recon/promisc/index.html#promiscuous-mode", 
            "text": "Promiscuous mode allows a network device to intercept and read each network packet that arrives in its entirety.   Unlike Monitor mode, in promisc mode the listener has to be connected to the network.    Some tools that use promiscuous mode - Wireshark, Tcpdump, Aircrack-ng, cain and abel, Snort, Virtualbox   Extremely effective because of it s passive nature.   Enable promiscuous mode:  $ sudo ifconfig  iface  promisc     Disable promiscuous mode:  $ sudo ifconfig  iface  -promisc", 
            "title": "Promiscuous mode"
        }, 
        {
            "location": "/network_recon/promisc/index.html#detecting-promisc-node-the-idea", 
            "text": "All the packets recieved by promisc NIC are passed on to the kernel, so the basic idea of detection is to send specially crafted packets that may trick the system kernel to respond to packets that it is not supposed to respond to.    Fake ARP request packets, ICMP Ping(echo request) with wrong MAC but right IP address could do the job.", 
            "title": "Detecting promisc node -  The idea:"
        }, 
        {
            "location": "/network_recon/promisc/index.html#arp-protocol", 
            "text": "ARP protocol is used for resolution of network layer addresses into link layer addresses, IPV4 over Ethernet generally.    ARP is depricated in IPv6 and the functionality is provided by  Network Discovery Protocol(NDP).    ARP works inside a network and it is  never routed  outside.  ARP is a  layer 2 protocol (well, yeah yeah,  2.5 layer maybe , for all the CCNA people)  ARP is generally  broadcasted  in the local network.", 
            "title": "ARP Protocol"
        }, 
        {
            "location": "/network_recon/promisc/index.html#hardware-filter", 
            "text": "Normally,  NIC of a machine filters and accepts only packets that have destination address set to the NIC s own hardware address, broadcast address (FF FF FF FF FF FF), and multicast address 1(01 00 5E 00 00 01). Let s call this a hardware filter.\nBut in promiscuous mode NIC is set to accept every packet that it recieves.   Should be easy to find promisc nodes, right?\nJust send packet that is supposed to be filtered by normal mode hardware filter, only a promisc node would pass it to kernel and respond to that.  Let s try:  00:00:00:00:00:01 . What happens??", 
            "title": "Hardware filter"
        }, 
        {
            "location": "/network_recon/promisc/index.html#software-filter", 
            "text": "Operating system kernels implement a filter, let s call it  software filter .\nEven though a packet passes through hardware filter, kernel is implementing another filter.", 
            "title": "Software Filter"
        }, 
        {
            "location": "/network_recon/promisc/index.html#hardware-filter-vs-software-filter", 
            "text": "The hardware filter usually blocks packets that are not supposed to arrive to the system kernel.   We need to craft a packet that is: \na. Blocked by the hardware filter in normal mode. \nb. Should be able to pass the software filter.", 
            "title": "Hardware filter vs Software filter"
        }, 
        {
            "location": "/network_recon/pcap_analysis/index.html", 
            "text": "PCAP analysis\n\n\n\n\nScapy has pretty handy functions for handling PCAP files.\n\n\nAlthough there are dedicated tools like dpkt, pcapy etc to deal with packet captures(using Python), Scapy is still a go-to tool for PCAP aanalysis because of it\ns dense methods that aid you in number of packet analysis operations.\n\n\nAlthough Scapy is all powerful, it\ns takes a lot of memory when reading packets so analysing larger packet will take toll on your system memory.\n\n\n\n\nPCAP operations\n\n\n\n\nMemory matters!\n\n\n\n\nScapy looks at each packet as a class which takes toll on the system memory, so it is not a right choice for analysing large PCAPs\n\n\nWhen investigating large PCAP\ns(several Giga Bytes) use light-weight tools like Tshark for initial analysis, when investigation boils down to smaller set of packets, use Scapy.\n\n\n\n\n\n\nReading pcap\n\n\n\n\nYou can read a PCAP file in Scapy using \nrdpcap\n function.\n\n\n\n\n rdpcap('port_knock_seq.pcap')\n\nport_knock_seq.pcap: TCP:6 UDP:0 ICMP:0 Other:0\n\n\n\n\n\n pkts = sniff(offline=\ntemp.cap\n)\n\n\n\n\nWriting pcap\n\n\n\n\nYou can write a set of packets into a PCAP file  using \nwrpcap\n function.\n\n\n\n\n wrpcap(\nattack.pcap\n,packets)\n\n\n\n\nSimple tcp-replay tool\n\n\n\n\nYou can write a very simple tcp-replay tools in one line of scapy.\n\n\nThis piece of code send packets in a PCAP over the network, very handy in some forensic analysis situations.\n\n\n\n\n sendp(rdpcap(\n/tmp/pcapfile\n)) # tcpreplay\n...........\nSent 11 packets.\n\n\n\n\n\n\n\n\n\n\nExercise time - packet hunting\n\n\nPlease solve Exercise 4- packet hunting (Misc exercises)", 
            "title": "PCAP Analysis"
        }, 
        {
            "location": "/network_recon/pcap_analysis/index.html#pcap-analysis", 
            "text": "Scapy has pretty handy functions for handling PCAP files.  Although there are dedicated tools like dpkt, pcapy etc to deal with packet captures(using Python), Scapy is still a go-to tool for PCAP aanalysis because of it s dense methods that aid you in number of packet analysis operations.  Although Scapy is all powerful, it s takes a lot of memory when reading packets so analysing larger packet will take toll on your system memory.", 
            "title": "PCAP analysis"
        }, 
        {
            "location": "/network_recon/pcap_analysis/index.html#pcap-operations", 
            "text": "Memory matters!   Scapy looks at each packet as a class which takes toll on the system memory, so it is not a right choice for analysing large PCAPs  When investigating large PCAP s(several Giga Bytes) use light-weight tools like Tshark for initial analysis, when investigation boils down to smaller set of packets, use Scapy.", 
            "title": "PCAP operations"
        }, 
        {
            "location": "/network_recon/pcap_analysis/index.html#reading-pcap", 
            "text": "You can read a PCAP file in Scapy using  rdpcap  function.    rdpcap('port_knock_seq.pcap') port_knock_seq.pcap: TCP:6 UDP:0 ICMP:0 Other:0    pkts = sniff(offline= temp.cap )", 
            "title": "Reading pcap"
        }, 
        {
            "location": "/network_recon/pcap_analysis/index.html#writing-pcap", 
            "text": "You can write a set of packets into a PCAP file  using  wrpcap  function.    wrpcap( attack.pcap ,packets)", 
            "title": "Writing pcap"
        }, 
        {
            "location": "/network_recon/pcap_analysis/index.html#simple-tcp-replay-tool", 
            "text": "You can write a very simple tcp-replay tools in one line of scapy.  This piece of code send packets in a PCAP over the network, very handy in some forensic analysis situations.    sendp(rdpcap( /tmp/pcapfile )) # tcpreplay\n...........\nSent 11 packets.     Exercise time - packet hunting  Please solve Exercise 4- packet hunting (Misc exercises)", 
            "title": "Simple tcp-replay tool"
        }, 
        {
            "location": "/network_recon/traceroute/index.html", 
            "text": "Traceroute\n\n\n\n\nTraceroute is a tool/technique to list all the routers that your packets go through to reach a target.\n\n\nThe technique is to send series of packets to the target with Time to Live (TTL) set in such a way that each router on the path will have to notify you of the death of the packet.\n\n\nThe traceroute technique is based on the way the IP protocol is designed. TTL value in IP header is seen as hop limit. Everytime a router recieves a packet to forward, it decrements the TTL by one and forwards the packet. When TTL reaches 0, the router will send a reply to the source machine indicating the packet has died.\n\n\nThe technique behind various tools is same but the way they implement it slightly differs. Unix systems use UDP datagrams while the Windows \ntracert\n program uses ICMP and \ntcptraceroute\n uses TCP.\n\n\n\n\n\n\n\n\n\n\nMost traceroute tools tend to send a packet with ceratin TTL value and wait for a reply before sending out the next packet which could slow down the whole process, especially when there is a network note that is unresponsive.\n\n\n\n\n\n\nIn this example, we are going to do a Standard ICMP Traceroute but we will send all our probes at the same time.\n\n\n\n\nOne obvious question, \nWhere do we stop?\n For this exercises we\nll just send packets till TTL 30 and that is a decent number to reach almost any node on Internet.\n\n\n\n\n ans,unans=sr(IP(dst=\n4.2.2.1\n,ttl=(1,10))/ICMP())\n\n\n\n\n\n\nOnce, we receive all probe requests we can obtain results:\n\n\n\n\n ans.summary( lambda(s,r) : r.sprintf(\n%IP.src%\n))\n192.168.1.1\n68.88.88.88\n68.60.60.60\n4.79.43.134\n4.79.43.133\n4.68.18.62\n4.68.123.6\n4.2.2.1\n4.2.2.1\n\n\n\n\n\n\nSimilarly, we can use TCP SYN traceroute to obtain similar results:\n\n\n\n\nans,unans=sr(IP(dst=\n4.2.2.1\n,ttl=(1,10))/TCP(dport=53,flags=\nS\n))\n\n\n\n\n\n\nAnd again results would be:\n\n\n\n\n ans.summary( lambda(s,r) : r.sprintf(\n%IP.src%\\t{ICMP:%ICMP.type%}\\t{TCP:%TCP.flags%}\n))\n192.168.1.1     time-exceeded\n68.86.90.162    time-exceeded\n4.79.43.134     time-exceeded\n4.79.43.133     time-exceeded\n4.68.18.126     time-exceeded\n4.68.123.38     time-exceeded\n4.2.2.1         SA\n\n\n\n\n\n\nScapy includes a built-in traceroute() function to perform same functionality as above. Here is an example of TCP SYN traceroute:\n\n\n\n\n traceroute(\n4.2.2.1\n)\nBegin emission:\n***********************Finished to send 30 packets.\n****\nReceived 27 packets, got 27 answers, remaining 3 packets\n   4.2.2.1:tcp80      \n1  192.168.1.1     11 \n5  4.79.43.134     11 \n6  4.79.43.133     11 \n7  4.68.18.62      11 \n8  4.68.123.6      11 \n9  4.2.2.1         RA \n10 4.2.2.1         RA \n...\n\n\n\n\n\n\nWe can perform a DNS traceroute by specifying a complete packet in l4 parameter of traceroute() function:\n\n\n\n\n ans,unans=traceroute(\n4.2.2.1\n,l4=UDP(sport=RandShort())/DNS(qd=DNSQR(qname=\nthesprawl.org\n)))\nBegin emission:\n..*....******...******.***...****Finished to send 30 packets.\n*****...***...............................\nReceived 75 packets, got 28 answers, remaining 2 packets\n   4.2.2.1:udp53      \n1  192.168.1.1     11 \n4  68.86.90.162    11 \n5  4.79.43.134     11 \n6  4.79.43.133     11 \n7  4.68.18.62      11 \n8  4.68.123.6      11 \n9  4.2.2.1            \n...\n\n\n\n\n\n\nSimilarly, IP Fragment traceroute can be emulated with this command:\n\n\n\n\n res,unans = sr(IP(dst=\n4.2.2.1\n, ttl=(5,10), flags=\nMF\n)\n...                /UDP(sport=RandShort( ), dport=53), timeout=125)\n\nNote: I couldn't produce Type 11 Code 1 (Time Exceeded During Reassembly) ICMP error.\n\n\n\n\nNAT detect", 
            "title": "Traceroute"
        }, 
        {
            "location": "/network_recon/traceroute/index.html#traceroute", 
            "text": "Traceroute is a tool/technique to list all the routers that your packets go through to reach a target.  The technique is to send series of packets to the target with Time to Live (TTL) set in such a way that each router on the path will have to notify you of the death of the packet.  The traceroute technique is based on the way the IP protocol is designed. TTL value in IP header is seen as hop limit. Everytime a router recieves a packet to forward, it decrements the TTL by one and forwards the packet. When TTL reaches 0, the router will send a reply to the source machine indicating the packet has died.  The technique behind various tools is same but the way they implement it slightly differs. Unix systems use UDP datagrams while the Windows  tracert  program uses ICMP and  tcptraceroute  uses TCP.      Most traceroute tools tend to send a packet with ceratin TTL value and wait for a reply before sending out the next packet which could slow down the whole process, especially when there is a network note that is unresponsive.    In this example, we are going to do a Standard ICMP Traceroute but we will send all our probes at the same time.   One obvious question,  Where do we stop?  For this exercises we ll just send packets till TTL 30 and that is a decent number to reach almost any node on Internet.    ans,unans=sr(IP(dst= 4.2.2.1 ,ttl=(1,10))/ICMP())   Once, we receive all probe requests we can obtain results:    ans.summary( lambda(s,r) : r.sprintf( %IP.src% ))\n192.168.1.1\n68.88.88.88\n68.60.60.60\n4.79.43.134\n4.79.43.133\n4.68.18.62\n4.68.123.6\n4.2.2.1\n4.2.2.1   Similarly, we can use TCP SYN traceroute to obtain similar results:   ans,unans=sr(IP(dst= 4.2.2.1 ,ttl=(1,10))/TCP(dport=53,flags= S ))   And again results would be:    ans.summary( lambda(s,r) : r.sprintf( %IP.src%\\t{ICMP:%ICMP.type%}\\t{TCP:%TCP.flags%} ))\n192.168.1.1     time-exceeded\n68.86.90.162    time-exceeded\n4.79.43.134     time-exceeded\n4.79.43.133     time-exceeded\n4.68.18.126     time-exceeded\n4.68.123.38     time-exceeded\n4.2.2.1         SA   Scapy includes a built-in traceroute() function to perform same functionality as above. Here is an example of TCP SYN traceroute:    traceroute( 4.2.2.1 )\nBegin emission:\n***********************Finished to send 30 packets.\n****\nReceived 27 packets, got 27 answers, remaining 3 packets\n   4.2.2.1:tcp80      \n1  192.168.1.1     11 \n5  4.79.43.134     11 \n6  4.79.43.133     11 \n7  4.68.18.62      11 \n8  4.68.123.6      11 \n9  4.2.2.1         RA \n10 4.2.2.1         RA \n...   We can perform a DNS traceroute by specifying a complete packet in l4 parameter of traceroute() function:    ans,unans=traceroute( 4.2.2.1 ,l4=UDP(sport=RandShort())/DNS(qd=DNSQR(qname= thesprawl.org )))\nBegin emission:\n..*....******...******.***...****Finished to send 30 packets.\n*****...***...............................\nReceived 75 packets, got 28 answers, remaining 2 packets\n   4.2.2.1:udp53      \n1  192.168.1.1     11 \n4  68.86.90.162    11 \n5  4.79.43.134     11 \n6  4.79.43.133     11 \n7  4.68.18.62      11 \n8  4.68.123.6      11 \n9  4.2.2.1            \n...   Similarly, IP Fragment traceroute can be emulated with this command:    res,unans = sr(IP(dst= 4.2.2.1 , ttl=(5,10), flags= MF )\n...                /UDP(sport=RandShort( ), dport=53), timeout=125)\n\nNote: I couldn't produce Type 11 Code 1 (Time Exceeded During Reassembly) ICMP error.", 
            "title": "Traceroute"
        }, 
        {
            "location": "/network_recon/traceroute/index.html#nat-detect", 
            "text": "", 
            "title": "NAT detect"
        }, 
        {
            "location": "/wireless/wireless_recon/index.html", 
            "text": "Wireless recon\n\n\n802.11\n\n\n\n\n802.11 has a number of layers.\n\n\n\n\n\n\n pkts = sniff(iface = 'mon1',count=10)\n\n pkt = pkts[0]\n\n\n\n pkt\n\nRadioTap  version=0 pad=0 len=30 present=Flags+Rate+Channel+dBm_AntSignal+b14+b29+Ext\nnotdecoded=' \\x08\\x00\\xa0 \\x08\\x00\\x00\\x00\\x02\\x99\\t\\xa0\\x00\\xc7\\x00\\x00\\x00\\xc7\\x00\\xc2\\x01' |\n\nDot11  subtype=5L type=Management proto=0L FCfield=retry ID=14849 addr1=0c:8b:fd:f4:09:16 addr2=48:9d:24:37:bf:e6 addr3=48:9d:24:37:bf:e6 SC=23104 addr4=None |\nDot11ProbeResp  timestamp=6058312302 beacon_interval=100 cap=res8+short-slot+ESS+privacy |\n\nDot11Elt  ID=SSID len=30 info='blackBerry_hotspot' |\n\nDot11Elt ID=Rates len=8 info='\\x8c\\x12\\x98$\\xb0H`l' \n|\nDot11Elt  ID=DSset len=1 info='\\x0b' |\n\nDot11Elt  ID=32 len=1 info='\\x00' |\n\nDot11Elt  ID=35 len=2 info='\\x08\\x00' |\n[... snipped ...]\n\n\n\n\n\n\nRadioTap / Dot11 / Dot11Beacon / Dot11Elt / Dot11Elt", 
            "title": 802.11
        }, 
        {
            "location": "/wireless/wireless_recon/index.html#wireless-recon", 
            "text": "", 
            "title": "Wireless recon"
        }, 
        {
            "location": "/wireless/wireless_recon/index.html#80211", 
            "text": "802.11 has a number of layers.     pkts = sniff(iface = 'mon1',count=10)  pkt = pkts[0]   pkt RadioTap  version=0 pad=0 len=30 present=Flags+Rate+Channel+dBm_AntSignal+b14+b29+Ext\nnotdecoded=' \\x08\\x00\\xa0 \\x08\\x00\\x00\\x00\\x02\\x99\\t\\xa0\\x00\\xc7\\x00\\x00\\x00\\xc7\\x00\\xc2\\x01' | Dot11  subtype=5L type=Management proto=0L FCfield=retry ID=14849 addr1=0c:8b:fd:f4:09:16 addr2=48:9d:24:37:bf:e6 addr3=48:9d:24:37:bf:e6 SC=23104 addr4=None | Dot11ProbeResp  timestamp=6058312302 beacon_interval=100 cap=res8+short-slot+ESS+privacy | Dot11Elt  ID=SSID len=30 info='blackBerry_hotspot' | Dot11Elt ID=Rates len=8 info='\\x8c\\x12\\x98$\\xb0H`l' \n| Dot11Elt  ID=DSset len=1 info='\\x0b' | Dot11Elt  ID=32 len=1 info='\\x00' | Dot11Elt  ID=35 len=2 info='\\x08\\x00' |\n[... snipped ...]   RadioTap / Dot11 / Dot11Beacon / Dot11Elt / Dot11Elt", 
            "title": "802.11"
        }, 
        {
            "location": "/libraries/netaddr/index.html", 
            "text": "netaddr\n\n\nOverview\n\n\nA Python library for representing and manipulating network addresses.\n\n\nProvides support for:\n\n\nLayer 3 addresses\n\n\n\n\nIPv4 and IPv6 addresses, subnets, masks, prefixes\n\n\niterating, slicing, sorting, summarizing and classifying IP networks\n\n\ndealing with various ranges formats (CIDR, arbitrary ranges and globs, nmap)\n\n\nset based operations (unions, intersections etc) over IP addresses and subnets\n\n\nparsing a large variety of different formats and notations\n\n\nlooking up IANA IP block information\n\n\ngenerating DNS reverse lookups\n\n\nsupernetting and subnetting\n\n\n\n\nLayer 2 addresses\n\n\n\n\nrepresentation and manipulation MAC addresses and EUI-64 identifiers\n\n\nlooking up IEEE organisational information (OUI, IAB)\n\n\ngenerating derived IPv6 addresses\n\n\n\n\nInstallation\n\n\nInstall the latest \nnetaddr\n from PIP\n\n\npip install netaddr\n\n\n\n\nImporting netaddr\n\n\nfrom netaddr import *\n\n\n\n\n\n\nimporting modules\n\n\nImporting this way is not optimal and leads to name clashes.\n\nIn your own code, you should be explicit about the classes,\nfunctions and constants you import to avoid name clashes.\n\n\n\n\nLayer 3 addressing(IP)\n\n\nIPAddress\n\n\nIPAddress object represents a single IP address.\n\n\n from netaddr import IPAddress\n\n\n\n ip = IPAddress('192.21.8.11')\n\n ip.version\n4\n\n dir(ip)\n[ ... Snipped... 'bin', 'bits', 'format', 'info', 'ipv4', 'ipv6', \n'is_hostmask', 'is_ipv4_compat', 'is_ipv4_mapped', 'is_link_local',\n'is_loopback', 'is_multicast', 'is_netmask', 'is_private', 'is_reserved',\n'is_unicast', 'key', 'netmask_bits', 'packed', 'reverse_dns', 'sort_key',\n'value', 'version', 'words']\n\n \n\n\n\n\n\nThere are methods to handle coverting an IP adress into binary or bits, split an IP, pack an\n\n\n ip.bin\n'0b11000000000101010000100000001011'\n\n \n\n ip.bits()\n'11000000.00010101.00001000.00001011'\n\n \n\n ip.words\n(192, 21, 8, 11)\n\n ip.packed\n'\\xc0\\x15\\x08\\x0b'\n\n\n\n\n\nThere are methods to check if the type of IP address(class, scope, type)\n\n\n ip.version\n6\n\n ip.is_unicast()\nTrue\n\n \n\n ip.is_link_local()\nTrue\n\n\n\n\nIPNetwork\n\n\nIPNetwork objects are used to represent subnets, networks or VLANs that accept CIDR prefixes and netmasks.\n\n\n from netaddr import IPNetwork\n\n \n\n ip_range = IPNetwork('192.241.21.6/24')\n\n \n\n dir(ip_range)\n[ ... snipped ...  'broadcast', 'cidr', 'first', 'hostmask', 'info',\n'ip', 'ipv4', 'ipv6', 'is_ipv4_compat', 'is_ipv4_mapped', 'is_link_local',\n'is_loopback', 'is_multicast', 'is_private', 'is_reserved', 'is_unicast',\n'iter_hosts', 'key', 'last', 'netmask', 'network', 'next', 'prefixlen',\n'previous', 'size', 'sort_key', 'subnet', 'supernet', 'value', 'version']\n\n\n\n\n\n\nThere are a bunch of methods associated with IPNetwork to understand the network defined.\n\n\n ip_range.network\nIPAddress('192.241.21.0')\n\n\n\n ip_range.hostmask\nIPAddress('0.0.0.255')\n\n \n\n ip_range.netmask\nIPAddress('255.255.255.0')\n\n\n\n ip_range.broadcast\nIPAddress('192.241.21.255')\n\n\n\n ip_range.size\n256\n\n\n\n\nYou can use a simple for loop to iterate over the list of IP addresses in the network range defined.\n\n\n for i in ip_range:\n...     print i\n... \n192.241.21.0\n192.241.21.1\n... snipped ...\n192.241.21.255\n\n\n\n\n\nList operations on IPNetwork object\n\n\nIf you treat an IPNetwork object as if it were a standard Python list object it will give you access to a list of individual\nIP address objects also various standard python list methods.\n\n\n ip_range = IPNetwork('192.0.2.16/29')\n\n \n\n ip_range_list = list(ip_range)\n\n \n\n len(ip_range_list)\n8\n\n ip_range_list\n[IPAddress('192.0.2.16'), IPAddress('192.0.2.17'), ...snipped... IPAddress('192.0.2.23')]\n\n\n\n ip_range_list[6]        # indexing\nIPAddress('192.0.2.22')\n\n\n\n ip_range_list[2:5\n\n]      # slicing\n[IPAddress('192.0.2.18'), IPAddress('192.0.2.19'), IPAddress('192.0.2.20')]\n\n\n\n\nIPRange\n\n\nYou can represent an arbitrary IP address range using a lower and upper bound address in the form of an IPRange\nobject.\n\n\n ip_range = IPRange('192.168.1.0', '192.168.1.20')\n\n \n\n for i in ip_range:\n...     print i\n... \n192.168.1.0\n... snipped ...\n192.168.1.19\n192.168.1.20\n\n\n\n\nIP sets\n\n\nYou can specify either IP addresses and networks as strings. Alternatively, you can use IPAddress, IPNetwork, IPRange\nor other IPSet objects.\n\n\n IPSet(['192.0.2.0'])\nIPSet(['192.0.2.0/32'])\n\n\n\n IPSet([IPAddress('192.0.2.0')])\nIPSet(['192.0.2.0/32'])\n\n\n\n IPSet([IPNetwork('192.0.2.0/24')])\nIPSet(['192.0.2.0/24'])\n\n\n\n IPSet(IPRange(\n10.0.0.0\n, \n10.0.1.31\n))\nIPSet(['10.0.0.0/24', '10.0.1.0/27'])\n\n\n\n\nYou can interate over all the IP addresses that are members of the IP set.\n\n\n for ip in IPSet(['192.0.2.0/28']):\n...     print ip\n192.0.2.0\n192.0.2.1\n... snipped ...\n192.168.2.15\n\n\n\n\nAdding and removing set elements\n\n\n from netaddr import IPSet\n\n \n\n s1 = IPSet()\n\n \n\n s1.add('192.168.1.0/30')\n\n s1.size\n4\n\n \n\n '192.168.1.3' in s1\nTrue\n\n \n\n s1.remove('192.168.1.3')\n\n s1.size\n3\n\n\n\n\nYou can do all sorts of set operations on IPSets \n\n\n scan1 = IPSet(['192.168.1.0/30'])\n\n \n\n scan1\nIPSet(['192.168.1.0/30'])\n\n \n\n scan1.size\n4\n\n \n\n scan2 = IPSet(['192.168.1.0/31'])\n\n \n\n scan2.size\n2\n\n \n\n scan1 | scan2\nIPSet(['192.168.1.0/30'])\n\n \n\n scan1 \n scan2\nIPSet(['192.168.1.0/31'])\n\n\n\n scan1 ^ scan2\nIPSet(['192.168.1.2/31'])\n\n\n\n\n\n\nLayer 2 addressing(MAC)\n\n\nInstances of the EUI class are used to represent MAC addresses.\n\n\n mac = EUI('ec:f4:bb:87:2d:0c')\n\n\n\n\nThere are methods to print out common properties of an address\n\n\n dir(mac)\n ... snipped ... 'bin', 'bits', 'dialect', 'ei', 'eui64', 'iab',\n'info', 'ipv6', 'ipv6_link_local', 'is_iab', 'modified_eui64', 'oui',\n'packed', 'value', 'version', 'words']\n\n\n\n str(mac), str(mac.ei), str(mac.oui), str(mac.version)\n('EC-F4-BB-87-2D-0C', '87-2D-0C', 'EC-F4-BB', '48')\n\n\n\n\nThere are methods to provide info on OUI and other organizational info.\n\n\n mac.info\n{'OUI': {'address': ['one dell way',\n             'MS:RR5-45',\n             'Round rock Texas 78682',\n             'UNITED STATES'],\n 'idx': 15529147,\n 'offset': 3429092,\n 'org': 'Dell Inc',\n 'oui': 'EC-F4-BB',\n 'size': 141}}\n\n \n\n\n\n\n oui = mac.oui\n\n \n\n dir(oui)\n[ ... snipped ... 'records', 'reg_count', 'registration']\n\n \n\n oui.registration().org\n'Dell Inc'\n\n\n\n oui.registration().address\n['one dell way', 'MS:RR5-45', 'Round rock Texas 78682', 'UNITED STATES']\n\n\n\n\n\n\nExamples of netaddr usage in open source projects\n\n\n\n\nFor more examples of various netaddr modules usage in open source projects: \nPython netaddr examples", 
            "title": "netaddr"
        }, 
        {
            "location": "/libraries/netaddr/index.html#netaddr", 
            "text": "", 
            "title": "netaddr"
        }, 
        {
            "location": "/libraries/netaddr/index.html#overview", 
            "text": "A Python library for representing and manipulating network addresses.  Provides support for:  Layer 3 addresses   IPv4 and IPv6 addresses, subnets, masks, prefixes  iterating, slicing, sorting, summarizing and classifying IP networks  dealing with various ranges formats (CIDR, arbitrary ranges and globs, nmap)  set based operations (unions, intersections etc) over IP addresses and subnets  parsing a large variety of different formats and notations  looking up IANA IP block information  generating DNS reverse lookups  supernetting and subnetting   Layer 2 addresses   representation and manipulation MAC addresses and EUI-64 identifiers  looking up IEEE organisational information (OUI, IAB)  generating derived IPv6 addresses", 
            "title": "Overview"
        }, 
        {
            "location": "/libraries/netaddr/index.html#installation", 
            "text": "Install the latest  netaddr  from PIP  pip install netaddr", 
            "title": "Installation"
        }, 
        {
            "location": "/libraries/netaddr/index.html#importing-netaddr", 
            "text": "from netaddr import *   importing modules  Importing this way is not optimal and leads to name clashes. \nIn your own code, you should be explicit about the classes,\nfunctions and constants you import to avoid name clashes.", 
            "title": "Importing netaddr"
        }, 
        {
            "location": "/libraries/netaddr/index.html#layer-3-addressingip", 
            "text": "", 
            "title": "Layer 3 addressing(IP)"
        }, 
        {
            "location": "/libraries/netaddr/index.html#ipaddress", 
            "text": "IPAddress object represents a single IP address.   from netaddr import IPAddress   ip = IPAddress('192.21.8.11')  ip.version\n4  dir(ip)\n[ ... Snipped... 'bin', 'bits', 'format', 'info', 'ipv4', 'ipv6', \n'is_hostmask', 'is_ipv4_compat', 'is_ipv4_mapped', 'is_link_local',\n'is_loopback', 'is_multicast', 'is_netmask', 'is_private', 'is_reserved',\n'is_unicast', 'key', 'netmask_bits', 'packed', 'reverse_dns', 'sort_key',\n'value', 'version', 'words']    \nThere are methods to handle coverting an IP adress into binary or bits, split an IP, pack an   ip.bin\n'0b11000000000101010000100000001011'    ip.bits()\n'11000000.00010101.00001000.00001011'    ip.words\n(192, 21, 8, 11)  ip.packed\n'\\xc0\\x15\\x08\\x0b'  \nThere are methods to check if the type of IP address(class, scope, type)   ip.version\n6  ip.is_unicast()\nTrue    ip.is_link_local()\nTrue", 
            "title": "IPAddress"
        }, 
        {
            "location": "/libraries/netaddr/index.html#ipnetwork", 
            "text": "IPNetwork objects are used to represent subnets, networks or VLANs that accept CIDR prefixes and netmasks.   from netaddr import IPNetwork    ip_range = IPNetwork('192.241.21.6/24')    dir(ip_range)\n[ ... snipped ...  'broadcast', 'cidr', 'first', 'hostmask', 'info',\n'ip', 'ipv4', 'ipv6', 'is_ipv4_compat', 'is_ipv4_mapped', 'is_link_local',\n'is_loopback', 'is_multicast', 'is_private', 'is_reserved', 'is_unicast',\n'iter_hosts', 'key', 'last', 'netmask', 'network', 'next', 'prefixlen',\n'previous', 'size', 'sort_key', 'subnet', 'supernet', 'value', 'version']   There are a bunch of methods associated with IPNetwork to understand the network defined.   ip_range.network\nIPAddress('192.241.21.0')   ip_range.hostmask\nIPAddress('0.0.0.255')    ip_range.netmask\nIPAddress('255.255.255.0')   ip_range.broadcast\nIPAddress('192.241.21.255')   ip_range.size\n256  You can use a simple for loop to iterate over the list of IP addresses in the network range defined.   for i in ip_range:\n...     print i\n... \n192.241.21.0\n192.241.21.1\n... snipped ...\n192.241.21.255", 
            "title": "IPNetwork"
        }, 
        {
            "location": "/libraries/netaddr/index.html#list-operations-on-ipnetwork-object", 
            "text": "If you treat an IPNetwork object as if it were a standard Python list object it will give you access to a list of individual\nIP address objects also various standard python list methods.   ip_range = IPNetwork('192.0.2.16/29')    ip_range_list = list(ip_range)    len(ip_range_list)\n8  ip_range_list\n[IPAddress('192.0.2.16'), IPAddress('192.0.2.17'), ...snipped... IPAddress('192.0.2.23')]   ip_range_list[6]        # indexing\nIPAddress('192.0.2.22')   ip_range_list[2:5\n\n]      # slicing\n[IPAddress('192.0.2.18'), IPAddress('192.0.2.19'), IPAddress('192.0.2.20')]", 
            "title": "List operations on IPNetwork object"
        }, 
        {
            "location": "/libraries/netaddr/index.html#iprange", 
            "text": "You can represent an arbitrary IP address range using a lower and upper bound address in the form of an IPRange\nobject.   ip_range = IPRange('192.168.1.0', '192.168.1.20')    for i in ip_range:\n...     print i\n... \n192.168.1.0\n... snipped ...\n192.168.1.19\n192.168.1.20", 
            "title": "IPRange"
        }, 
        {
            "location": "/libraries/netaddr/index.html#ip-sets", 
            "text": "You can specify either IP addresses and networks as strings. Alternatively, you can use IPAddress, IPNetwork, IPRange\nor other IPSet objects.   IPSet(['192.0.2.0'])\nIPSet(['192.0.2.0/32'])   IPSet([IPAddress('192.0.2.0')])\nIPSet(['192.0.2.0/32'])   IPSet([IPNetwork('192.0.2.0/24')])\nIPSet(['192.0.2.0/24'])   IPSet(IPRange( 10.0.0.0 ,  10.0.1.31 ))\nIPSet(['10.0.0.0/24', '10.0.1.0/27'])  You can interate over all the IP addresses that are members of the IP set.   for ip in IPSet(['192.0.2.0/28']):\n...     print ip\n192.0.2.0\n192.0.2.1\n... snipped ...\n192.168.2.15", 
            "title": "IP sets"
        }, 
        {
            "location": "/libraries/netaddr/index.html#adding-and-removing-set-elements", 
            "text": "from netaddr import IPSet    s1 = IPSet()    s1.add('192.168.1.0/30')  s1.size\n4    '192.168.1.3' in s1\nTrue    s1.remove('192.168.1.3')  s1.size\n3  You can do all sorts of set operations on IPSets    scan1 = IPSet(['192.168.1.0/30'])    scan1\nIPSet(['192.168.1.0/30'])    scan1.size\n4    scan2 = IPSet(['192.168.1.0/31'])    scan2.size\n2    scan1 | scan2\nIPSet(['192.168.1.0/30'])    scan1   scan2\nIPSet(['192.168.1.0/31'])   scan1 ^ scan2\nIPSet(['192.168.1.2/31'])", 
            "title": "Adding and removing set elements"
        }, 
        {
            "location": "/libraries/netaddr/index.html#layer-2-addressingmac", 
            "text": "Instances of the EUI class are used to represent MAC addresses.   mac = EUI('ec:f4:bb:87:2d:0c')  There are methods to print out common properties of an address   dir(mac)\n ... snipped ... 'bin', 'bits', 'dialect', 'ei', 'eui64', 'iab',\n'info', 'ipv6', 'ipv6_link_local', 'is_iab', 'modified_eui64', 'oui',\n'packed', 'value', 'version', 'words']   str(mac), str(mac.ei), str(mac.oui), str(mac.version)\n('EC-F4-BB-87-2D-0C', '87-2D-0C', 'EC-F4-BB', '48')  There are methods to provide info on OUI and other organizational info.   mac.info\n{'OUI': {'address': ['one dell way',\n             'MS:RR5-45',\n             'Round rock Texas 78682',\n             'UNITED STATES'],\n 'idx': 15529147,\n 'offset': 3429092,\n 'org': 'Dell Inc',\n 'oui': 'EC-F4-BB',\n 'size': 141}}     oui = mac.oui    dir(oui)\n[ ... snipped ... 'records', 'reg_count', 'registration']    oui.registration().org\n'Dell Inc'   oui.registration().address\n['one dell way', 'MS:RR5-45', 'Round rock Texas 78682', 'UNITED STATES']   Examples of netaddr usage in open source projects   For more examples of various netaddr modules usage in open source projects:  Python netaddr examples", 
            "title": "Layer 2 addressing(MAC)"
        }, 
        {
            "location": "/libraries/netifaces/index.html", 
            "text": "netifaces\n\n\n\n\nA portable third-party library in Python to enumerate network interfaces on local machine.\n\n\nHistorically it has been difficult to straightforwardly get the network address(es) of the machine on which your Python scripts are running without compromising the portability of your script.\n\n\nnetifaces takes care of enumerating interfaces, network addresses and also preserves the portability(works on all *nix systems atleast).\n\n\n\n\nInstallation\n\n\n\n\nnetifaces needs python extension modules. In case you haven\nt already, you should install python-dev package.\n\n\n\n\nverax@humla ~ $ sudo apt-get install python-dev\n\n\n\n\n\n\nYou can install netifaces using PIP.\n\n\n\n\nverax@humla ~ $ pip install netifaces\n\n\n\n\nBasic operations\n\n\nYou can take a look at all the modules that are part of netifaces\n\n\n import netifaces\n\n \n\n dir(netifaces)\n[ ... snipped ...\n'address_families', 'gateways', 'ifaddresses', 'interfaces', 'version']\n\n \n\n\n\n\n\nGetting a list of all the network interface identifiers on the machine.\n\n\n netifaces.interfaces()\n['lo', 'eth0', 'wlan0', 'eth3', 'vboxnet0']\n\n\n\n\nYou can ask for the addresses of a particular interface\n\n\n import netifaces\n\n from pprint import pprint\n\n\n\n pprint(netifaces.ifaddresses('eth3'))\n{2: [{'addr': '192.168.1.100',\n      'broadcast': '192.168.1.255',\n      'netmask': '255.255.255.0'}],\n 10: [{'addr': 'fe80::364b:50ff:feb7:ef1d%eth3',\n       'netmask': 'ffff:ffff:ffff:ffff::/64'}],\n 17: [{'addr': '34:4b:50:b7:ef:1d', 'broadcast': 'ff:ff:ff:ff:ff:ff'}]}\n\n\n\n\n\n\npprint\n\n\n\n\npprint\n contains a \u201cpretty printer\u201d for producing aesthetically pleasing representations of your data structures.\n\n\nThe formatter produces representations of data structures that can be parsed correctly by the interpreter, and are also easy for a human to read\n\n\n\n\n\n\nYou can also get list of all the gateways\n\n\n netifaces.gateways()\n{'default': {2: ('192.168.1.1', 'eth3')}, 2: [('192.168.1.1', 'eth3', True)]}\n\n\n\n\nGetting list of IPv4 addresses excluding loopback and virtualbox adapters\n\n\n for iface in netifaces.interfaces():\n...     if iface == 'lo' or iface.startswith('vbox'):\n...         continue\n...     iface_details = netifaces.ifaddresses(iface)\n...     if iface_details.has_key(netifaces.AF_INET):\n...         print iface_details[netifaces.AF_INET]\n... \n[{'broadcast': '192.168.1.255', 'netmask': '255.255.255.0', 'addr': '192.168.1.100'}]\n[{'broadcast': '192.168.1.255', 'netmask': '255.255.255.0', 'addr': '192.168.1.101'}]\n\n\n\n\n\n\nExamples of netifaces usage in open source projects\n\n\n\n\nFor more examples of netifaces usage in open source projects: \nnetifaces examples", 
            "title": "netifaces"
        }, 
        {
            "location": "/libraries/netifaces/index.html#netifaces", 
            "text": "A portable third-party library in Python to enumerate network interfaces on local machine.  Historically it has been difficult to straightforwardly get the network address(es) of the machine on which your Python scripts are running without compromising the portability of your script.  netifaces takes care of enumerating interfaces, network addresses and also preserves the portability(works on all *nix systems atleast).", 
            "title": "netifaces"
        }, 
        {
            "location": "/libraries/netifaces/index.html#installation", 
            "text": "netifaces needs python extension modules. In case you haven t already, you should install python-dev package.   verax@humla ~ $ sudo apt-get install python-dev   You can install netifaces using PIP.   verax@humla ~ $ pip install netifaces", 
            "title": "Installation"
        }, 
        {
            "location": "/libraries/netifaces/index.html#basic-operations", 
            "text": "You can take a look at all the modules that are part of netifaces   import netifaces    dir(netifaces)\n[ ... snipped ...\n'address_families', 'gateways', 'ifaddresses', 'interfaces', 'version']    Getting a list of all the network interface identifiers on the machine.   netifaces.interfaces()\n['lo', 'eth0', 'wlan0', 'eth3', 'vboxnet0']  You can ask for the addresses of a particular interface   import netifaces  from pprint import pprint   pprint(netifaces.ifaddresses('eth3'))\n{2: [{'addr': '192.168.1.100',\n      'broadcast': '192.168.1.255',\n      'netmask': '255.255.255.0'}],\n 10: [{'addr': 'fe80::364b:50ff:feb7:ef1d%eth3',\n       'netmask': 'ffff:ffff:ffff:ffff::/64'}],\n 17: [{'addr': '34:4b:50:b7:ef:1d', 'broadcast': 'ff:ff:ff:ff:ff:ff'}]}   pprint   pprint  contains a \u201cpretty printer\u201d for producing aesthetically pleasing representations of your data structures.  The formatter produces representations of data structures that can be parsed correctly by the interpreter, and are also easy for a human to read    You can also get list of all the gateways   netifaces.gateways()\n{'default': {2: ('192.168.1.1', 'eth3')}, 2: [('192.168.1.1', 'eth3', True)]}  Getting list of IPv4 addresses excluding loopback and virtualbox adapters   for iface in netifaces.interfaces():\n...     if iface == 'lo' or iface.startswith('vbox'):\n...         continue\n...     iface_details = netifaces.ifaddresses(iface)\n...     if iface_details.has_key(netifaces.AF_INET):\n...         print iface_details[netifaces.AF_INET]\n... \n[{'broadcast': '192.168.1.255', 'netmask': '255.255.255.0', 'addr': '192.168.1.100'}]\n[{'broadcast': '192.168.1.255', 'netmask': '255.255.255.0', 'addr': '192.168.1.101'}]   Examples of netifaces usage in open source projects   For more examples of netifaces usage in open source projects:  netifaces examples", 
            "title": "Basic operations"
        }, 
        {
            "location": "/exercises/misc_exercises/index.html", 
            "text": "Miscellaneous exercises\n\n\n\n\nExercise 1\n\n\nNetwork sweeping\n\n\n\n\nWrite a script to perform network sweeping i.e. given a IP address range, find all the machines that are alive.\n\n\nUse any of the host discovery techniques that have been discussed but ARP tends to be neat and faster on local networks.\n\n\n\n\nverax@untamed  $ sudo python hd_tcp_syn.py 192.168.56.99-110\n 192.168.56.102 is alive\n 192.168.56.103 is alive\n 192.168.56.107 is alive\n\n\n\n\nExercise 2\n\n\nIP ID pattern finder\n\n\n\n\nWrite a script that takes a target IP and checks for patterns in the IP ID generation.\n\n\nBasic checks include: if the IP IDs generated are: all zeros, are all constant, are all randomized or if they are incremental.\n\n\n\n\nExample:\n\n\nverax@humla $ sudo python ipidseq.py 192.168.56.101\n\nTarget =\n 192.168.56.101\n\n[+] Sending packets to the target\n[+] Analyzing the IPID pattern\n[*] IPID generation pattern on scanme.nmap.org is randomized\n\n\n\n\nPython/Scapy tips:\n\n\n\n\nUse \nsr1\nfor sending packet and recieving first response\n\n\nPython has in-built function \nall()\n that comes handy when comparing elements in list. Looking at below examples, think about how you can use it to do other comparisions.\n\n\n\n\n lis = [0,0,0,0]\n\n all(v == 0 for v in lis)       # Checking if all elements in list are zero\nTrue \n\n\n\n\n lis = [1,4,6,9,22,65,98,354]\n\n \n\n all(x\ny for x, y in zip(lis, lis[1:]))  # Checking if the elements are in increasing order\nTrue\n\n\n\n\nMore on Python\ns \nany()\n and \nall()\n:\n\n\n\nAny and all\n \n\n\ncheck-list-monotonicity in Python\n \n\n\nHow do Python\ns any and all functions work?\n \n\n\nSolution hints I:\n\n\n\n\nSend packets to target IP address, save the IPIDs from responses in a data structure. (looping might help)\n\n\nCompare the IPIDs stored in data structure for patterns.\n\n\n\n\nExercise 3\n\n\nIP ID scanner\n\n\n\n\nYour might have found a potential \nzombie\n from the previous scan.\n\n\nWrite a script that takes a zombie_ip, victim_ip. victim_port Performs a ipid scan.(Details in the notes)\n\n\n\n\nFor more detailed discussion: \nIdle scan\n \n\n\nExample:\n\n\nverax@untamed $ sudo python ipidscanner.py 192.168.56.102 192.168.56.103 4444\n\n[+] Sending syn-ack to zombie\n\n[+] Recording initial IPID\n\n[+] Sending spoofed syn to victim\n\n[+] Sending syn-ack to zombie\n\n[+] Recording final IPID\n\n[*] Initial IPID of zombie: 14\n[*] Final IPID of zombie: 16\n\nThe port 4444 on 192.168.56.103 is open\n\n\n\n\nPython/Scapy tips:\n\n\n\n\nUse \nsr1\nor \nsend\n to send packets\n\n\nsend\n \nsr1\n and other packet sending functions take an extra argument \nverbose\n, set \nverbose=0\n to avoid scapy output.\n\n\n\n\nSolution:\n\n\nidle scan consists of three steps that are repeated for each port:\n\n\n\n\n\n\nProbe the zombie\ns IPID and record it. (Send a syn-ack to zombie, record ipid in response)\n\n\n\n\n\n\nForge a SYN packet with zombie IP as source and victim IP, victim port as destination. \n\n\n\n\n\n\nProbe the zombie\ns IP ID again. The target port state is then determined by comparing this new IP ID with the one recorded in step 1.\n\n\n\n\n\n\nAt this point, if the \nzombie\ns IPID increased by one\n that the zombie hasn\nt sent out any packets, except for its reply to the attacker\ns probe. THis is an indication that the target port might be closed on victim.\n\n\n\n\n\n\nIf the \nzombie\ns IPID increased by two\n, it means the zombie sent out a packet between the two probes. This is an indication that the target port is open on the victim.\n\n\n\n\n\n\nIf zombie IPIP increases by more than two, it usually indicates a bad zombie host. It might not have predictable IPID numbers, or might be engaged in communication unrelated to the idle scan.\n\n\n\n\n\n\nExercise 4\n\n\nPacket hunting\n\n\n\n\nYou are given a PCAP \nboston2016\n, this PCAP is suspected to be having covert channel activity. (someone trying to transfer data in packet using unsual methods).\n\n\nYour task is to analyze this packet capture and find out the hidden data.\n\n\n\n\nPython/Scapy tips:\n\n\n\n\nrdpcap\n to read a pcap.\n\n\npacket[protocol]\n to extract protocol specific content.\n\n\npacket[protocol].field\n to extract field\n\n\nformat(text,'04x')\n is how you format into proper hex format in Python.\n\n\nUse join method to joing elements of a list \n\".\".join([192, 168, 99, 24])\n \n 192.168.99.24\n\n\n\n\nSolution hints I:\n\n\nThis is not a packet analysis or CTF class so I\nll describe the solution in plain terms here, try to codify it using Scapy.\n\n\n\n\nThe covert activity might be happening through UDP checksums.\n\n\n\n\nSolution hints II:\n\n\nSpoilers ahead\n\n\n\n\nThe data is being exfiltrated by one party through checksums.\n\n\nTo be specific, UDP checksums in DNS queries is where the data is. - Extract the checksums from DNS queries.\n\n\nYou have to read the checksums in \n0x:(hex) format first. \nformat(text,'0x')\n\n\nDecode the hex checksums into ascii and that\ns the exfiltrated data.\n\n\n\n\nExercise 5\n\n\nDummy network scanner\n\n\n\n\n\n\nA client wants you to do a security audit on their network. Client provided you with a network range to scan and set of IP addresses to exclude from scan.\n\n\n\n\n\n\nBefore you run an actual network scan, write a script that lists all the IP addresses that falls under scan(similar to Nmap list scan). (Network range provided by client minus IP addresses to be excluded)\n\n\n\n\n\n\nBoilerplate syntax is provided, can be found in code directory\n\n\nExample:\n\n\nxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxxxx\n\n\n\n\n\n\nHints:\n\n\n\n\nnetaddr\n library deals with Layer 3 addressing.\n\n\nnetaddr.IPSet\n has a remove method to remove elements.\n\n\n\n\n\n\nExercise 6\n\n\nLocal network interface enumeration.\n\n\n\n\nUse a python library to list all the interfaces on your machine, find as much as you can(interface labels, addressing etc).\n\n\nWhen you print the output, make sure it\ns easily readable.\n\n\n\n\nHints:\n\n\n\n\nnetifaces\n helps enumerate local interfaces.\n\n\nstring \n.format\n method and \npprint\n helps you print stuff beautifully in Python.", 
            "title": "Misc exercises"
        }, 
        {
            "location": "/exercises/misc_exercises/index.html#miscellaneous-exercises", 
            "text": "", 
            "title": "Miscellaneous exercises"
        }, 
        {
            "location": "/exercises/misc_exercises/index.html#exercise-1", 
            "text": "", 
            "title": "Exercise 1"
        }, 
        {
            "location": "/exercises/misc_exercises/index.html#network-sweeping", 
            "text": "Write a script to perform network sweeping i.e. given a IP address range, find all the machines that are alive.  Use any of the host discovery techniques that have been discussed but ARP tends to be neat and faster on local networks.   verax@untamed  $ sudo python hd_tcp_syn.py 192.168.56.99-110\n 192.168.56.102 is alive\n 192.168.56.103 is alive\n 192.168.56.107 is alive", 
            "title": "Network sweeping"
        }, 
        {
            "location": "/exercises/misc_exercises/index.html#exercise-2", 
            "text": "", 
            "title": "Exercise 2"
        }, 
        {
            "location": "/exercises/misc_exercises/index.html#ip-id-pattern-finder", 
            "text": "Write a script that takes a target IP and checks for patterns in the IP ID generation.  Basic checks include: if the IP IDs generated are: all zeros, are all constant, are all randomized or if they are incremental.   Example:  verax@humla $ sudo python ipidseq.py 192.168.56.101\n\nTarget =  192.168.56.101\n\n[+] Sending packets to the target\n[+] Analyzing the IPID pattern\n[*] IPID generation pattern on scanme.nmap.org is randomized", 
            "title": "IP ID pattern finder"
        }, 
        {
            "location": "/exercises/misc_exercises/index.html#pythonscapy-tips", 
            "text": "Use  sr1 for sending packet and recieving first response  Python has in-built function  all()  that comes handy when comparing elements in list. Looking at below examples, think about how you can use it to do other comparisions.    lis = [0,0,0,0]  all(v == 0 for v in lis)       # Checking if all elements in list are zero\nTrue    lis = [1,4,6,9,22,65,98,354]    all(x y for x, y in zip(lis, lis[1:]))  # Checking if the elements are in increasing order\nTrue  More on Python s  any()  and  all() :  Any and all    check-list-monotonicity in Python    How do Python s any and all functions work?", 
            "title": "Python/Scapy tips:"
        }, 
        {
            "location": "/exercises/misc_exercises/index.html#solution-hints-i", 
            "text": "Send packets to target IP address, save the IPIDs from responses in a data structure. (looping might help)  Compare the IPIDs stored in data structure for patterns.", 
            "title": "Solution hints I:"
        }, 
        {
            "location": "/exercises/misc_exercises/index.html#exercise-3", 
            "text": "", 
            "title": "Exercise 3"
        }, 
        {
            "location": "/exercises/misc_exercises/index.html#ip-id-scanner", 
            "text": "Your might have found a potential  zombie  from the previous scan.  Write a script that takes a zombie_ip, victim_ip. victim_port Performs a ipid scan.(Details in the notes)   For more detailed discussion:  Idle scan    Example:  verax@untamed $ sudo python ipidscanner.py 192.168.56.102 192.168.56.103 4444\n\n[+] Sending syn-ack to zombie\n\n[+] Recording initial IPID\n\n[+] Sending spoofed syn to victim\n\n[+] Sending syn-ack to zombie\n\n[+] Recording final IPID\n\n[*] Initial IPID of zombie: 14\n[*] Final IPID of zombie: 16\n\nThe port 4444 on 192.168.56.103 is open", 
            "title": "IP ID scanner"
        }, 
        {
            "location": "/exercises/misc_exercises/index.html#pythonscapy-tips_1", 
            "text": "Use  sr1 or  send  to send packets  send   sr1  and other packet sending functions take an extra argument  verbose , set  verbose=0  to avoid scapy output.", 
            "title": "Python/Scapy tips:"
        }, 
        {
            "location": "/exercises/misc_exercises/index.html#solution", 
            "text": "idle scan consists of three steps that are repeated for each port:    Probe the zombie s IPID and record it. (Send a syn-ack to zombie, record ipid in response)    Forge a SYN packet with zombie IP as source and victim IP, victim port as destination.     Probe the zombie s IP ID again. The target port state is then determined by comparing this new IP ID with the one recorded in step 1.    At this point, if the  zombie s IPID increased by one  that the zombie hasn t sent out any packets, except for its reply to the attacker s probe. THis is an indication that the target port might be closed on victim.    If the  zombie s IPID increased by two , it means the zombie sent out a packet between the two probes. This is an indication that the target port is open on the victim.    If zombie IPIP increases by more than two, it usually indicates a bad zombie host. It might not have predictable IPID numbers, or might be engaged in communication unrelated to the idle scan.", 
            "title": "Solution:"
        }, 
        {
            "location": "/exercises/misc_exercises/index.html#exercise-4", 
            "text": "", 
            "title": "Exercise 4"
        }, 
        {
            "location": "/exercises/misc_exercises/index.html#packet-hunting", 
            "text": "You are given a PCAP  boston2016 , this PCAP is suspected to be having covert channel activity. (someone trying to transfer data in packet using unsual methods).  Your task is to analyze this packet capture and find out the hidden data.", 
            "title": "Packet hunting"
        }, 
        {
            "location": "/exercises/misc_exercises/index.html#pythonscapy-tips_2", 
            "text": "rdpcap  to read a pcap.  packet[protocol]  to extract protocol specific content.  packet[protocol].field  to extract field  format(text,'04x')  is how you format into proper hex format in Python.  Use join method to joing elements of a list  \".\".join([192, 168, 99, 24])    192.168.99.24", 
            "title": "Python/Scapy tips:"
        }, 
        {
            "location": "/exercises/misc_exercises/index.html#solution-hints-i_1", 
            "text": "This is not a packet analysis or CTF class so I ll describe the solution in plain terms here, try to codify it using Scapy.   The covert activity might be happening through UDP checksums.", 
            "title": "Solution hints I:"
        }, 
        {
            "location": "/exercises/misc_exercises/index.html#solution-hints-ii", 
            "text": "Spoilers ahead   The data is being exfiltrated by one party through checksums.  To be specific, UDP checksums in DNS queries is where the data is. - Extract the checksums from DNS queries.  You have to read the checksums in  0x:(hex) format first.  format(text,'0x')  Decode the hex checksums into ascii and that s the exfiltrated data.", 
            "title": "Solution hints II:"
        }, 
        {
            "location": "/exercises/misc_exercises/index.html#exercise-5", 
            "text": "", 
            "title": "Exercise 5"
        }, 
        {
            "location": "/exercises/misc_exercises/index.html#dummy-network-scanner", 
            "text": "A client wants you to do a security audit on their network. Client provided you with a network range to scan and set of IP addresses to exclude from scan.    Before you run an actual network scan, write a script that lists all the IP addresses that falls under scan(similar to Nmap list scan). (Network range provided by client minus IP addresses to be excluded)    Boilerplate syntax is provided, can be found in code directory", 
            "title": "Dummy network scanner"
        }, 
        {
            "location": "/exercises/misc_exercises/index.html#example", 
            "text": "xxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxxxx", 
            "title": "Example:"
        }, 
        {
            "location": "/exercises/misc_exercises/index.html#hints", 
            "text": "netaddr  library deals with Layer 3 addressing.  netaddr.IPSet  has a remove method to remove elements.", 
            "title": "Hints:"
        }, 
        {
            "location": "/exercises/misc_exercises/index.html#exercise-6", 
            "text": "", 
            "title": "Exercise 6"
        }, 
        {
            "location": "/exercises/misc_exercises/index.html#local-network-interface-enumeration", 
            "text": "Use a python library to list all the interfaces on your machine, find as much as you can(interface labels, addressing etc).  When you print the output, make sure it s easily readable.", 
            "title": "Local network interface enumeration."
        }, 
        {
            "location": "/exercises/misc_exercises/index.html#hints_1", 
            "text": "netifaces  helps enumerate local interfaces.  string  .format  method and  pprint  helps you print stuff beautifully in Python.", 
            "title": "Hints:"
        }, 
        {
            "location": "/exercises/network_hunt/index.html", 
            "text": "Let\ns go Network hunting!\n\n\nTrivia\n\n\n\n\n\n\nTerminal-based game in which you will use common network attack vectors and penetration testing methods to analyze and compromise a virtual network.\n\n\n\n\n\n\nInvolves Network Security challenges designed to educate users on packet manipulation and common network attacks.\n\n\n\n\n\n\nThe whole challenge happens over sort of a software defined network(SDN).\n\n\n\n\n\n\nOriginally created by James Sullivan(MIT License), modified by us for a workshop setting.\n\n\n\n\n\n\n\n\nNetwork Hunt\n\n\n\n\nThe network hunt is a simple Software Defined Network \n\n\nThe network is completely defined by handcrafted packets using scapy/python which simulates a typical network setup.\n\n\n\n\n\n\nThe Goal\n\n\nThere is an FTP server somewhere on the network containing a document:\n\n\n\n\nLocate the FTP server\n\n\nConnect to the service \n\n\nRetrieve the file!\n\n\n\n\nTools\n\n\n\n\nscapy\n\n\nnmap\n\n\nwireshark or maybe \nwireshark\n\n\ntelnet/nc\n\n\ndsniff\n\n\n\n\nConcepts\n\n\n\n\nBash terminal-fu\n\n\nPacket capture and manipulation in scapy\n\n\nPacket analysis in wireshark\n\n\nRouter modes of operation\n\n\nNetwork topography, gateways\n\n\nBasic telnet/nc commands\n\n\n\n\n\n\nHints\n\n\n\n\nYou may need to find a way to see all of the traffic on the network.\n\n\nOther clients on the network might give you useful clues, if you can coerce them.\n\n\nThe target will most likely be isolated from the immediate local network, and will have some preferred clients.\n\n\n\n\n\n\nTASKS\n\n\nTASK - I\n\n\nRun the script \n find the details about the interface.\n\n\nTASK - II\n\n\nUnderstand the Network.\n\n\n\n\nIs there any traffic on the network?\n\n\nAre there devices connected to the network?\n\n\n\n\nTASK - III\n\n\n\n\nHow to gain access to traffic beyond a network domain?\n\n\nThe nature of layer 2 switches.\n\n\n\n\nScapy tips:\n\n- RandMAC() - Generates random MAC addresses.\n\n- RandIP() - Generates random IP addresses. \n\n\nTASK - IV\n\n\nTASK - V\n\n\nTASK - VI\n\n\nTASK - VIII", 
            "title": "Network Hunt"
        }, 
        {
            "location": "/exercises/network_hunt/index.html#lets-go-network-hunting", 
            "text": "", 
            "title": "Let's go Network hunting!"
        }, 
        {
            "location": "/exercises/network_hunt/index.html#trivia", 
            "text": "Terminal-based game in which you will use common network attack vectors and penetration testing methods to analyze and compromise a virtual network.    Involves Network Security challenges designed to educate users on packet manipulation and common network attacks.    The whole challenge happens over sort of a software defined network(SDN).    Originally created by James Sullivan(MIT License), modified by us for a workshop setting.     Network Hunt   The network hunt is a simple Software Defined Network   The network is completely defined by handcrafted packets using scapy/python which simulates a typical network setup.", 
            "title": "Trivia"
        }, 
        {
            "location": "/exercises/network_hunt/index.html#the-goal", 
            "text": "There is an FTP server somewhere on the network containing a document:   Locate the FTP server  Connect to the service   Retrieve the file!", 
            "title": "The Goal"
        }, 
        {
            "location": "/exercises/network_hunt/index.html#tools", 
            "text": "scapy  nmap  wireshark or maybe  wireshark  telnet/nc  dsniff", 
            "title": "Tools"
        }, 
        {
            "location": "/exercises/network_hunt/index.html#concepts", 
            "text": "Bash terminal-fu  Packet capture and manipulation in scapy  Packet analysis in wireshark  Router modes of operation  Network topography, gateways  Basic telnet/nc commands    Hints   You may need to find a way to see all of the traffic on the network.  Other clients on the network might give you useful clues, if you can coerce them.  The target will most likely be isolated from the immediate local network, and will have some preferred clients.", 
            "title": "Concepts"
        }, 
        {
            "location": "/exercises/network_hunt/index.html#tasks", 
            "text": "", 
            "title": "TASKS"
        }, 
        {
            "location": "/exercises/network_hunt/index.html#task-i", 
            "text": "Run the script   find the details about the interface.", 
            "title": "TASK - I"
        }, 
        {
            "location": "/exercises/network_hunt/index.html#task-ii", 
            "text": "Understand the Network.   Is there any traffic on the network?  Are there devices connected to the network?", 
            "title": "TASK - II"
        }, 
        {
            "location": "/exercises/network_hunt/index.html#task-iii", 
            "text": "How to gain access to traffic beyond a network domain?  The nature of layer 2 switches.   Scapy tips: \n- RandMAC() - Generates random MAC addresses. \n- RandIP() - Generates random IP addresses.", 
            "title": "TASK - III"
        }, 
        {
            "location": "/exercises/network_hunt/index.html#task-iv", 
            "text": "", 
            "title": "TASK - IV"
        }, 
        {
            "location": "/exercises/network_hunt/index.html#task-v", 
            "text": "", 
            "title": "TASK - V"
        }, 
        {
            "location": "/exercises/network_hunt/index.html#task-vi", 
            "text": "", 
            "title": "TASK - VI"
        }, 
        {
            "location": "/exercises/network_hunt/index.html#task-viii", 
            "text": "", 
            "title": "TASK - VIII"
        }, 
        {
            "location": "/epilogue/moving_forward/index.html", 
            "text": "Moving forward\n\n\n\n\nScapy project needs more contributors.\n\n\nThere is a lot of scope for improvement and it makes a great starting place for contributing to open source.\n\n\nWrite add-ons, protocol dissector, jupyter notebooks, improve documentation etc.\n\n\nFind a problem/technique/utility.. code it yourself!", 
            "title": "Moving forward"
        }, 
        {
            "location": "/epilogue/moving_forward/index.html#moving-forward", 
            "text": "Scapy project needs more contributors.  There is a lot of scope for improvement and it makes a great starting place for contributing to open source.  Write add-ons, protocol dissector, jupyter notebooks, improve documentation etc.  Find a problem/technique/utility.. code it yourself!", 
            "title": "Moving forward"
        }, 
        {
            "location": "/epilogue/feedback/index.html", 
            "text": "Feedback \n Suggestions\n\n\n\n\nSlack channel\n\n\n\n\nCredits\n\n\nnull - The Open Security Community. \n |  \n \nhttp://swachalit.null.co.in/\n\nPhillipe Biondi for Scapy tool \n excellent literature on it.  \n |  \n \nhttp://secdev.org/\n\nJames Sullivan for his brilliant ScapyHunt program. \n |  \n \nhttps://github.com/JamesSullivan1/scapyHunt/\n\nPeople at packetstan esp. Judy Novak. \n |  \n \npacketstan.com\n\nTom Christie, Dougal Matthews for their beautiful documentation generator \n |  \n \nmkdocs.org\n\niphelix from The Sprawl | \nScapy Intro @ The Sprawl", 
            "title": "Feedback"
        }, 
        {
            "location": "/epilogue/feedback/index.html#feedback-suggestions", 
            "text": "Slack channel", 
            "title": "Feedback &amp; Suggestions"
        }, 
        {
            "location": "/epilogue/feedback/index.html#credits", 
            "text": "null - The Open Security Community.   |     http://swachalit.null.co.in/ \nPhillipe Biondi for Scapy tool   excellent literature on it.    |     http://secdev.org/ \nJames Sullivan for his brilliant ScapyHunt program.   |     https://github.com/JamesSullivan1/scapyHunt/ \nPeople at packetstan esp. Judy Novak.   |     packetstan.com \nTom Christie, Dougal Matthews for their beautiful documentation generator   |     mkdocs.org \niphelix from The Sprawl |  Scapy Intro @ The Sprawl", 
            "title": "Credits"
        }
    ]
}